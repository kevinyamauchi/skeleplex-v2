{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to the Skeleplex docs","text":"<p>This is a not-yet-working refactor of the Skeleplex pipeline. Please check back later!</p>"},{"location":"app/","title":"SkelePlex application","text":""},{"location":"app/#events","title":"Events","text":""},{"location":"app/#loading-data","title":"Loading data","text":"<p>This sequence is for loading data from the GUI. The events are connected in skeleplex.app.model.SkeleplexApp._connect_data_events()</p> <ol> <li>Load data button clicked: skeleplex.app.qt.app_controls.AppControlsWidget.load_data_widget.called()</li> <li>Event received by skeleplex.app.model.SkeleplexApp._load_data_clicked(). The new paths are set in the data manager (skeleplex.app.data.DataManager) and the data manager emits the DataManager.events.data() event.</li> <li>The data() event is received by the SkeleplexApp.load_main_viewer() and the data are loaded into the viewer.</li> </ol>"},{"location":"euler/","title":"Running SkelePlex on ETH Euler Cluster","text":""},{"location":"euler/#making-the-environment-on-euler","title":"Making the Environment on Euler","text":"<ol> <li>Connect to the ETH network, either by using the on-side wifi/Ethernet or by using a VPN</li> <li>Start a terminal</li> <li>Use ssh command to connect to the login node of Euler: <code>ssh username@euler.ethz.ch</code>, use your regular ETH password to connect</li> <li>First use only: clone SkelePlex-V2 to your working directory (e.g., /cluster/home/username/), you might have to add an SHH key for this step, follow tutorial on:add SHH key GitHub</li> <li>cd into the folder where SkelePlex-V2 is installed </li> <li>Create a new virtual environment using these commands:<ol> <li>Load module stack with pre-installed packages: <code>module load stack/2024-06 python_cuda/3.11.6</code></li> <li>Create new virtual environment called skeleplexenv: <code>python -m venv --system-site-packages skeleplexenv</code></li> <li>Activate your new virtual environment called skeleplexenv: <code>source skeleplexenv/bin/activate</code></li> <li>Install skeleplex into that virtual environment:<code>pip install -e \".[dev-all]\"</code></li> <li>Install cuda into that virtual environment:<code>pip install cupy-cuda12x</code></li> </ol> </li> </ol>"},{"location":"euler/#send-your-data-to-euler","title":"Send your Data to Euler","text":"<p>This is how to upload a file to a specific folder on Euler, for large .zarr files it is recommended to send them in a compressed format and then unzip on Euler. 1. Sent to Euler: <code>rsync -av  /path/to/file/yourimage.zarr.zip  username@euler.ethz.ch:/cluster/where/you/save/data</code> 2. Unzip file on Euler: <code>unzip yourimage.zarr.zip</code></p>"},{"location":"euler/#write-and-run-the-job-script-on-euler","title":"Write and Run the Job Script on Euler","text":"<ul> <li>Create a new file containing your skeleplex job: <code>nano skeleplex_job.sh</code></li> <li> <p>Write the Job Script, set the requirements according to your needs, use the HPC - Slurm Submission Line Advisor for the set-up. See an example below:</p> <p>```#!/bin/bash</p> </li> <li> <p>Save the file (<code>Ctrl+X</code>, then <code>Y</code>, then <code>Enter</code> in nano).</p> </li> <li>To ensure that SkelePlex can be accessed run the following command before submitting your job: <code>module load eth_proxy</code></li> <li>Then, submit the job: <code>sbatch skeleplex_job.sh</code>. You will obtain a job ID that you can use to look into the status of your submission: <code>squeue -j 12345678</code> (replace with your actual job ID) or <code>myjobs -j 12345678</code> for more detailed information (for both commands, replace with actual job ID).</li> <li>You can view the output file with this line: <code>cat skeleplex_job_12345678.out</code> (replace with actual job ID).</li> </ul>"},{"location":"euler/#sbatch-job-nameskeleplex_job","title":"SBATCH --job-name=skeleplex_job","text":""},{"location":"euler/#sbatch-time040000","title":"SBATCH --time=04:00:00","text":""},{"location":"euler/#sbatch-ntasks1","title":"SBATCH --ntasks=1","text":""},{"location":"euler/#sbatch-cpus-per-task4","title":"SBATCH --cpus-per-task=4","text":""},{"location":"euler/#sbatch-mem-per-cpu64g","title":"SBATCH --mem-per-cpu=64G","text":""},{"location":"euler/#sbatch-gpusrtx_40901","title":"SBATCH --gpus=rtx_4090:1","text":""},{"location":"euler/#sbatch-outputskeleplex_job_jout","title":"SBATCH --output=skeleplex_job_%j.out","text":"<p>python skeleplex_job.py --workers 1</p> <p>echo \"Job completed: $(date)\"```</p>"},{"location":"euler/#retrieve-data-from-euler","title":"Retrieve Data from Euler","text":"<p>This is how you can pull back the output files to your local computer: <code>rsync -av username@euler.ethz.ch:cluster/where/you/save/data/*.zarr /path/to/save/file/to/here/</code></p>"},{"location":"euler/#resources-used-in-above-text","title":"Resources used in above Text:","text":"<ul> <li>HPC - first job on Euler</li> <li>HPC - Slurm Submission Line Advisor </li> <li>Add SHH key GitHub</li> </ul>"},{"location":"segmentation_to_image_lazy/","title":"Tutorial: Lazy Graph Construction from 3D Segmentation","text":"<p>This tutorial demonstrates how to compute a distance transform, perform chunkwise skeleton prediction using a pretrained model, and construct a skeleton graph from a 3D segmentation using the SkelePlex framework.</p>"},{"location":"segmentation_to_image_lazy/#step-1-generate-example-data","title":"Step 1: Generate Example Data","text":"<p>We start with a synthetic 3D bifurcating tree structure. This serves as an example of a segmented object with branching topology. All scripts used in this rundown are found in <code>examples/segmentation_to_graph/</code> . You can generate the data using the provided script 'create_example_data.py', which:</p> <ul> <li>Creates a 3D binary tree-like structure</li> <li>Applies 3D dilation to thicken the branches</li> <li>Saves the result in zarr format as 'bifurcating_tree.zarr'</li> </ul> <p>This file will be used as the input segmentation for the subsequent processing steps.</p>"},{"location":"segmentation_to_image_lazy/#step-2-predict-skeleton-from-segmentation","title":"Step 2: Predict Skeleton from Segmentation","text":"<p>The script 'predict_skeleton.py' computes a local normalized distance transform from the binary segmentation and performs skeleton prediction using a pretrained model.</p> <p>This step includes:</p> <ul> <li>Computing the local distance field using chunked processing</li> <li>Predicting a skeleton using the pretrained 'MultiscaleSkeletonizationNet'</li> <li>Masking the predicted skeleton with the original segmentation</li> <li>Saving the outputs in zarr format</li> </ul> <p>The resulting skeleton will serve as the basis for graph construction in the next step.</p>"},{"location":"segmentation_to_image_lazy/#step-3-postprocess-and-threshold-the-skeleton-prediction","title":"Step 3: Postprocess and Threshold the Skeleton Prediction","text":"<p>The script 'create_skeleton.py' converts the skeleton prediction into a binary skeleton mask and refines it using classical morphological skeletonization.</p> <p>This step includes:</p> <ul> <li>Thresholding the predicted skeleton to create a binary mask</li> <li>Applying a voxel-wise skeletonization ('skimage.morphology.skeletonize') in chunks using 'map_overlap'</li> <li>Saving the final skeleton to zarr format</li> </ul> <p>The output is a binarized skeleton that can be used for graph construction.</p>"},{"location":"segmentation_to_image_lazy/#step-4-construct-the-graph-from-the-skeleton","title":"Step 4: Construct the Graph from the Skeleton","text":"<p>The script 'create_graph.py' converts the final binary skeleton into a graph representation and stores it as a JSON file for further analysis or visualization.</p> <p>This step includes:</p> <ul> <li>Computing the degree of each skeleton voxel</li> <li>Removing isolated voxels with no connected neighbors</li> <li>Assigning unique IDs to each voxel in the skeleton</li> <li>Constructing edge paths and a connectivity table from the labeled components</li> <li>Creating a 'SkeletonGraph' object from the voxel graph</li> <li>Saving the resulting graph in JSON format</li> </ul> <p>The output graph structure captures the connectivity and geometry of the original 3D skeleton and can be further processed or visualized using the SkelePlex viewer or other tools.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>skeleplex<ul> <li>app<ul> <li>_app</li> <li>_constants</li> <li>_curate</li> <li>_data</li> <li>_utils</li> <li>_viewer_controller</li> <li>actions</li> <li>cellier<ul> <li>utils</li> </ul> </li> <li>functions</li> <li>qt<ul> <li>app_controls</li> <li>auxiliary_views</li> <li>flat_group_box</li> <li>main_viewer</li> <li>styles</li> <li>window</li> </ul> </li> </ul> </li> <li>data<ul> <li>bifurcating_tree</li> <li>fractal_trees</li> <li>skeleton_image</li> <li>skeletons</li> <li>tubes</li> <li>utils</li> <li>y_junctions</li> </ul> </li> <li>graph<ul> <li>break_detection</li> <li>constants</li> <li>image_to_graph</li> <li>image_to_graph_lazy</li> <li>modify_graph</li> <li>sample</li> <li>skeleton_graph</li> <li>spline</li> <li>utils</li> </ul> </li> <li>measurements<ul> <li>angles</li> <li>branches</li> <li>fit_surface</li> <li>graph_properties</li> <li>lumen_classifier</li> <li>utils</li> </ul> </li> <li>skeleton<ul> <li>_chunked_label</li> <li>_chunked_upscale</li> <li>_segment</li> <li>_skeletonize</li> <li>_upscale</li> <li>_utils</li> <li>distance_field</li> </ul> </li> <li>utils<ul> <li>_chunked</li> <li>_geometry</li> </ul> </li> <li>visualize<ul> <li>_color</li> <li>spline</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/skeleplex/","title":"skeleplex","text":""},{"location":"reference/skeleplex/#skeleplex","title":"skeleplex","text":"<p>A Python package for analyzing skeletons.</p> <p>Modules:</p> <ul> <li> <code>app</code>           \u2013            <p>A desktop application for viewing and curating a skeleton.</p> </li> <li> <code>data</code>           \u2013            <p>Example data.</p> </li> <li> <code>graph</code>           \u2013            <p>Tools to create a graph of a skeleton.</p> </li> <li> <code>measurements</code>           \u2013            <p>Tools to compute properties of a skeleton.</p> </li> <li> <code>skeleton</code>           \u2013            <p>Tools to create a skeleton image of a structure.</p> </li> <li> <code>utils</code>           \u2013            <p>Utilities for operating on the skeleton.</p> </li> <li> <code>visualize</code>           \u2013            <p>Module for interactive visualization and curation of the skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/app/","title":"app","text":""},{"location":"reference/skeleplex/app/#skeleplex.app","title":"skeleplex.app","text":"<p>A desktop application for viewing and curating a skeleton.</p> <p>Modules:</p> <ul> <li> <code>actions</code>           \u2013            <p>Actions to be registered for the application.</p> </li> <li> <code>cellier</code>           \u2013            <p>Cellier rendering module.</p> </li> <li> <code>functions</code>           \u2013            <p>Functions for the app.</p> </li> <li> <code>qt</code>           \u2013            <p>Qt widgets for the SkelePlex app.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DataManager</code>           \u2013            <p>A class to manage data.</p> </li> <li> <code>SkelePlexApp</code>           \u2013            <p>The main application class.</p> </li> <li> <code>SkeletonDataPaths</code>           \u2013            <p>A class storing the state of the skeleton dataset.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Start the Qt application event loop.</p> </li> <li> <code>view_skeleton</code>             \u2013              <p>Launch the skeleton viewer application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager","title":"DataManager","text":"<pre><code>DataManager(file_paths: SkeletonDataPaths, selection: SelectionManager | None = None, edge_colormap: EdgeColormap | None = None, load_data: bool = True)\n</code></pre> <p>A class to manage data.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>events</code>               (<code>DataEvents</code>)           \u2013            <p>The events for the DataManager class.</p> </li> <li> <code>node_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates of the nodes in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for the nodes in the skeleton graph. This is index-matched with the node_coordinates array. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates for rendering the edges in the skeleton graph as line segments. Each edge is rendered as a sequence of line segments. All line segments are stored in this array. The array has shape (n_line_segments * 2, 3) where line segment n is defined by the start coordinate edge_coordinates[n * 2, :] and end coordinate edge_coordinates[n * 2 + 1, :]. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_indices</code>               (<code>ndarray | None</code>)           \u2013            <p>The indices for the edges in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for edges of each edge coordinate in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_colors</code>               (<code>ndarray | None</code>)           \u2013            <p>The colors for the edges in the skeleton graph. These are index-matched with the edge_coordinates array.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              <p>Load data.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Convert to json-serializable dictionary.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    file_paths: SkeletonDataPaths,\n    selection: SelectionManager | None = None,\n    edge_colormap: EdgeColormap | None = None,\n    load_data: bool = True,\n) -&gt; None:\n    self._file_paths = file_paths\n\n    self._view = DataView(\n        data_manager=self, mode=ViewMode.ALL, bounding_box=BoundingBoxData()\n    )\n\n    # make the selection model\n    if selection is None:\n        selection = SelectionManager(\n            edge=EdgeSelectionManager(enabled=False, values=set()),\n            node=NodeSelectionManager(enabled=False, values=set()),\n        )\n    self._selection = selection\n\n    # make the edge colormap\n    if edge_colormap is None:\n        # default edge color is blue\n        edge_colormap = EdgeColormap(\n            colormap={}, default_color=Color([0.0, 0.0, 1.0, 1.0])\n        )\n    self._edge_colormap = edge_colormap\n\n    # initialize the data\n    self._skeleton_graph: SkeletonGraph | None = None\n    self._node_coordinates: np.ndarray | None = None\n    self._edge_coordinates: np.ndarray | None = None\n    self._edge_indices: np.ndarray | None = None\n    self._edge_keys: np.ndarray | None = None\n    self._edge_colors: np.ndarray | None = None\n\n    if self.file_paths.has_paths() and load_data:\n        self.load()\n\n    # connect the event for updating the view when the data is changed\n    self.events.data.connect(self._view.update)\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager(file_paths)","title":"<code>file_paths</code>","text":"(<code>SkeletonDataPaths</code>)           \u2013            <p>The paths to the data files.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager(selection)","title":"<code>selection</code>","text":"(<code>SelectionManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The selection manager.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_colormap","title":"edge_colormap  <code>property</code> <code>writable</code>","text":"<pre><code>edge_colormap: EdgeColormap\n</code></pre> <p>Get the edge colormap.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_colors","title":"edge_colors  <code>property</code>","text":"<pre><code>edge_colors: ndarray | None\n</code></pre> <p>Get the colors of each edge line segment.</p> <p>(n_edges x 2 x n_points_per_edge, 4) array of RGBA colors.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_coordinates","title":"edge_coordinates  <code>property</code>","text":"<pre><code>edge_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge, 3) array of edge coordinates.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_indices","title":"edge_indices  <code>property</code>","text":"<pre><code>edge_indices: ndarray | None\n</code></pre> <p>Get the indices of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge indices.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.edge_keys","title":"edge_keys  <code>property</code>","text":"<pre><code>edge_keys: ndarray | None\n</code></pre> <p>Get the keys of the edge for each edge coordinate in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge keys.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.file_paths","title":"file_paths  <code>property</code>","text":"<pre><code>file_paths: SkeletonDataPaths\n</code></pre> <p>Get the file paths.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the nodes in the skeleton graph.</p> <p>(n_nodes, 3) array of node coordinates.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.node_keys","title":"node_keys  <code>property</code>","text":"<pre><code>node_keys: ndarray | None\n</code></pre> <p>Get the keys of the nodes in the skeleton graph.</p> <p>(n_nodes,) array of node keys. These are index-matched with the node_coordinates array.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.selection","title":"selection  <code>property</code>","text":"<pre><code>selection: SelectionManager\n</code></pre> <p>Get the current data selection.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.skeleton_graph","title":"skeleton_graph  <code>property</code>","text":"<pre><code>skeleton_graph: SkeletonGraph\n</code></pre> <p>Get the skeleton graph.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.view","title":"view  <code>property</code>","text":"<pre><code>view: DataView\n</code></pre> <p>Get the current data view.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.load","title":"load","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load data.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load data.\"\"\"\n    # load the skeleton graph\n    if self.file_paths.skeleton_graph:\n        log.info(f\"Loading skeleton graph from {self.file_paths.skeleton_graph}\")\n        self._skeleton_graph = SkeletonGraph.from_json_file(\n            self.file_paths.skeleton_graph\n        )\n        self._update_node_coordinates()\n        self._update_edge_coordinates()\n        self._update_edge_colors()\n    else:\n        log.info(\"No skeleton graph loaded.\")\n        self._skeleton_graph = None\n\n    self.events.data.emit()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.DataManager.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert to json-serializable dictionary.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert to json-serializable dictionary.\"\"\"\n    return self._data.to_dict()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp","title":"SkelePlexApp","text":"<pre><code>SkelePlexApp(data: DataManager | None = None, selection: SelectionManager | None = None)\n</code></pre> <p>               Bases: <code>Application</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.SkelePlexApp[SkelePlexApp]\n\n              \n\n              click skeleplex.app.SkelePlexApp href \"\" \"skeleplex.app.SkelePlexApp\"\n            </code></pre> <p>The main application class.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the right dock of the main window.</p> </li> <li> <code>add_points</code>             \u2013              <p>Add points to the viewer.</p> </li> <li> <code>load_main_viewer</code>             \u2013              <p>Add the data to the main viewer.</p> </li> <li> <code>look_at_skeleton</code>             \u2013              <p>Set the camera in the main viewer to look at the skeleton.</p> </li> <li> <code>show</code>             \u2013              <p>Show the app.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>curate</code>               (<code>CurationManager</code>)           \u2013            <p>Get the curation manager.</p> </li> <li> <code>data</code>               (<code>DataManager</code>)           \u2013            <p>Get the data manager.</p> </li> </ul> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def __init__(\n    self, data: DataManager | None = None, selection: SelectionManager | None = None\n) -&gt; None:\n    super().__init__(\"SkelePlex\")\n\n    # make the data model\n    if data is None:\n        data = DataManager(file_paths=SkeletonDataPaths(), selection=selection)\n    self._data = data\n\n    # add the curation manager\n    self._curate = CurationManager(\n        data_manager=self._data,\n    )\n\n    # make the viewer model\n    self._viewer = ViewerController()\n    # self._viewer = ViewerController(parent_widget=self._main_window)\n\n    # ACTIONS is a list of Action objects.\n    for action in ACTIONS:\n        self.register_action(action)\n    self._register_data_actions()\n\n    self._main_window = MainWindow(\n        app=self,\n    )\n    # This will build a menu bar based on these menus\n    self._main_window.setModelMenuBar([MenuId.FILE, MenuId.EDIT, MenuId.DATA])\n\n    # populate the renderer\n    self._viewer._populate_viewer_from_model(\n        canvas_widget_parent=self._main_window._main_viewer_widget.main_viewer_frame\n    )\n\n    for canvas in self._viewer._backend._canvas_widgets.values():\n        # add the canvas widgets\n        self._main_window._set_main_viewer_widget(canvas)\n\n    # connect the data events\n    self._connect_data_events()\n\n    # connect the selection events\n    self._connect_selection_events()\n\n    # update the data view\n    self.data.view.update()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.curate","title":"curate  <code>property</code>","text":"<pre><code>curate: CurationManager\n</code></pre> <p>Get the curation manager.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.data","title":"data  <code>property</code>","text":"<pre><code>data: DataManager\n</code></pre> <p>Get the data manager.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget, name: str) -&gt; None\n</code></pre> <p>Add a widget to the right dock of the main window.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def add_auxiliary_widget(self, widget, name: str) -&gt; None:\n    \"\"\"Add a widget to the right dock of the main window.\"\"\"\n    self._main_window.add_auxiliary_widget(widget, name)\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.add_points","title":"add_points","text":"<pre><code>add_points(point_coordinates: ndarray | None = None) -&gt; tuple[PointsVisual, PointsMemoryStore]\n</code></pre> <p>Add points to the viewer.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PointsVisual, PointsMemoryStore]</code>           \u2013            <p>A tuple containing the PointsVisual and PointsMemoryStore objects.</p> </li> </ul> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def add_points(\n    self, point_coordinates: np.ndarray | None = None\n) -&gt; tuple[PointsVisual, PointsMemoryStore]:\n    \"\"\"Add points to the viewer.\n\n    Parameters\n    ----------\n    point_coordinates : np.ndarray, optional\n        The coordinates of the points to add, by default np.array([0,0,0],\n                                                            dtype=np.float32)\n\n    Returns\n    -------\n    tuple[PointsVisual, PointsMemoryStore]\n        A tuple containing the PointsVisual and PointsMemoryStore objects.\n    \"\"\"\n    # create a list of points to add\n    # note these must be Float32\n    if point_coordinates is None or len(point_coordinates) == 0:\n        point_coordinates = np.array([[0, 0, 0]], dtype=np.float32)\n    else:\n        point_coordinates = np.asarray(point_coordinates, dtype=np.float32)\n\n    # make the data store for the points\n    new_points_store = PointsMemoryStore(\n        coordinates=point_coordinates,\n    )\n\n    # set up the points appearance\n    points_appearance = PointsUniformAppearance(\n        size=50, color=(0, 1, 0, 1), size_coordinate_space=\"data\"\n    )\n\n    # make the highlight points model\n    points_visual = PointsVisual(\n        name=\"node_highlight_points\",\n        data_store_id=new_points_store.id,\n        appearance=points_appearance,\n    )\n\n    # add the data and visual to the viewer backend (cellier)\n    self._viewer._backend.add_data_store(data_store=new_points_store)\n    self._viewer._backend.add_visual(\n        visual_model=points_visual, scene_id=self._viewer._main_canvas.scene_id\n    )\n\n    # reslice the viewer to update the display\n    self._viewer._backend.reslice_all()\n    return points_visual, new_points_store\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.add_points(point_coordinates)","title":"<code>point_coordinates</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The coordinates of the points to add, by default np.array([0,0,0],                                                     dtype=np.float32)</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.load_main_viewer","title":"load_main_viewer","text":"<pre><code>load_main_viewer() -&gt; None\n</code></pre> <p>Add the data to the main viewer.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def load_main_viewer(self) -&gt; None:\n    \"\"\"Add the data to the main viewer.\"\"\"\n    log.debug(\"Loading data into the main viewer...\")\n    if self.data.skeleton_graph is None:\n        log.debug(\"No skeleton graph loaded.\")\n        return\n\n    self._viewer.main_canvas.update_skeleton_geometry(\n        node_coordinates=self.data.view.node_coordinates,\n        edge_coordinates=self.data.view.edge_coordinates,\n        edge_colors=self.data.view.edge_colors,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.look_at_skeleton","title":"look_at_skeleton","text":"<pre><code>look_at_skeleton() -&gt; None\n</code></pre> <p>Set the camera in the main viewer to look at the skeleton.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def look_at_skeleton(self) -&gt; None:\n    \"\"\"Set the camera in the main viewer to look at the skeleton.\"\"\"\n    self._viewer.main_canvas.look_at_skeleton()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkelePlexApp.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the app.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the app.\"\"\"\n    self._main_window.show()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths","title":"SkeletonDataPaths","text":"<p>               Bases: <code>EventedModel</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.SkeletonDataPaths[SkeletonDataPaths]\n\n              \n\n              click skeleplex.app.SkeletonDataPaths href \"\" \"skeleplex.app.SkeletonDataPaths\"\n            </code></pre> <p>A class storing the state of the skeleton dataset.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>has_paths</code>             \u2013              <p>Returns true if any of the paths are set.</p> </li> </ul>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths(image)","title":"<code>image</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the image file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths(segmentation)","title":"<code>segmentation</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the segmentation image file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>FilePath</code>)           \u2013            <p>The path to the skeleton graph file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.SkeletonDataPaths.has_paths","title":"has_paths","text":"<pre><code>has_paths() -&gt; bool\n</code></pre> <p>Returns true if any of the paths are set.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def has_paths(self) -&gt; bool:\n    \"\"\"Returns true if any of the paths are set.\"\"\"\n    return any([self.image, self.segmentation, self.skeleton_graph])\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the Qt application event loop.</p> <p>This is meant to be used in a script. This should be called after the viewer is set up.</p> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def run():\n    \"\"\"Start the Qt application event loop.\n\n    This is meant to be used in a script.\n    This should be called after the viewer is set up.\n    \"\"\"\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # start the Qt application event loop\n    qapp.exec_()\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.view_skeleton","title":"view_skeleton","text":"<pre><code>view_skeleton(graph_path: str, launch_widgets: bool = True)\n</code></pre> <p>Launch the skeleton viewer application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SkelePlexApp</code>           \u2013            <p>The SkelePlex application instance for viewing the skeleton.</p> </li> </ul> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def view_skeleton(\n    graph_path: str,\n    launch_widgets: bool = True,\n):\n    \"\"\"Launch the skeleton viewer application.\n\n    Parameters\n    ----------\n    graph_path : str\n        Path to the skeleton graph JSON file.\n    launch_widgets : bool, optional\n        Whether to launch the auxiliary widgets for curation.\n        Defaults to True.\n\n    Returns\n    -------\n    SkelePlexApp\n        The SkelePlex application instance for viewing the skeleton.\n    \"\"\"\n    global _app_ref\n\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # Store reference to prevent garbage collection\n    _app_ref = qapp\n\n    # load the data\n    data_manager = DataManager(file_paths=SkeletonDataPaths(skeleton_graph=graph_path))\n\n    # make the viewer\n    viewer = SkelePlexApp(data=data_manager)\n    viewer.show()\n\n    # Wait a short time for things to load and then look at the skeleton\n    # this is a hack...do something smarter later\n    timer = QTimer()\n    timer.singleShot(100, viewer.look_at_skeleton)\n\n    # start the Qt event loop if in Jupyter/IPython\n    if should_launch_ipython_event_loop():\n        start_qt_loop_ipython()\n\n    if launch_widgets:\n        undo_widget = magicgui(viewer.curate.undo)\n        delete_edge_widget = magicgui(\n            viewer.curate.delete_edge,\n        )\n        render_around_node_widget = magicgui(\n            viewer.curate.render_around_node,\n            node_id={\n                \"widget_type\": \"LineEdit\",\n            },\n            bounding_box_width={\"min\": 0, \"max\": sys.float_info.max},\n        )\n\n        connect_without_merging_widget = magicgui(\n            viewer.curate.connect_without_merging,\n        )\n        connect_with_merging_widget = magicgui(\n            viewer.curate.connect_with_merging,\n        )\n        split_edge_widget = make_split_edge_widget(viewer)\n\n        ChangeBranchColorWidget(viewer)\n\n        # add to viewer\n        viewer.add_auxiliary_widget(undo_widget.native, name=\"Undo\")\n        viewer.add_auxiliary_widget(delete_edge_widget.native, name=\"Delete edge\")\n        viewer.add_auxiliary_widget(\n            render_around_node_widget.native, name=\"Render around node\"\n        )\n        viewer.add_auxiliary_widget(\n            connect_without_merging_widget.native, name=\"Connect without merging\"\n        )\n        viewer.add_auxiliary_widget(\n            connect_with_merging_widget.native, name=\"Connect with merging\"\n        )\n        viewer.add_auxiliary_widget(split_edge_widget.native, name=\"Split edge\")\n    return viewer\n</code></pre>"},{"location":"reference/skeleplex/app/#skeleplex.app.view_skeleton(graph_path)","title":"<code>graph_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the skeleton graph JSON file.</p>"},{"location":"reference/skeleplex/app/#skeleplex.app.view_skeleton(launch_widgets)","title":"<code>launch_widgets</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to launch the auxiliary widgets for curation. Defaults to True.</p>"},{"location":"reference/skeleplex/app/_app/","title":"_app","text":""},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app","title":"skeleplex.app._app","text":"<p>The main application model.</p> <p>Classes:</p> <ul> <li> <code>SkelePlexApp</code>           \u2013            <p>The main application class.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp","title":"SkelePlexApp","text":"<pre><code>SkelePlexApp(data: DataManager | None = None, selection: SelectionManager | None = None)\n</code></pre> <p>               Bases: <code>Application</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._app.SkelePlexApp[SkelePlexApp]\n\n              \n\n              click skeleplex.app._app.SkelePlexApp href \"\" \"skeleplex.app._app.SkelePlexApp\"\n            </code></pre> <p>The main application class.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the right dock of the main window.</p> </li> <li> <code>add_points</code>             \u2013              <p>Add points to the viewer.</p> </li> <li> <code>load_main_viewer</code>             \u2013              <p>Add the data to the main viewer.</p> </li> <li> <code>look_at_skeleton</code>             \u2013              <p>Set the camera in the main viewer to look at the skeleton.</p> </li> <li> <code>show</code>             \u2013              <p>Show the app.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>curate</code>               (<code>CurationManager</code>)           \u2013            <p>Get the curation manager.</p> </li> <li> <code>data</code>               (<code>DataManager</code>)           \u2013            <p>Get the data manager.</p> </li> </ul> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def __init__(\n    self, data: DataManager | None = None, selection: SelectionManager | None = None\n) -&gt; None:\n    super().__init__(\"SkelePlex\")\n\n    # make the data model\n    if data is None:\n        data = DataManager(file_paths=SkeletonDataPaths(), selection=selection)\n    self._data = data\n\n    # add the curation manager\n    self._curate = CurationManager(\n        data_manager=self._data,\n    )\n\n    # make the viewer model\n    self._viewer = ViewerController()\n    # self._viewer = ViewerController(parent_widget=self._main_window)\n\n    # ACTIONS is a list of Action objects.\n    for action in ACTIONS:\n        self.register_action(action)\n    self._register_data_actions()\n\n    self._main_window = MainWindow(\n        app=self,\n    )\n    # This will build a menu bar based on these menus\n    self._main_window.setModelMenuBar([MenuId.FILE, MenuId.EDIT, MenuId.DATA])\n\n    # populate the renderer\n    self._viewer._populate_viewer_from_model(\n        canvas_widget_parent=self._main_window._main_viewer_widget.main_viewer_frame\n    )\n\n    for canvas in self._viewer._backend._canvas_widgets.values():\n        # add the canvas widgets\n        self._main_window._set_main_viewer_widget(canvas)\n\n    # connect the data events\n    self._connect_data_events()\n\n    # connect the selection events\n    self._connect_selection_events()\n\n    # update the data view\n    self.data.view.update()\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.curate","title":"curate  <code>property</code>","text":"<pre><code>curate: CurationManager\n</code></pre> <p>Get the curation manager.</p>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.data","title":"data  <code>property</code>","text":"<pre><code>data: DataManager\n</code></pre> <p>Get the data manager.</p>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget, name: str) -&gt; None\n</code></pre> <p>Add a widget to the right dock of the main window.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def add_auxiliary_widget(self, widget, name: str) -&gt; None:\n    \"\"\"Add a widget to the right dock of the main window.\"\"\"\n    self._main_window.add_auxiliary_widget(widget, name)\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.add_points","title":"add_points","text":"<pre><code>add_points(point_coordinates: ndarray | None = None) -&gt; tuple[PointsVisual, PointsMemoryStore]\n</code></pre> <p>Add points to the viewer.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[PointsVisual, PointsMemoryStore]</code>           \u2013            <p>A tuple containing the PointsVisual and PointsMemoryStore objects.</p> </li> </ul> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def add_points(\n    self, point_coordinates: np.ndarray | None = None\n) -&gt; tuple[PointsVisual, PointsMemoryStore]:\n    \"\"\"Add points to the viewer.\n\n    Parameters\n    ----------\n    point_coordinates : np.ndarray, optional\n        The coordinates of the points to add, by default np.array([0,0,0],\n                                                            dtype=np.float32)\n\n    Returns\n    -------\n    tuple[PointsVisual, PointsMemoryStore]\n        A tuple containing the PointsVisual and PointsMemoryStore objects.\n    \"\"\"\n    # create a list of points to add\n    # note these must be Float32\n    if point_coordinates is None or len(point_coordinates) == 0:\n        point_coordinates = np.array([[0, 0, 0]], dtype=np.float32)\n    else:\n        point_coordinates = np.asarray(point_coordinates, dtype=np.float32)\n\n    # make the data store for the points\n    new_points_store = PointsMemoryStore(\n        coordinates=point_coordinates,\n    )\n\n    # set up the points appearance\n    points_appearance = PointsUniformAppearance(\n        size=50, color=(0, 1, 0, 1), size_coordinate_space=\"data\"\n    )\n\n    # make the highlight points model\n    points_visual = PointsVisual(\n        name=\"node_highlight_points\",\n        data_store_id=new_points_store.id,\n        appearance=points_appearance,\n    )\n\n    # add the data and visual to the viewer backend (cellier)\n    self._viewer._backend.add_data_store(data_store=new_points_store)\n    self._viewer._backend.add_visual(\n        visual_model=points_visual, scene_id=self._viewer._main_canvas.scene_id\n    )\n\n    # reslice the viewer to update the display\n    self._viewer._backend.reslice_all()\n    return points_visual, new_points_store\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.add_points(point_coordinates)","title":"<code>point_coordinates</code>","text":"(<code>ndarray</code>, default:                   <code>None</code> )           \u2013            <p>The coordinates of the points to add, by default np.array([0,0,0],                                                     dtype=np.float32)</p>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.load_main_viewer","title":"load_main_viewer","text":"<pre><code>load_main_viewer() -&gt; None\n</code></pre> <p>Add the data to the main viewer.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def load_main_viewer(self) -&gt; None:\n    \"\"\"Add the data to the main viewer.\"\"\"\n    log.debug(\"Loading data into the main viewer...\")\n    if self.data.skeleton_graph is None:\n        log.debug(\"No skeleton graph loaded.\")\n        return\n\n    self._viewer.main_canvas.update_skeleton_geometry(\n        node_coordinates=self.data.view.node_coordinates,\n        edge_coordinates=self.data.view.edge_coordinates,\n        edge_colors=self.data.view.edge_colors,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.look_at_skeleton","title":"look_at_skeleton","text":"<pre><code>look_at_skeleton() -&gt; None\n</code></pre> <p>Set the camera in the main viewer to look at the skeleton.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def look_at_skeleton(self) -&gt; None:\n    \"\"\"Set the camera in the main viewer to look at the skeleton.\"\"\"\n    self._viewer.main_canvas.look_at_skeleton()\n</code></pre>"},{"location":"reference/skeleplex/app/_app/#skeleplex.app._app.SkelePlexApp.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Show the app.</p> Source code in <code>skeleplex/app/_app.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Show the app.\"\"\"\n    self._main_window.show()\n</code></pre>"},{"location":"reference/skeleplex/app/_constants/","title":"_constants","text":""},{"location":"reference/skeleplex/app/_constants/#skeleplex.app._constants","title":"skeleplex.app._constants","text":"<p>Constants for the application.</p> <p>Classes:</p> <ul> <li> <code>CommandId</code>           \u2013            <p>Command identifiers for the application.</p> </li> <li> <code>MenuId</code>           \u2013            <p>Menu identifiers for the application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_constants/#skeleplex.app._constants.CommandId","title":"CommandId","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._constants.CommandId[CommandId]\n\n              \n\n              click skeleplex.app._constants.CommandId href \"\" \"skeleplex.app._constants.CommandId\"\n            </code></pre> <p>Command identifiers for the application.</p>"},{"location":"reference/skeleplex/app/_constants/#skeleplex.app._constants.MenuId","title":"MenuId","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._constants.MenuId[MenuId]\n\n              \n\n              click skeleplex.app._constants.MenuId href \"\" \"skeleplex.app._constants.MenuId\"\n            </code></pre> <p>Menu identifiers for the application.</p>"},{"location":"reference/skeleplex/app/_curate/","title":"_curate","text":""},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate","title":"skeleplex.app._curate","text":"<p>Classes:</p> <ul> <li> <code>ChangeBranchColorWidget</code>           \u2013            </li> <li> <code>CurationManager</code>           \u2013            </li> <li> <code>LIFOBuffer</code>           \u2013            <p>A last-in-first-out buffer with a maximum size.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>change_color_attr</code>             \u2013              <p>Change the color of edges based on a specific attribute.</p> </li> <li> <code>edge_string_to_key</code>             \u2013              <p>Parse a string representation of a set of tuples back into a Python set.</p> </li> <li> <code>filter_edges_by_attribute</code>             \u2013              <p>Filter edges based on a specific attribute and its value range.</p> </li> <li> <code>make_split_edge_widget</code>             \u2013              <p>Create a widget for splitting edges in the skeleton graph.</p> </li> <li> <code>node_string_to_node_keys</code>             \u2013              <p>Parse a string representation of a set of integers back into a Python set.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.ChangeBranchColorWidget","title":"ChangeBranchColorWidget","text":"<pre><code>ChangeBranchColorWidget(viewer)\n</code></pre> <p>Methods:</p> <ul> <li> <code>change_branch_color</code>             \u2013              <p>Change the color of edges based on a specific edge attribute.</p> </li> <li> <code>filter_edges</code>             \u2013              <p>Filter edges based on the selected edge attribute and its value range.</p> </li> <li> <code>get_edge_attributes</code>             \u2013              <p>Get the edge attributes from the skeleton graph.</p> </li> <li> <code>get_min_max_values</code>             \u2013              <p>Get the min and max values of the specified edge attribute.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def __init__(self, viewer):\n    self.viewer = viewer\n\n    # Create magicgui widget\n    self.widget = magicgui(\n        self.change_branch_color,\n        edge_attribute={\n            \"choices\": self.get_edge_attributes(),\n            \"widget_type\": \"ComboBox\",\n        },\n        cmap={\"widget_type\": \"ComboBox\", \"choices\": plt.colormaps()},\n        vmin={\n            \"widget_type\": \"FloatSlider\",\n            \"min\": 0,\n            \"max\": 1,\n            \"step\": 1,\n            \"value\": 0,\n        },\n        vmax={\n            \"widget_type\": \"FloatSlider\",\n            \"min\": 0,\n            \"max\": 1,\n            \"step\": 1,\n            \"value\": 1,\n        },\n    )\n\n    self.widget.call_button.visible = False\n\n    self.run_button = QPushButton(\"Run\")\n    self.run_button.clicked.connect(self._on_run_clicked)\n\n    self.filter_button = QPushButton(\"Filter Edges\")\n    self.filter_button.clicked.connect(self._on_filter_clicked)\n\n    # QLabel for colorbar\n    self.colorbar_label = QLabel()\n\n    # Layout to contain both magicgui and colorbar\n    self.container = QWidget()\n    layout = QVBoxLayout()\n    layout.addWidget(self.widget.native)\n    layout.addWidget(self.run_button)\n    layout.addWidget(self.filter_button)\n    layout.addWidget(self.colorbar_label)\n    self.container.setLayout(layout)\n\n    self.widget.edge_attribute.changed.connect(self._on_attribute_change)\n    self._on_attribute_change(self.widget.edge_attribute.value)\n\n    self.widget.vmin.changed.connect(self._on_slider_value_change)\n    self.widget.vmax.changed.connect(self._on_slider_value_change)\n\n    # Add the full container widget to the viewer\n    self.viewer.add_auxiliary_widget(self.container, name=\"Change Branch Color\")\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.ChangeBranchColorWidget.change_branch_color","title":"change_branch_color","text":"<pre><code>change_branch_color(edge_attribute: str, cmap: str, vmin: float, vmax: float)\n</code></pre> <p>Change the color of edges based on a specific edge attribute.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def change_branch_color(\n    self, edge_attribute: str, cmap: str, vmin: float, vmax: float\n):\n    \"\"\"Change the color of edges based on a specific edge attribute.\"\"\"\n    change_color_attr(\n        self.viewer,\n        edge_attribute=edge_attribute,\n        cmap=plt.get_cmap(cmap),\n        vmin=vmin,\n        vmax=vmax,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.ChangeBranchColorWidget.filter_edges","title":"filter_edges","text":"<pre><code>filter_edges()\n</code></pre> <p>Filter edges based on the selected edge attribute and its value range.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def filter_edges(self):\n    \"\"\"Filter edges based on the selected edge attribute and its value range.\"\"\"\n    edge_attribute = self.widget.edge_attribute.value\n    cmap = plt.get_cmap(self.widget.cmap.value)\n    vmin = self.widget.vmin.value\n    vmax = self.widget.vmax.value\n\n    filter_edges_by_attribute(\n        self.viewer,\n        edge_attribute=edge_attribute,\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.ChangeBranchColorWidget.get_edge_attributes","title":"get_edge_attributes","text":"<pre><code>get_edge_attributes()\n</code></pre> <p>Get the edge attributes from the skeleton graph.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def get_edge_attributes(self):\n    \"\"\"Get the edge attributes from the skeleton graph.\"\"\"\n    if not self.viewer.data.skeleton_graph.graph.edges:\n        return []\n    attribute_set = set()\n    for _, _, edge_data in self.viewer.data.skeleton_graph.graph.edges(data=True):\n        attribute_set.update(edge_data.keys())\n    return list(attribute_set)\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.ChangeBranchColorWidget.get_min_max_values","title":"get_min_max_values","text":"<pre><code>get_min_max_values(edge_attribute: str)\n</code></pre> <p>Get the min and max values of the specified edge attribute.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def get_min_max_values(self, edge_attribute: str):\n    \"\"\"Get the min and max values of the specified edge attribute.\"\"\"\n    values = [\n        value\n        for _, value in nx.get_edge_attributes(\n            self.viewer.data.skeleton_graph.graph, edge_attribute\n        ).items()\n        if isinstance(value, numbers.Number)\n    ]\n    return np.nanmin(values), np.nanmax(values)\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager","title":"CurationManager","text":"<pre><code>CurationManager(data_manager: DataManager)\n</code></pre> <p>Methods:</p> <ul> <li> <code>connect_with_merging</code>             \u2013              <p>Connect two nodes in the skeleton graph by merging them.</p> </li> <li> <code>connect_without_merging</code>             \u2013              <p>Connect two nodes in the skeleton graph without merging them.</p> </li> <li> <code>delete_edge</code>             \u2013              <p>Delete an edge from the skeleton graph.</p> </li> <li> <code>redo</code>             \u2013              <p>Redo the last undone action on the skeleton graph.</p> </li> <li> <code>render_around_node</code>             \u2013              <p>Render a bounding box around the specified node.</p> </li> <li> <code>undo</code>             \u2013              <p>Undo the last action performed on the skeleton graph.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def __init__(\n    self,\n    data_manager: \"DataManager\",\n):\n    self._data = data_manager\n\n    # buffers for undo and redo operations\n    self._undo_buffer = LIFOBuffer(max_size=10)\n    self._redo_buffer = LIFOBuffer(max_size=10)\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_with_merging","title":"connect_with_merging","text":"<pre><code>connect_with_merging(node_to_keep: int, node_to_merge: int, redraw: bool = True) -&gt; None\n</code></pre> <p>Connect two nodes in the skeleton graph by merging them.</p> <p>This method connects two nodes in the skeleton graph by merging one node into another. The node to keep will retain its identity, while the other node will be merged into it, effectively removing it from the graph.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def connect_with_merging(\n    self,\n    node_to_keep: Annotated[int, {\"widget_type\": \"LineEdit\"}],\n    node_to_merge: Annotated[int, {\"widget_type\": \"LineEdit\"}],\n    redraw: bool = True,\n) -&gt; None:\n    \"\"\"Connect two nodes in the skeleton graph by merging them.\n\n    This method connects two nodes in the skeleton graph by merging one node\n    into another. The node to keep will retain its identity, while the other\n    node will be merged into it, effectively removing it from the graph.\n\n    Parameters\n    ----------\n    node_to_keep : int\n        The ID of the nod e to keep after merging.\n    node_to_merge : int\n        The ID of the node to merge into the first node.\n    redraw : bool\n        Flag set to True to redraw the graph after connecting.\n        Defaults value is True.\n    \"\"\"\n    node_to_keep = node_string_to_node_keys(node_to_keep)\n    node_to_merge = node_string_to_node_keys(node_to_merge)\n    node_to_keep = next(iter(node_to_keep), None)\n    node_to_merge = next(iter(node_to_merge), None)\n\n    if node_to_keep == node_to_merge:\n        # if both nodes are the same, do nothing\n        return\n\n    # store the previous state in the undo buffer\n    self._undo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # merge the nodes in the skeleton graph\n    merge_nodes(\n        skeleton_graph=self._data.skeleton_graph,\n        node_to_keep=node_to_keep,\n        node_to_merge=node_to_merge,\n    )\n\n    # connect the nodes with merging\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_with_merging(node_to_keep)","title":"<code>node_to_keep</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the nod e to keep after merging.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_with_merging(node_to_merge)","title":"<code>node_to_merge</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the node to merge into the first node.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_with_merging(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after connecting. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_without_merging","title":"connect_without_merging","text":"<pre><code>connect_without_merging(start_node: int, end_node: int, redraw: bool = True) -&gt; None\n</code></pre> <p>Connect two nodes in the skeleton graph without merging them.</p> <p>This method connects two nodes in the skeleton graph by creating an edge between them. If the nodes are already connected, no action is taken. The connection does not merge the nodes, preserving their individual identities.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def connect_without_merging(\n    self,\n    start_node: Annotated[int, {\"widget_type\": \"LineEdit\"}],\n    end_node: Annotated[int, {\"widget_type\": \"LineEdit\"}],\n    redraw: bool = True,\n) -&gt; None:\n    \"\"\"Connect two nodes in the skeleton graph without merging them.\n\n    This method connects two nodes in the skeleton graph by creating an edge\n    between them. If the nodes are already connected, no action is taken.\n    The connection does not merge the nodes, preserving their individual identities.\n\n    Parameters\n    ----------\n    start_node : int\n        The ID of the first node to connect.\n    end_node : int\n        The ID of the second node to connect.\n    redraw : bool\n        Flag set to True to redraw the graph after connecting.\n        Defaults value is True.\n    \"\"\"\n    start_node = node_string_to_node_keys(start_node)\n    end_node = node_string_to_node_keys(end_node)\n    start_node = next(iter(start_node), None)\n    end_node = next(iter(end_node), None)\n    if start_node is None or end_node is None:\n        # if either node is None, do nothing\n        return\n    if start_node == end_node:\n        # if both nodes are the same, do nothing\n        return\n\n    # store the previous state in the undo buffer\n    self._undo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # connect the nodes without merging\n    connect_without_merging(\n        skeleton_graph=self._data.skeleton_graph, node1=start_node, node2=end_node\n    )\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_without_merging(start_node)","title":"<code>start_node</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the first node to connect.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_without_merging(end_node)","title":"<code>end_node</code>","text":"(<code>int</code>)           \u2013            <p>The ID of the second node to connect.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.connect_without_merging(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after connecting. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.delete_edge","title":"delete_edge","text":"<pre><code>delete_edge(edge: set[tuple[int, int]] | str, redraw: bool = True) -&gt; None\n</code></pre> <p>Delete an edge from the skeleton graph.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def delete_edge(\n    self,\n    edge: Annotated[set[tuple[int, int]] | str, {\"widget_type\": \"LineEdit\"}],\n    redraw: bool = True,\n) -&gt; None:\n    \"\"\"Delete an edge from the skeleton graph.\n\n    Parameters\n    ----------\n    edge : tuple[int, int] | None\n        The edge to delete, represented as a tuple of node IDs.\n        If None, no action is taken.\n    redraw : bool\n        Flag set to True to redraw the graph after deletion.\n        Defaults value is True.\n    \"\"\"\n    if len(edge) == 0:\n        # if no edge is selected, do nothing\n        return\n\n    # parse the edge if it is a string\n    edges = edge_string_to_key(edge) if isinstance(edge, str) else edge\n\n    # store the previous state in the undo buffer\n    self._undo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # delete the edge from the skeleton graph\n    for edge in edges:\n        delete_edge(skeleton_graph=self._data.skeleton_graph, edge=edge)\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.delete_edge(edge)","title":"<code>edge</code>","text":"(<code>tuple[int, int] | None</code>)           \u2013            <p>The edge to delete, represented as a tuple of node IDs. If None, no action is taken.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.delete_edge(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after deletion. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.redo","title":"redo","text":"<pre><code>redo(redraw: bool = True) -&gt; None\n</code></pre> <p>Redo the last undone action on the skeleton graph.</p> <p>This method restores the skeleton graph to the next state in the undo buffer. If there are no actions to redo, it does nothing.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def redo(self, redraw: bool = True) -&gt; None:\n    \"\"\"Redo the last undone action on the skeleton graph.\n\n    This method restores the skeleton graph to the next state in the undo buffer.\n    If there are no actions to redo, it does nothing.\n\n    Parameters\n    ----------\n    redraw : bool\n        Flag set to True to redraw the graph after redoing.\n        Defaults value is True.\n    \"\"\"\n    if len(self._redo_buffer) == 0:\n        # if there are no actions to redo, do nothing\n        return\n\n    # store the current state in the undo buffer\n    self._undo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # restore the next state from the redo buffer\n    next_state = self._redo_buffer.pop()\n    self._data._skeleton_graph = next_state\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.redo(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after redoing. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.render_around_node","title":"render_around_node","text":"<pre><code>render_around_node(node_id=int, bounding_box_width: int = 100)\n</code></pre> <p>Render a bounding box around the specified node.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def render_around_node(\n    self,\n    node_id=int,\n    bounding_box_width: int = 100,\n):\n    \"\"\"Render a bounding box around the specified node.\n\n    Parameters\n    ----------\n    node_id : int\n        The ID of the node to render around.\n    bounding_box_width : int\n        The width of the bounding box to render around the node.\n        Default is 100.\n    \"\"\"\n    # get the coordinate of the node\n    node_id = node_string_to_node_keys(node_id)\n    node_id = next(iter(node_id), None)\n    graph_object = self._data.skeleton_graph.graph\n    node_coordinate = graph_object.nodes[node_id][NODE_COORDINATE_KEY]\n\n    # get the minimum and maximum coordinates for the bounding box\n    half_width = bounding_box_width / 2\n    min_coordinate = node_coordinate - half_width\n    max_coordinate = node_coordinate + half_width\n\n    # set the bounding box in the viewer\n    self._data.view.bounding_box._min_coordinate = min_coordinate\n    self._data.view.bounding_box._max_coordinate = max_coordinate\n\n    # set the render mode to bounding box\n    self._data.view.mode = \"bounding_box\"\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.render_around_node(node_id)","title":"<code>node_id</code>","text":"(<code>int</code>, default:                   <code>int</code> )           \u2013            <p>The ID of the node to render around.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.render_around_node(bounding_box_width)","title":"<code>bounding_box_width</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The width of the bounding box to render around the node. Default is 100.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.undo","title":"undo","text":"<pre><code>undo(redraw: bool = True) -&gt; None\n</code></pre> <p>Undo the last action performed on the skeleton graph.</p> <p>This method restores the skeleton graph to its previous state using the undo buffer. If there are no actions to undo, it does nothing.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def undo(self, redraw: bool = True) -&gt; None:\n    \"\"\"Undo the last action performed on the skeleton graph.\n\n    This method restores the skeleton graph to its previous state\n    using the undo buffer. If there are no actions to undo, it does nothing.\n\n    Parameters\n    ----------\n    redraw : bool\n        Flag set to True to redraw the graph after undoing.\n        Defaults value is True.\n    \"\"\"\n    if len(self._undo_buffer) == 0:\n        # if there are no actions to undo, do nothing\n        return\n\n    # store the current state in the redo buffer\n    self._redo_buffer.push(deepcopy(self._data.skeleton_graph))\n\n    # restore the previous state from the undo buffer\n    previous_state = self._undo_buffer.pop()\n    self._data._skeleton_graph = previous_state\n\n    if redraw:\n        # redraw the graph\n        self._update_and_request_redraw()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.CurationManager.undo(redraw)","title":"<code>redraw</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag set to True to redraw the graph after undoing. Defaults value is True.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer","title":"LIFOBuffer","text":"<pre><code>LIFOBuffer(max_size: int)\n</code></pre> <p>A last-in-first-out buffer with a maximum size.</p> <p>This buffer automatically removes the oldest items when the maximum size is exceeded, maintaining LIFO ordering for retrieval.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If max_size is not a positive integer.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>clear</code>             \u2013              <p>Remove all items from the buffer.</p> </li> <li> <code>pop</code>             \u2013              <p>Remove and return the most recently added item.</p> </li> <li> <code>push</code>             \u2013              <p>Add an item to the buffer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>max_size</code>               (<code>int</code>)           \u2013            <p>Get the maximum capacity of the buffer.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def __init__(self, max_size: int) -&gt; None:\n    if max_size &lt;= 0:\n        raise ValueError(\"max_size must be greater than 0\")\n\n    self._buffer = deque(maxlen=max_size)\n    self._max_size = max_size\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer(max_size)","title":"<code>max_size</code>","text":"(<code>int</code>)           \u2013            <p>The maximum number of items the buffer can hold. Must be greater than 0.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.max_size","title":"max_size  <code>property</code>","text":"<pre><code>max_size: int\n</code></pre> <p>Get the maximum capacity of the buffer.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The maximum number of items the buffer can hold.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Remove all items from the buffer.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Remove all items from the buffer.\"\"\"\n    self._buffer.clear()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.pop","title":"pop","text":"<pre><code>pop() -&gt; Any\n</code></pre> <p>Remove and return the most recently added item.</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The most recently added item.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>IndexError</code>             \u2013            <p>If the buffer is empty.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def pop(self) -&gt; Any:\n    \"\"\"Remove and return the most recently added item.\n\n    Returns\n    -------\n    Any\n        The most recently added item.\n\n    Raises\n    ------\n    IndexError\n        If the buffer is empty.\n    \"\"\"\n    if not self._buffer:\n        raise IndexError(\"pop from empty buffer\")\n    return self._buffer.pop()\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.push","title":"push","text":"<pre><code>push(item: Any) -&gt; None\n</code></pre> <p>Add an item to the buffer.</p> <p>If the buffer is at maximum capacity, the oldest item will be automatically removed.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def push(self, item: Any) -&gt; None:\n    \"\"\"Add an item to the buffer.\n\n    If the buffer is at maximum capacity, the oldest item\n    will be automatically removed.\n\n    Parameters\n    ----------\n    item : Any\n        The item to add to the buffer.\n    \"\"\"\n    self._buffer.append(item)\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.LIFOBuffer.push(item)","title":"<code>item</code>","text":"(<code>Any</code>)           \u2013            <p>The item to add to the buffer.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.change_color_attr","title":"change_color_attr","text":"<pre><code>change_color_attr(viewer, edge_attribute: str = GENERATION_KEY, cmap=viridis, vmin: float | None = None, vmax: float | None = None)\n</code></pre> <p>Change the color of edges based on a specific attribute.</p> <p>This function retrieves the specified edge attribute from the skeleton graph, normalizes the values using the provided colormap, and updates the edge colors in the viewer's data.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def change_color_attr(\n    viewer,\n    edge_attribute: str = GENERATION_KEY,\n    cmap=plt.cm.viridis,\n    vmin: float | None = None,\n    vmax: float | None = None,\n):\n    \"\"\"Change the color of edges based on a specific attribute.\n\n    This function retrieves the specified edge attribute from the skeleton graph,\n    normalizes the values using the provided colormap, and updates the edge colors\n    in the viewer's data.\n\n    Parameters\n    ----------\n    viewer : SkelePlexApp\n        The SkelePlex application instance containing the skeleton graph data.\n    edge_attribute : str\n        The name of the edge attribute to use for coloring.\n        Defaults to GENERATION_KEY.\n    cmap : Colormap\n        The colormap to use for normalizing the edge attribute values.\n        Defaults to plt.cm.viridis.\n    vmin : float | None\n        The minimum value for normalization. If None, it will be set to the minimum\n        value of the edge attribute.\n    vmax : float | None\n        The maximum value for normalization. If None, it will be set to the maximum\n        value of the edge attribute.\n    \"\"\"\n    color_dict = nx.get_edge_attributes(\n        viewer.data.skeleton_graph.graph, edge_attribute\n    )\n\n    for key, value in color_dict.items():\n        if not value:\n            color_dict[key] = np.nan\n\n    if vmin is None:\n        vmin = np.nanmin(list(color_dict.values()))\n    if vmax is None:\n        vmax = np.nanmax(list(color_dict.values()))\n\n    norm = plt.Normalize(vmin=vmin, vmax=vmax)\n    color_dict = {k: np.array(cmap(norm(v))) for k, v in color_dict.items()}\n\n    # update\n    edge_colormap = EdgeColormap.from_arrays(\n        colormap=color_dict,\n        default_color=np.array([0, 0, 0, 1], dtype=np.float32),\n    )\n    viewer.data.edge_colormap = edge_colormap\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.change_color_attr(viewer)","title":"<code>viewer</code>","text":"(<code>SkelePlexApp</code>)           \u2013            <p>The SkelePlex application instance containing the skeleton graph data.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.change_color_attr(edge_attribute)","title":"<code>edge_attribute</code>","text":"(<code>str</code>, default:                   <code>GENERATION_KEY</code> )           \u2013            <p>The name of the edge attribute to use for coloring. Defaults to GENERATION_KEY.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.change_color_attr(cmap)","title":"<code>cmap</code>","text":"(<code>Colormap</code>, default:                   <code>viridis</code> )           \u2013            <p>The colormap to use for normalizing the edge attribute values. Defaults to plt.cm.viridis.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.change_color_attr(vmin)","title":"<code>vmin</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The minimum value for normalization. If None, it will be set to the minimum value of the edge attribute.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.change_color_attr(vmax)","title":"<code>vmax</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum value for normalization. If None, it will be set to the maximum value of the edge attribute.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.edge_string_to_key","title":"edge_string_to_key","text":"<pre><code>edge_string_to_key(edge_string: str) -&gt; set[tuple[int, ...]]\n</code></pre> <p>Parse a string representation of a set of tuples back into a Python set.</p> <p>This function safely converts string representations of sets containing tuples back into their original Python data structure. It handles the case where the string was created using str() on a set of tuples.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>set[tuple[int, ...]]</code>           \u2013            <p>A set containing tuples parsed from the input string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string cannot be safely parsed as a set of tuples.</p> </li> <li> <code>SyntaxError</code>             \u2013            <p>If the string contains invalid Python syntax.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def edge_string_to_key(edge_string: str) -&gt; set[tuple[int, ...]]:\n    \"\"\"Parse a string representation of a set of tuples back into a Python set.\n\n    This function safely converts string representations of sets containing tuples\n    back into their original Python data structure. It handles the case where\n    the string was created using str() on a set of tuples.\n\n    Parameters\n    ----------\n    edge_string : str\n        String representation of a set of tuples, typically created by\n        calling str() on a set object containing tuples.\n\n    Returns\n    -------\n    set[tuple[int, ...]]\n        A set containing tuples parsed from the input string.\n\n    Raises\n    ------\n    ValueError\n        If the string cannot be safely parsed as a set of tuples.\n    SyntaxError\n        If the string contains invalid Python syntax.\n    \"\"\"\n    try:\n        # parse the string to convert it back to a set of tuples\n        parsed_result = ast.literal_eval(edge_string)\n\n        # Verify that the result is a set\n        if not isinstance(parsed_result, set):\n            raise ValueError(f\"Expected a set, but got {type(parsed_result).__name__}\")\n\n        # Verify that all elements are tuples\n        for element in parsed_result:\n            if not isinstance(element, tuple):\n                raise ValueError(\"Expected all elements must be tuples\")\n\n        return parsed_result\n\n    except (ValueError, SyntaxError) as e:\n        raise ValueError(f\"Could not parse edge string '{edge_string}': {e}\") from e\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.edge_string_to_key(edge_string)","title":"<code>edge_string</code>","text":"(<code>str</code>)           \u2013            <p>String representation of a set of tuples, typically created by calling str() on a set object containing tuples.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.filter_edges_by_attribute","title":"filter_edges_by_attribute","text":"<pre><code>filter_edges_by_attribute(viewer, edge_attribute: str = GENERATION_KEY, cmap=viridis, vmin: float | None = None, vmax: float | None = None)\n</code></pre> <p>Filter edges based on a specific attribute and its value range.</p> <p>Edges that do not have the specified attribute or whose values are outside the specified range will be rendered as transparent.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def filter_edges_by_attribute(\n    viewer,\n    edge_attribute: str = GENERATION_KEY,\n    cmap=plt.cm.viridis,\n    vmin: float | None = None,\n    vmax: float | None = None,\n):\n    \"\"\"Filter edges based on a specific attribute and its value range.\n\n    Edges that do not have the specified attribute or whose values\n    are outside the specified range will be rendered as transparent.\n\n    Parameters\n    ----------\n    viewer : SkelePlexApp\n        The SkelePlex application instance containing the skeleton graph data.\n    edge_attribute : str\n        The name of the edge attribute to use for filtering.\n        Defaults to GENERATION_KEY.\n    cmap : Colormap\n        The colormap to use for normalizing the edge attribute values.\n        Defaults to plt.cm.viridis.\n    vmin : float | None\n        The minimum value for normalization. If None, it will be set to the minimum\n        value of the edge attribute.\n    vmax : float | None\n        The maximum value for normalization. If None, it will be set to the maximum\n        value of the edge attribute.\n\n    \"\"\"\n    color_dict = nx.get_edge_attributes(\n        viewer.data.skeleton_graph.graph, edge_attribute\n    )\n    for key, value in color_dict.items():\n        if not value:\n            color_dict[key] = np.nan\n\n    if vmin is None:\n        vmin = np.nanmin(list(color_dict.values()))\n    if vmax is None:\n        vmax = np.nanmax(list(color_dict.values()))\n\n    norm = plt.Normalize(vmin=vmin, vmax=vmax)\n    color_dict = {k: np.array(cmap(norm(v))) for k, v in color_dict.items()}\n\n    edges_to_remove = [\n        edge\n        for edge, value in nx.get_edge_attributes(\n            viewer.data.skeleton_graph.graph, edge_attribute\n        ).items()\n        if not isinstance(value, numbers.Number) or not (vmin &lt;= value &lt;= vmax)\n    ]\n\n    for edge in viewer.data.skeleton_graph.graph.edges:\n        # if generation_dict[edge] &gt; levels:\n        #     continue\n        if edge in edges_to_remove:\n            # Render edges that are filtered out as transparent\n            color_dict[edge] = np.array([0, 0, 0, 0], dtype=np.float32)  # Transparent\n        else:\n            color_dict[edge] = color_dict.get(\n                edge, np.array([0, 0, 0, 1], dtype=np.float32)\n            )\n\n    edge_colormap = EdgeColormap.from_arrays(\n        colormap=color_dict,\n        default_color=np.array([0, 0, 0, 1], dtype=np.float32),\n    )\n    viewer.data.edge_colormap = edge_colormap\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.filter_edges_by_attribute(viewer)","title":"<code>viewer</code>","text":"(<code>SkelePlexApp</code>)           \u2013            <p>The SkelePlex application instance containing the skeleton graph data.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.filter_edges_by_attribute(edge_attribute)","title":"<code>edge_attribute</code>","text":"(<code>str</code>, default:                   <code>GENERATION_KEY</code> )           \u2013            <p>The name of the edge attribute to use for filtering. Defaults to GENERATION_KEY.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.filter_edges_by_attribute(cmap)","title":"<code>cmap</code>","text":"(<code>Colormap</code>, default:                   <code>viridis</code> )           \u2013            <p>The colormap to use for normalizing the edge attribute values. Defaults to plt.cm.viridis.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.filter_edges_by_attribute(vmin)","title":"<code>vmin</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The minimum value for normalization. If None, it will be set to the minimum value of the edge attribute.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.filter_edges_by_attribute(vmax)","title":"<code>vmax</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum value for normalization. If None, it will be set to the maximum value of the edge attribute.</p>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.make_split_edge_widget","title":"make_split_edge_widget","text":"<pre><code>make_split_edge_widget(viewer)\n</code></pre> <p>Create a widget for splitting edges in the skeleton graph.</p> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def make_split_edge_widget(viewer):\n    \"\"\"Create a widget for splitting edges in the skeleton graph.\"\"\"\n\n    @magicgui(\n        edge_to_split_ID={\"widget_type\": \"LineEdit\"},\n        split_pos={\n            \"widget_type\": \"FloatSlider\",\n            \"min\": 0.0,\n            \"max\": 1.0,\n            \"step\": 0.01,\n            \"value\": 0.5,\n        },\n    )\n    def split_edge_widget(edge_to_split_ID: int, split_pos: float = 0.5):\n        \"\"\"Widget to split an edge in the skeleton graph.\n\n        Parameters\n        ----------\n        edge_to_split_ID : str\n            The ID of the edge to split, represented as a string.\n            This should be a string representation of a set of tuples,\n            e.g. \"{(1, 2), (2, 3)}\".\n        split_pos : float\n            The position to split the edge at, between 0 and 1.\n            Default value is 0.5, which means the edge will be split in the middle\n            of its length.\n        \"\"\"\n        edge_key = next(iter(edge_string_to_key(edge_to_split_ID)))\n        viewer.curate._undo_buffer.push(deepcopy(viewer.curate._data.skeleton_graph))\n        split_edge(viewer.curate._data.skeleton_graph, edge_key, split_pos)\n        viewer.curate._update_and_request_redraw()\n\n    def preview_split():\n        \"\"\"Preview the split edge operation.\n\n        This function is connected to the split_pos widget to update the preview\n        of the split edge in the viewer.\n        It calculates the position of the split point based on the current\n        split_pos value and the spline of the edge to be split.\n        The calculated point position is then set in the point_store and made visible.\n        \"\"\"\n        edge_key = next(\n            iter(edge_string_to_key(split_edge_widget.edge_to_split_ID.value))\n        )\n        spline = viewer.data.skeleton_graph.graph.edges[edge_key][EDGE_SPLINE_KEY]\n        point_pos = spline.eval(split_edge_widget.split_pos.value)\n\n        split_edge_widget.point_store.coordinates = np.array(\n            [point_pos], dtype=np.float32\n        )\n        split_edge_widget.point_visual.appearance.visible = True\n        viewer._viewer._backend.reslice_all()\n\n    split_edge_widget.split_pos.changed.connect(preview_split)\n    split_edge_widget.point_visual, split_edge_widget.point_store = viewer.add_points()\n    split_edge_widget.point_visual.appearance.visible = False\n\n    return split_edge_widget\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.node_string_to_node_keys","title":"node_string_to_node_keys","text":"<pre><code>node_string_to_node_keys(node_string: str) -&gt; set[int]\n</code></pre> <p>Parse a string representation of a set of integers back into a Python set.</p> <p>This function safely converts string representations of sets containing integers back into their original Python data structure. It handles the case where the string was created using str() on a set of integers.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>set[int]</code>           \u2013            <p>A set containing integers parsed from the input string.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the string cannot be safely parsed as a set of integers, or if the string exceeds the maximum allowed length.</p> </li> <li> <code>SyntaxError</code>             \u2013            <p>If the string contains invalid Python syntax.</p> </li> </ul> Source code in <code>skeleplex/app/_curate.py</code> <pre><code>def node_string_to_node_keys(node_string: str) -&gt; set[int]:\n    \"\"\"Parse a string representation of a set of integers back into a Python set.\n\n    This function safely converts string representations of sets containing integers\n    back into their original Python data structure. It handles the case where\n    the string was created using str() on a set of integers.\n\n    Parameters\n    ----------\n    node_string : str\n        String representation of a set of integers, typically created by\n        calling str() on a set object containing integers.\n\n    Returns\n    -------\n    set[int]\n        A set containing integers parsed from the input string.\n\n    Raises\n    ------\n    ValueError\n        If the string cannot be safely parsed as a set of integers,\n        or if the string exceeds the maximum allowed length.\n    SyntaxError\n        If the string contains invalid Python syntax.\n    \"\"\"\n    try:\n        parsed_result = ast.literal_eval(node_string)\n\n        # Verify that the result is a set\n        if not isinstance(parsed_result, set):\n            raise ValueError(f\"Expected a set, but got {type(parsed_result).__name__}\")\n\n        # Verify that all elements are integers\n        for element in parsed_result:\n            if not isinstance(element, int):\n                raise ValueError(\"All elements must be integers\")\n\n        return parsed_result\n\n    except (ValueError, SyntaxError) as e:\n        raise ValueError(f\"Could not parse node string '{node_string}': {e}\") from e\n</code></pre>"},{"location":"reference/skeleplex/app/_curate/#skeleplex.app._curate.node_string_to_node_keys(node_string)","title":"<code>node_string</code>","text":"(<code>str</code>)           \u2013            <p>String representation of a set of integers, typically created by calling str() on a set object containing integers.</p>"},{"location":"reference/skeleplex/app/_data/","title":"_data","text":""},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data","title":"skeleplex.app._data","text":"<p>Module for handling data in the SkelePlex application.</p> <p>Classes:</p> <ul> <li> <code>AllViewRequest</code>           \u2013            <p>Request to view all data in the skeleton graph.</p> </li> <li> <code>BoundingBoxData</code>           \u2013            <p>The current bounding box parameters.</p> </li> <li> <code>BoundingBoxEvents</code>           \u2013            <p>Events for the DataManager class.</p> </li> <li> <code>BoundingBoxViewRequest</code>           \u2013            <p>Request to view an axis-aligned bounding box region.</p> </li> <li> <code>DataEvents</code>           \u2013            <p>Events for the DataManager class.</p> </li> <li> <code>DataManager</code>           \u2013            <p>A class to manage data.</p> </li> <li> <code>DataView</code>           \u2013            <p>A class to manage the current view on the data.</p> </li> <li> <code>EdgeSelectionManager</code>           \u2013            <p>Class to manage selection of edge in the viewer.</p> </li> <li> <code>EdgeSelectionPasteRequest</code>           \u2013            <p>Selected edges to paste.</p> </li> <li> <code>NodeSelectionManager</code>           \u2013            <p>Class to manage selection of nodes in the viewer.</p> </li> <li> <code>NodeSelectionPasteRequest</code>           \u2013            <p>Selected nodes to paste.</p> </li> <li> <code>SelectionManager</code>           \u2013            <p>Class to manage selection of data in the viewer.</p> </li> <li> <code>SkeletonDataPaths</code>           \u2013            <p>A class storing the state of the skeleton dataset.</p> </li> <li> <code>ViewEvents</code>           \u2013            <p>Events for the DataManager class.</p> </li> <li> <code>ViewMode</code>           \u2013            <p>The different viewing modes.</p> </li> <li> <code>ViewRequest</code>           \u2013            <p>Base Request to view data in the skeleton graph.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.AllViewRequest","title":"AllViewRequest  <code>dataclass</code>","text":"<pre><code>AllViewRequest()\n</code></pre> <p>               Bases: <code>ViewRequest</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.AllViewRequest[AllViewRequest]\n              skeleplex.app._data.ViewRequest[ViewRequest]\n\n                              skeleplex.app._data.ViewRequest --&gt; skeleplex.app._data.AllViewRequest\n                \n\n\n              click skeleplex.app._data.AllViewRequest href \"\" \"skeleplex.app._data.AllViewRequest\"\n              click skeleplex.app._data.ViewRequest href \"\" \"skeleplex.app._data.ViewRequest\"\n            </code></pre> <p>Request to view all data in the skeleton graph.</p> <p>This is used for passing requests to view all data in the skeleton graph. It does not require any parameters.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData","title":"BoundingBoxData","text":"<pre><code>BoundingBoxData(min_coordinate: ndarray | None = None, max_coordinate: ndarray | None = None)\n</code></pre> <p>The current bounding box parameters.</p> <p>Attributes:</p> <ul> <li> <code>is_populated</code>               (<code>bool</code>)           \u2013            <p>Returns True if the min and max coordinate have been set.</p> </li> <li> <code>max_coordinate</code>               (<code>ndarray | None</code>)           \u2013            <p>Returns the minimum corner of the bounding box.</p> </li> <li> <code>min_coordinate</code>               (<code>ndarray | None</code>)           \u2013            <p>Returns the minimum corner of the bounding box.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    min_coordinate: np.ndarray | None = None,\n    max_coordinate: np.ndarray | None = None,\n):\n    self._min_coordinate = min_coordinate\n    self._max_coordinate = max_coordinate\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData.is_populated","title":"is_populated  <code>property</code>","text":"<pre><code>is_populated: bool\n</code></pre> <p>Returns True if the min and max coordinate have been set.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData.max_coordinate","title":"max_coordinate  <code>property</code> <code>writable</code>","text":"<pre><code>max_coordinate: ndarray | None\n</code></pre> <p>Returns the minimum corner of the bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxData.min_coordinate","title":"min_coordinate  <code>property</code> <code>writable</code>","text":"<pre><code>min_coordinate: ndarray | None\n</code></pre> <p>Returns the minimum corner of the bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxEvents","title":"BoundingBoxEvents","text":"<p>               Bases: <code>SignalGroup</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.BoundingBoxEvents[BoundingBoxEvents]\n\n              \n\n              click skeleplex.app._data.BoundingBoxEvents href \"\" \"skeleplex.app._data.BoundingBoxEvents\"\n            </code></pre> <p>Events for the DataManager class.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxViewRequest","title":"BoundingBoxViewRequest  <code>dataclass</code>","text":"<pre><code>BoundingBoxViewRequest(minimum: ndarray, maximum: ndarray)\n</code></pre> <p>               Bases: <code>ViewRequest</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.BoundingBoxViewRequest[BoundingBoxViewRequest]\n              skeleplex.app._data.ViewRequest[ViewRequest]\n\n                              skeleplex.app._data.ViewRequest --&gt; skeleplex.app._data.BoundingBoxViewRequest\n                \n\n\n              click skeleplex.app._data.BoundingBoxViewRequest href \"\" \"skeleplex.app._data.BoundingBoxViewRequest\"\n              click skeleplex.app._data.ViewRequest href \"\" \"skeleplex.app._data.ViewRequest\"\n            </code></pre> <p>Request to view an axis-aligned bounding box region.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxViewRequest(minimum)","title":"<code>minimum</code>","text":"(<code>ndarray</code>)           \u2013            <p>The minimum corner of the axis-aligned bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.BoundingBoxViewRequest(maximum)","title":"<code>maximum</code>","text":"(<code>ndarray</code>)           \u2013            <p>The maximum corner of the axis-aligned bounding box.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataEvents","title":"DataEvents","text":"<p>               Bases: <code>SignalGroup</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.DataEvents[DataEvents]\n\n              \n\n              click skeleplex.app._data.DataEvents href \"\" \"skeleplex.app._data.DataEvents\"\n            </code></pre> <p>Events for the DataManager class.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager","title":"DataManager","text":"<pre><code>DataManager(file_paths: SkeletonDataPaths, selection: SelectionManager | None = None, edge_colormap: EdgeColormap | None = None, load_data: bool = True)\n</code></pre> <p>A class to manage data.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>events</code>               (<code>DataEvents</code>)           \u2013            <p>The events for the DataManager class.</p> </li> <li> <code>node_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates of the nodes in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for the nodes in the skeleton graph. This is index-matched with the node_coordinates array. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>The coordinates for rendering the edges in the skeleton graph as line segments. Each edge is rendered as a sequence of line segments. All line segments are stored in this array. The array has shape (n_line_segments * 2, 3) where line segment n is defined by the start coordinate edge_coordinates[n * 2, :] and end coordinate edge_coordinates[n * 2 + 1, :]. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_indices</code>               (<code>ndarray | None</code>)           \u2013            <p>The indices for the edges in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>The keys for edges of each edge coordinate in the skeleton graph. This is None when the skeleton hasn't been loaded.</p> </li> <li> <code>edge_colors</code>               (<code>ndarray | None</code>)           \u2013            <p>The colors for the edges in the skeleton graph. These are index-matched with the edge_coordinates array.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>load</code>             \u2013              <p>Load data.</p> </li> <li> <code>to_dict</code>             \u2013              <p>Convert to json-serializable dictionary.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    file_paths: SkeletonDataPaths,\n    selection: SelectionManager | None = None,\n    edge_colormap: EdgeColormap | None = None,\n    load_data: bool = True,\n) -&gt; None:\n    self._file_paths = file_paths\n\n    self._view = DataView(\n        data_manager=self, mode=ViewMode.ALL, bounding_box=BoundingBoxData()\n    )\n\n    # make the selection model\n    if selection is None:\n        selection = SelectionManager(\n            edge=EdgeSelectionManager(enabled=False, values=set()),\n            node=NodeSelectionManager(enabled=False, values=set()),\n        )\n    self._selection = selection\n\n    # make the edge colormap\n    if edge_colormap is None:\n        # default edge color is blue\n        edge_colormap = EdgeColormap(\n            colormap={}, default_color=Color([0.0, 0.0, 1.0, 1.0])\n        )\n    self._edge_colormap = edge_colormap\n\n    # initialize the data\n    self._skeleton_graph: SkeletonGraph | None = None\n    self._node_coordinates: np.ndarray | None = None\n    self._edge_coordinates: np.ndarray | None = None\n    self._edge_indices: np.ndarray | None = None\n    self._edge_keys: np.ndarray | None = None\n    self._edge_colors: np.ndarray | None = None\n\n    if self.file_paths.has_paths() and load_data:\n        self.load()\n\n    # connect the event for updating the view when the data is changed\n    self.events.data.connect(self._view.update)\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager(file_paths)","title":"<code>file_paths</code>","text":"(<code>SkeletonDataPaths</code>)           \u2013            <p>The paths to the data files.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager(selection)","title":"<code>selection</code>","text":"(<code>SelectionManager | None</code>, default:                   <code>None</code> )           \u2013            <p>The selection manager.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_colormap","title":"edge_colormap  <code>property</code> <code>writable</code>","text":"<pre><code>edge_colormap: EdgeColormap\n</code></pre> <p>Get the edge colormap.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_colors","title":"edge_colors  <code>property</code>","text":"<pre><code>edge_colors: ndarray | None\n</code></pre> <p>Get the colors of each edge line segment.</p> <p>(n_edges x 2 x n_points_per_edge, 4) array of RGBA colors.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_coordinates","title":"edge_coordinates  <code>property</code>","text":"<pre><code>edge_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge, 3) array of edge coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_indices","title":"edge_indices  <code>property</code>","text":"<pre><code>edge_indices: ndarray | None\n</code></pre> <p>Get the indices of the edges in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge indices.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.edge_keys","title":"edge_keys  <code>property</code>","text":"<pre><code>edge_keys: ndarray | None\n</code></pre> <p>Get the keys of the edge for each edge coordinate in the skeleton graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge keys.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.file_paths","title":"file_paths  <code>property</code>","text":"<pre><code>file_paths: SkeletonDataPaths\n</code></pre> <p>Get the file paths.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the nodes in the skeleton graph.</p> <p>(n_nodes, 3) array of node coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.node_keys","title":"node_keys  <code>property</code>","text":"<pre><code>node_keys: ndarray | None\n</code></pre> <p>Get the keys of the nodes in the skeleton graph.</p> <p>(n_nodes,) array of node keys. These are index-matched with the node_coordinates array.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.selection","title":"selection  <code>property</code>","text":"<pre><code>selection: SelectionManager\n</code></pre> <p>Get the current data selection.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.skeleton_graph","title":"skeleton_graph  <code>property</code>","text":"<pre><code>skeleton_graph: SkeletonGraph\n</code></pre> <p>Get the skeleton graph.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.view","title":"view  <code>property</code>","text":"<pre><code>view: DataView\n</code></pre> <p>Get the current data view.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.load","title":"load","text":"<pre><code>load() -&gt; None\n</code></pre> <p>Load data.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def load(self) -&gt; None:\n    \"\"\"Load data.\"\"\"\n    # load the skeleton graph\n    if self.file_paths.skeleton_graph:\n        log.info(f\"Loading skeleton graph from {self.file_paths.skeleton_graph}\")\n        self._skeleton_graph = SkeletonGraph.from_json_file(\n            self.file_paths.skeleton_graph\n        )\n        self._update_node_coordinates()\n        self._update_edge_coordinates()\n        self._update_edge_colors()\n    else:\n        log.info(\"No skeleton graph loaded.\")\n        self._skeleton_graph = None\n\n    self.events.data.emit()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataManager.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict\n</code></pre> <p>Convert to json-serializable dictionary.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"Convert to json-serializable dictionary.\"\"\"\n    return self._data.to_dict()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView","title":"DataView","text":"<pre><code>DataView(data_manager: DataManager, bounding_box: BoundingBoxData, mode: ViewMode = ALL)\n</code></pre> <p>A class to manage the current view on the data.</p> <p>Methods:</p> <ul> <li> <code>update</code>             \u2013              <p>Update the data for the currently specified view.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>bounding_box</code>               (<code>BoundingBoxData</code>)           \u2013            <p>Get the current bounding box data.</p> </li> <li> <code>edge_colors</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the colors of the edges in the rendered graph.</p> </li> <li> <code>edge_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the coordinates of the current view of the edges in the rendered graph.</p> </li> <li> <code>edge_indices</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the indices of the current view of the edges in the rendered graph.</p> </li> <li> <code>edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the keys of the edge for each edge coordinate in the rendered graph.</p> </li> <li> <code>highlighted_edge_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get keys of the highlighted edges for each coordinate in the rendered graph.</p> </li> <li> <code>highlighted_node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the indices of the highlighted nodes in the rendered graph.</p> </li> <li> <code>mode</code>               (<code>ViewMode</code>)           \u2013            <p>Get the current view mode.</p> </li> <li> <code>node_coordinates</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the coordinates of the current view of the nodes in the skeleton graph.</p> </li> <li> <code>node_keys</code>               (<code>ndarray | None</code>)           \u2013            <p>Get the keys of the nodes in the rendered graph.</p> </li> </ul> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def __init__(\n    self,\n    data_manager: \"DataManager\",\n    bounding_box: BoundingBoxData,\n    mode: ViewMode = ViewMode.ALL,\n) -&gt; None:\n    self._data_manager = data_manager\n    self._bounding_box = bounding_box\n    self._mode = mode\n\n    # initialize the data\n    self._edge_coordinates: np.ndarray | None = None\n    self._edge_indices: np.ndarray | None = None\n    self._edge_keys: np.ndarray | None = None\n    self._edge_colors: np.ndarray | None = None\n    self._highlighted_edge_keys: np.ndarray | None = None\n    self._node_coordinates: np.ndarray | None = None\n    self._node_keys: np.ndarray | None = None\n    self._highlighted_node_keys: np.ndarray | None = None\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.bounding_box","title":"bounding_box  <code>property</code>","text":"<pre><code>bounding_box: BoundingBoxData\n</code></pre> <p>Get the current bounding box data.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_colors","title":"edge_colors  <code>property</code>","text":"<pre><code>edge_colors: ndarray | None\n</code></pre> <p>Get the colors of the edges in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge, 4) array of RGBA colors.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_coordinates","title":"edge_coordinates  <code>property</code>","text":"<pre><code>edge_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the current view of the edges in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge, 3) array of edge coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_indices","title":"edge_indices  <code>property</code>","text":"<pre><code>edge_indices: ndarray | None\n</code></pre> <p>Get the indices of the current view of the edges in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge indices.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.edge_keys","title":"edge_keys  <code>property</code>","text":"<pre><code>edge_keys: ndarray | None\n</code></pre> <p>Get the keys of the edge for each edge coordinate in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of edge keys.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.highlighted_edge_keys","title":"highlighted_edge_keys  <code>property</code>","text":"<pre><code>highlighted_edge_keys: ndarray | None\n</code></pre> <p>Get keys of the highlighted edges for each coordinate in the rendered graph.</p> <p>(n_edges x 2 x n_points_per_edge,) array of highlighted edge keys.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.highlighted_node_keys","title":"highlighted_node_keys  <code>property</code>","text":"<pre><code>highlighted_node_keys: ndarray | None\n</code></pre> <p>Get the indices of the highlighted nodes in the rendered graph.</p> <p>(n_highlighted_nodes,) array of node indices.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.mode","title":"mode  <code>property</code> <code>writable</code>","text":"<pre><code>mode: ViewMode\n</code></pre> <p>Get the current view mode.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: ndarray | None\n</code></pre> <p>Get the coordinates of the current view of the nodes in the skeleton graph.</p> <p>(n_nodes, 3) array of node coordinates.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.node_keys","title":"node_keys  <code>property</code>","text":"<pre><code>node_keys: ndarray | None\n</code></pre> <p>Get the keys of the nodes in the rendered graph.</p> <p>(n_nodes,) array of node keys. These are index-matched with the node_coordinates array.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.DataView.update","title":"update","text":"<pre><code>update() -&gt; None\n</code></pre> <p>Update the data for the currently specified view.</p> <p>This updates the edge coordinates, edge indices, and node indices.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the data for the currently specified view.\n\n    This updates the edge coordinates, edge indices, and node indices.\n    \"\"\"\n    if self._data_manager.skeleton_graph is None:\n        # if the data isn't loaded, nothing to update\n        return\n    if self._mode == ViewMode.ALL:\n        (\n            self._node_coordinates,\n            self._node_keys,\n            self._edge_coordinates,\n            self._edge_indices,\n            self._edge_keys,\n            self._edge_colors,\n        ) = self._get_view_all()\n        self._highlighted_edge_keys = np.empty((0, 2))\n    elif self._mode == ViewMode.BOUNDING_BOX:\n        (\n            self._node_coordinates,\n            self._node_keys,\n            self._edge_coordinates,\n            self._edge_indices,\n            self._edge_keys,\n            self._edge_colors,\n        ) = self._get_view_bounding_box()\n        self._highlighted_edge_keys = np.empty((0, 2))\n    else:\n        raise NotImplementedError(f\"View mode {self._mode} not implemented.\")\n\n    # Emit signal that the view data has been updated\n    self.events.data.emit()\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionManager","title":"EdgeSelectionManager","text":"<p>               Bases: <code>EventedModel</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.EdgeSelectionManager[EdgeSelectionManager]\n\n              \n\n              click skeleplex.app._data.EdgeSelectionManager href \"\" \"skeleplex.app._data.EdgeSelectionManager\"\n            </code></pre> <p>Class to manage selection of edge in the viewer.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionManager(enabled)","title":"<code>enabled</code>","text":"(<code>bool</code>)           \u2013            <p>Set to true if the edge selection is enabled. The default value is False.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionManager(values)","title":"<code>values</code>","text":"(<code>set[tuple[int, int]] | None</code>)           \u2013            <p>The selected edges.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionPasteRequest","title":"EdgeSelectionPasteRequest  <code>dataclass</code>","text":"<pre><code>EdgeSelectionPasteRequest(edge_keys: set[tuple[int, int]])\n</code></pre> <p>Selected edges to paste.</p> <p>This is used for passing selected edges to the paste operation. For example, when pasting edges from the selection to a GUI widget.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.EdgeSelectionPasteRequest(edge_key)","title":"<code>edge_key</code>","text":"(<code>set[tuple[int, int]]</code>)           \u2013            <p>The keys of the selected edges.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionManager","title":"NodeSelectionManager","text":"<p>               Bases: <code>EventedModel</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.NodeSelectionManager[NodeSelectionManager]\n\n              \n\n              click skeleplex.app._data.NodeSelectionManager href \"\" \"skeleplex.app._data.NodeSelectionManager\"\n            </code></pre> <p>Class to manage selection of nodes in the viewer.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionManager(enabled)","title":"<code>enabled</code>","text":"(<code>bool</code>)           \u2013            <p>Set to true if the edge selection is enabled. The default value is False.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionManager(values)","title":"<code>values</code>","text":"(<code>set[int] | None</code>)           \u2013            <p>The selected nodes.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionPasteRequest","title":"NodeSelectionPasteRequest  <code>dataclass</code>","text":"<pre><code>NodeSelectionPasteRequest(node_keys: set[int])\n</code></pre> <p>Selected nodes to paste.</p> <p>This is used for passing selected nodes to the paste operation. For example, when pasting nodes from the selection to a GUI widget.</p> <p>Parameters:</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.NodeSelectionPasteRequest(node_keys)","title":"<code>node_keys</code>","text":"(<code>set[int]</code>)           \u2013            <p>The keys of the selected nodes.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SelectionManager","title":"SelectionManager","text":"<p>               Bases: <code>EventedModel</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.SelectionManager[SelectionManager]\n\n              \n\n              click skeleplex.app._data.SelectionManager href \"\" \"skeleplex.app._data.SelectionManager\"\n            </code></pre> <p>Class to manage selection of data in the viewer.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths","title":"SkeletonDataPaths","text":"<p>               Bases: <code>EventedModel</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.SkeletonDataPaths[SkeletonDataPaths]\n\n              \n\n              click skeleplex.app._data.SkeletonDataPaths href \"\" \"skeleplex.app._data.SkeletonDataPaths\"\n            </code></pre> <p>A class storing the state of the skeleton dataset.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>has_paths</code>             \u2013              <p>Returns true if any of the paths are set.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths(image)","title":"<code>image</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the image file.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths(segmentation)","title":"<code>segmentation</code>","text":"(<code>FilePath | None</code>)           \u2013            <p>The path to the segmentation image file.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>FilePath</code>)           \u2013            <p>The path to the skeleton graph file.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.SkeletonDataPaths.has_paths","title":"has_paths","text":"<pre><code>has_paths() -&gt; bool\n</code></pre> <p>Returns true if any of the paths are set.</p> Source code in <code>skeleplex/app/_data.py</code> <pre><code>def has_paths(self) -&gt; bool:\n    \"\"\"Returns true if any of the paths are set.\"\"\"\n    return any([self.image, self.segmentation, self.skeleton_graph])\n</code></pre>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.ViewEvents","title":"ViewEvents","text":"<p>               Bases: <code>SignalGroup</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.ViewEvents[ViewEvents]\n\n              \n\n              click skeleplex.app._data.ViewEvents href \"\" \"skeleplex.app._data.ViewEvents\"\n            </code></pre> <p>Events for the DataManager class.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.ViewMode","title":"ViewMode","text":"<p>               Bases: <code>Enum</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app._data.ViewMode[ViewMode]\n\n              \n\n              click skeleplex.app._data.ViewMode href \"\" \"skeleplex.app._data.ViewMode\"\n            </code></pre> <p>The different viewing modes.</p> <p>ALL: Show all data. BOUNDING_BOX: Show data in a specified bounding box. NODE: Show data around a specified node.</p>"},{"location":"reference/skeleplex/app/_data/#skeleplex.app._data.ViewRequest","title":"ViewRequest  <code>dataclass</code>","text":"<pre><code>ViewRequest()\n</code></pre> <p>Base Request to view data in the skeleton graph.</p> <p>Do not use this class directly, use one of the subclasses instead.</p>"},{"location":"reference/skeleplex/app/_utils/","title":"_utils","text":""},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils","title":"skeleplex.app._utils","text":"<p>Functions:</p> <ul> <li> <code>run</code>             \u2013              <p>Start the Qt application event loop.</p> </li> <li> <code>should_launch_ipython_event_loop</code>             \u2013              <p>Check if the IPython Qt event loop should be launched.</p> </li> <li> <code>start_qt_loop_ipython</code>             \u2013              <p>Start the Qt event loop in an IPython environment.</p> </li> <li> <code>view_skeleton</code>             \u2013              <p>Launch the skeleton viewer application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.run","title":"run","text":"<pre><code>run()\n</code></pre> <p>Start the Qt application event loop.</p> <p>This is meant to be used in a script. This should be called after the viewer is set up.</p> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def run():\n    \"\"\"Start the Qt application event loop.\n\n    This is meant to be used in a script.\n    This should be called after the viewer is set up.\n    \"\"\"\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # start the Qt application event loop\n    qapp.exec_()\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.should_launch_ipython_event_loop","title":"should_launch_ipython_event_loop","text":"<pre><code>should_launch_ipython_event_loop() -&gt; bool\n</code></pre> <p>Check if the IPython Qt event loop should be launched.</p> <p>This means that we are both in an IPython environment and the event loop is not already running.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if running in IPython and the loop is needed. False otherwise.</p> </li> </ul> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def should_launch_ipython_event_loop() -&gt; bool:\n    \"\"\"\n    Check if the IPython Qt event loop should be launched.\n\n    This means that we are both in an IPython environment and the\n    event loop is not already running.\n\n    Returns\n    -------\n    bool\n        True if running in IPython and the loop is needed.\n        False otherwise.\n    \"\"\"\n    shell = get_ipython()\n\n    if not shell:\n        # not in IPython environment\n        return False\n\n    return not shell.active_eventloop == \"qt\"\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.start_qt_loop_ipython","title":"start_qt_loop_ipython","text":"<pre><code>start_qt_loop_ipython()\n</code></pre> <p>Start the Qt event loop in an IPython environment.</p> <p>This works for both jupyter and ipython console environments.</p> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def start_qt_loop_ipython():\n    \"\"\"Start the Qt event loop in an IPython environment.\n\n    This works for both jupyter and ipython console environments.\n    \"\"\"\n    ipython = get_ipython()\n    ipython.enable_gui(\"qt\")\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.view_skeleton","title":"view_skeleton","text":"<pre><code>view_skeleton(graph_path: str, launch_widgets: bool = True)\n</code></pre> <p>Launch the skeleton viewer application.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SkelePlexApp</code>           \u2013            <p>The SkelePlex application instance for viewing the skeleton.</p> </li> </ul> Source code in <code>skeleplex/app/_utils.py</code> <pre><code>def view_skeleton(\n    graph_path: str,\n    launch_widgets: bool = True,\n):\n    \"\"\"Launch the skeleton viewer application.\n\n    Parameters\n    ----------\n    graph_path : str\n        Path to the skeleton graph JSON file.\n    launch_widgets : bool, optional\n        Whether to launch the auxiliary widgets for curation.\n        Defaults to True.\n\n    Returns\n    -------\n    SkelePlexApp\n        The SkelePlex application instance for viewing the skeleton.\n    \"\"\"\n    global _app_ref\n\n    # get the qapplication instance\n    qapp = QApplication.instance() or QApplication([])\n\n    # Store reference to prevent garbage collection\n    _app_ref = qapp\n\n    # load the data\n    data_manager = DataManager(file_paths=SkeletonDataPaths(skeleton_graph=graph_path))\n\n    # make the viewer\n    viewer = SkelePlexApp(data=data_manager)\n    viewer.show()\n\n    # Wait a short time for things to load and then look at the skeleton\n    # this is a hack...do something smarter later\n    timer = QTimer()\n    timer.singleShot(100, viewer.look_at_skeleton)\n\n    # start the Qt event loop if in Jupyter/IPython\n    if should_launch_ipython_event_loop():\n        start_qt_loop_ipython()\n\n    if launch_widgets:\n        undo_widget = magicgui(viewer.curate.undo)\n        delete_edge_widget = magicgui(\n            viewer.curate.delete_edge,\n        )\n        render_around_node_widget = magicgui(\n            viewer.curate.render_around_node,\n            node_id={\n                \"widget_type\": \"LineEdit\",\n            },\n            bounding_box_width={\"min\": 0, \"max\": sys.float_info.max},\n        )\n\n        connect_without_merging_widget = magicgui(\n            viewer.curate.connect_without_merging,\n        )\n        connect_with_merging_widget = magicgui(\n            viewer.curate.connect_with_merging,\n        )\n        split_edge_widget = make_split_edge_widget(viewer)\n\n        ChangeBranchColorWidget(viewer)\n\n        # add to viewer\n        viewer.add_auxiliary_widget(undo_widget.native, name=\"Undo\")\n        viewer.add_auxiliary_widget(delete_edge_widget.native, name=\"Delete edge\")\n        viewer.add_auxiliary_widget(\n            render_around_node_widget.native, name=\"Render around node\"\n        )\n        viewer.add_auxiliary_widget(\n            connect_without_merging_widget.native, name=\"Connect without merging\"\n        )\n        viewer.add_auxiliary_widget(\n            connect_with_merging_widget.native, name=\"Connect with merging\"\n        )\n        viewer.add_auxiliary_widget(split_edge_widget.native, name=\"Split edge\")\n    return viewer\n</code></pre>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.view_skeleton(graph_path)","title":"<code>graph_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the skeleton graph JSON file.</p>"},{"location":"reference/skeleplex/app/_utils/#skeleplex.app._utils.view_skeleton(launch_widgets)","title":"<code>launch_widgets</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to launch the auxiliary widgets for curation. Defaults to True.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/","title":"_viewer_controller","text":""},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller","title":"skeleplex.app._viewer_controller","text":"<p>Classes for interfacing with the viewer.</p> <p>Classes:</p> <ul> <li> <code>MainCanvasController</code>           \u2013            <p>A class for controlling the main canvas.</p> </li> <li> <code>RenderedSkeletonComponents</code>           \u2013            <p>A class for storing the components for a rendered skeleton.</p> </li> <li> <code>ViewerController</code>           \u2013            <p>A class for controlling the viewer backend.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController","title":"MainCanvasController","text":"<pre><code>MainCanvasController(scene_id: str, backend: CellierController)\n</code></pre> <p>A class for controlling the main canvas.</p> <p>Methods:</p> <ul> <li> <code>add_skeleton_edge_callback</code>             \u2013              <p>Add a callback to the skeleton edge visual.</p> </li> <li> <code>add_skeleton_node_callback</code>             \u2013              <p>Add a callback to the skeleton node visual.</p> </li> <li> <code>look_at_skeleton</code>             \u2013              <p>Adjust the camera to look at the skeleton.</p> </li> <li> <code>remove_skeleton_edge_callback</code>             \u2013              <p>Remove a callback from the skeleton edge visual.</p> </li> <li> <code>remove_skeleton_node_callback</code>             \u2013              <p>Remove a callback from the skeleton node visual.</p> </li> <li> <code>set_edge_highlight</code>             \u2013              <p>Set the edge highlight coordinates.</p> </li> <li> <code>set_node_highlight</code>             \u2013              <p>Set the node highlight coordinates.</p> </li> <li> <code>update_skeleton_geometry</code>             \u2013              <p>Update the geometry of the skeleton in the viewer.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>scene_id</code>               (<code>str</code>)           \u2013            <p>Get the scene ID of the main canvas.</p> </li> </ul> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def __init__(self, scene_id: str, backend: CellierController):\n    self._scene_id = scene_id\n    self._backend = backend\n\n    # this will store the rendered skeleton components\n    self._skeleton = RenderedSkeletonComponents()\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.scene_id","title":"scene_id  <code>property</code>","text":"<pre><code>scene_id: str\n</code></pre> <p>Get the scene ID of the main canvas.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_edge_callback","title":"add_skeleton_edge_callback","text":"<pre><code>add_skeleton_edge_callback(callback: Callable)\n</code></pre> <p>Add a callback to the skeleton edge visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def add_skeleton_edge_callback(\n    self,\n    callback: Callable,\n):\n    \"\"\"Add a callback to the skeleton edge visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    # add for the data visual\n    if (\n        self._skeleton.edges_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.edges_visual.id\n        )\n    self._backend.events.mouse.subscribe_to_visual(\n        visual_id=self._skeleton.edges_visual.id,\n        callback=partial(callback, click_source=\"data\"),\n    )\n\n    # add for the highlight visual\n    if (\n        self._skeleton.edge_highlight_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.edge_highlight_visual.id\n        )\n    self._backend.events.mouse.subscribe_to_visual(\n        visual_id=self._skeleton.edge_highlight_visual.id,\n        callback=partial(callback, click_source=\"highlight\"),\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_edge_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_node_callback","title":"add_skeleton_node_callback","text":"<pre><code>add_skeleton_node_callback(callback: Callable)\n</code></pre> <p>Add a callback to the skeleton node visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def add_skeleton_node_callback(self, callback: Callable):\n    \"\"\"Add a callback to the skeleton node visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    callback_type : tuple[str, ...]\n        The type of callback. See the pygfx documentation for event types.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    # add for the data visual\n    if (\n        self._skeleton.node_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.node_visual.id\n        )\n    self._backend.events.mouse.subscribe_to_visual(\n        visual_id=self._skeleton.node_visual.id,\n        callback=partial(callback, click_source=\"data\"),\n    )\n\n    # add for the highlight visual\n    if (\n        self._skeleton.node_highlight_visual.id\n        not in self._backend.events.mouse.visual_signals\n    ):\n        # if the visual isn't registered, register it\n        self._backend.events.mouse.register_visual(\n            visual_id=self._skeleton.node_highlight_visual.id\n        )\n        self._backend.events.mouse.subscribe_to_visual(\n            visual_id=self._skeleton.node_highlight_visual.id,\n            callback=partial(callback, click_source=\"highlight\"),\n        )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_node_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.add_skeleton_node_callback(callback_type)","title":"<code>callback_type</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>The type of callback. See the pygfx documentation for event types.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.look_at_skeleton","title":"look_at_skeleton","text":"<pre><code>look_at_skeleton(view_direction: tuple[int, int, int] = (0, 0, 1), up: tuple[int, int, int] = (0, 1, 0))\n</code></pre> <p>Adjust the camera to look at the skeleton.</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def look_at_skeleton(\n    self,\n    view_direction: tuple[int, int, int] = (0, 0, 1),\n    up: tuple[int, int, int] = (0, 1, 0),\n):\n    \"\"\"Adjust the camera to look at the skeleton.\"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._backend.look_at_visual(\n        visual_id=self._skeleton.node_visual.id,\n        view_direction=view_direction,\n        up=up,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_edge_callback","title":"remove_skeleton_edge_callback","text":"<pre><code>remove_skeleton_edge_callback(callback: Callable)\n</code></pre> <p>Remove a callback from the skeleton edge visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def remove_skeleton_edge_callback(self, callback: Callable):\n    \"\"\"Remove a callback from the skeleton edge visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    callback_type : tuple[str, ...]\n        The type of callback. See the pygfx documentation for event types.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._backend.remove_visual_callback(\n        visual_id=self._skeleton.edges_visual.id,\n        callback=callback,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_edge_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_edge_callback(callback_type)","title":"<code>callback_type</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>The type of callback. See the pygfx documentation for event types.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_node_callback","title":"remove_skeleton_node_callback","text":"<pre><code>remove_skeleton_node_callback(callback: Callable)\n</code></pre> <p>Remove a callback from the skeleton node visual.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def remove_skeleton_node_callback(self, callback: Callable):\n    \"\"\"Remove a callback from the skeleton node visual.\n\n    Parameters\n    ----------\n    callback : Callable\n        The callback function.\n    callback_type : tuple[str, ...]\n        The type of callback. See the pygfx documentation for event types.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._backend.remove_visual_callback(\n        visual_id=self._skeleton.node_visual.id,\n        callback=callback,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_node_callback(callback)","title":"<code>callback</code>","text":"(<code>Callable</code>)           \u2013            <p>The callback function.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.remove_skeleton_node_callback(callback_type)","title":"<code>callback_type</code>","text":"(<code>tuple[str, ...]</code>)           \u2013            <p>The type of callback. See the pygfx documentation for event types.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_edge_highlight","title":"set_edge_highlight","text":"<pre><code>set_edge_highlight(edge_coordinates: ndarray)\n</code></pre> <p>Set the edge highlight coordinates.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def set_edge_highlight(\n    self,\n    edge_coordinates: np.ndarray,\n):\n    \"\"\"Set the edge highlight coordinates.\n\n    Parameters\n    ----------\n    edge_coordinates : np.ndarray\n        The coordinates of the edge to highlight.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._skeleton.edge_highlight_store.coordinates = edge_coordinates.astype(\n        np.float32\n    )\n    self._backend.reslice_scene(scene_id=self.scene_id)\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_edge_highlight(edge_coordinates)","title":"<code>edge_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the edge to highlight.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_node_highlight","title":"set_node_highlight","text":"<pre><code>set_node_highlight(node_coordinates: ndarray) -&gt; None\n</code></pre> <p>Set the node highlight coordinates.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def set_node_highlight(\n    self,\n    node_coordinates: np.ndarray,\n) -&gt; None:\n    \"\"\"Set the node highlight coordinates.\n\n    Parameters\n    ----------\n    node_coordinates : np.ndarray\n        The coordinates of the node to highlight.\n    \"\"\"\n    if not self._skeleton.populated():\n        # don't do anything if the skeleton is not rendered\n        return\n\n    self._skeleton.node_highlight_store.coordinates = node_coordinates.astype(\n        np.float32\n    )\n    self._backend.reslice_scene(scene_id=self.scene_id)\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.set_node_highlight(node_coordinates)","title":"<code>node_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates of the node to highlight.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.update_skeleton_geometry","title":"update_skeleton_geometry","text":"<pre><code>update_skeleton_geometry(edge_coordinates: ndarray, edge_colors: ndarray, node_coordinates: ndarray)\n</code></pre> <p>Update the geometry of the skeleton in the viewer.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def update_skeleton_geometry(\n    self,\n    edge_coordinates: np.ndarray,\n    edge_colors: np.ndarray,\n    node_coordinates: np.ndarray,\n):\n    \"\"\"Update the geometry of the skeleton in the viewer.\n\n    Parameters\n    ----------\n    edge_coordinates : np.ndarray\n        (n_edges * 2 * n_segments_per_edge) array of coordinates of\n        the edges of the skeleton to be rendered.\n    edge_colors : np.ndarray\n        (n_edges * 2 * n_segments_per_edge, 4 ) RGBA array of colors\n        of the edges of the skeleton to be rendered.\n    node_coordinates : np.ndarray\n        (n_nodes, 3) array of coordinates of the nodes of the skeleton\n        to be rendered.\n    \"\"\"\n    # make the highlight lines store\n    if self._skeleton.edge_highlight_store is None:\n        # if the highlight store is not populated, create it\n        self._skeleton.edge_highlight_store = LinesMemoryStore(\n            coordinates=np.empty((0, 3))\n        )\n        self._backend.add_data_store(data_store=self._skeleton.edge_highlight_store)\n\n    if self._skeleton.edge_highlight_visual is None:\n        # if the highlight visual is not populated, create it\n        edge_highlight_material_3d = LinesUniformAppearance(\n            color=(1, 0, 1, 1), size=6, size_coordinate_space=\"data\", opacity=1.0\n        )\n\n        # make the highlight lines model\n        edge_highlight_visual = LinesVisual(\n            name=\"edge_highlight\",\n            data_store_id=self._skeleton.edge_highlight_store.id,\n            appearance=edge_highlight_material_3d,\n            pick_write=True,\n        )\n        self._skeleton.edge_highlight_visual = edge_highlight_visual\n\n        # add the visual model to the viewer\n        self._backend.add_visual(\n            visual_model=edge_highlight_visual, scene_id=self.scene_id\n        )\n\n    # update the lines store\n    if self._skeleton.edges_store is None:\n        self._skeleton.edges_store = LinesMemoryStore(\n            coordinates=edge_coordinates, colors=edge_colors\n        )\n        self._backend.add_data_store(data_store=self._skeleton.edges_store)\n    else:\n        self._skeleton.edges_store.coordinates = edge_coordinates.astype(np.float32)\n        self._skeleton.edges_store.colors = edge_colors.astype(np.float32)\n\n    if self._skeleton.edges_visual is None:\n        # if the lines visual is not populated, create it\n        edge_lines_material_3d = LinesVertexColorAppearance(\n            size=2, size_coordinate_space=\"data\"\n        )\n\n        # make the lines model\n        edge_lines_visual = LinesVisual(\n            name=\"edge_lines\",\n            data_store_id=self._skeleton.edges_store.id,\n            appearance=edge_lines_material_3d,\n        )\n        self._skeleton.edges_visual = edge_lines_visual\n        self._backend.add_visual(\n            visual_model=edge_lines_visual, scene_id=self.scene_id\n        )\n\n    if self._skeleton.node_highlight_store is None:\n        # make the highlight points store if it is not already created\n        self._skeleton.node_highlight_store = PointsMemoryStore(\n            coordinates=np.empty((0, 3), dtype=np.float32)\n        )\n        self._backend.add_data_store(data_store=self._skeleton.node_highlight_store)\n\n    if self._skeleton.node_highlight_visual is None:\n        # make the highlight points material\n        highlight_points_material_3d = PointsUniformAppearance(\n            size=20, color=(0, 1, 0, 1), size_coordinate_space=\"data\"\n        )\n\n        # make the highlight points model\n        highlight_points_visual_3d = PointsVisual(\n            name=\"node_highlight_points\",\n            data_store_id=self._skeleton.node_highlight_store.id,\n            appearance=highlight_points_material_3d,\n        )\n        self._skeleton.node_highlight_visual = highlight_points_visual_3d\n\n        # add the highlights to the viewer\n        self._backend.add_visual(\n            visual_model=highlight_points_visual_3d, scene_id=self.scene_id\n        )\n\n    if self._skeleton.node_store is None:\n        # make the points store if it is not already created\n        self._skeleton.node_store = PointsMemoryStore(coordinates=node_coordinates)\n        self._backend.add_data_store(data_store=self._skeleton.node_store)\n    else:\n        # update the points store with the new coordinates\n        self._skeleton.node_store.coordinates = node_coordinates.astype(np.float32)\n\n    if self._skeleton.node_visual is None:\n        # make the points material\n        points_material_3d = PointsUniformAppearance(\n            size=8, color=(0, 0, 0, 1), size_coordinate_space=\"data\"\n        )\n\n        # make the points model\n        points_visual_3d = PointsVisual(\n            name=\"node_points\",\n            data_store_id=self._skeleton.node_store.id,\n            appearance=points_material_3d,\n        )\n        self._skeleton.node_visual = points_visual_3d\n        self._backend.add_visual(\n            visual_model=points_visual_3d, scene_id=self.scene_id\n        )\n\n    # reslice the scene\n    self._backend.reslice_scene(scene_id=self.scene_id)\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.update_skeleton_geometry(edge_coordinates)","title":"<code>edge_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_edges * 2 * n_segments_per_edge) array of coordinates of the edges of the skeleton to be rendered.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.update_skeleton_geometry(edge_colors)","title":"<code>edge_colors</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_edges * 2 * n_segments_per_edge, 4 ) RGBA array of colors of the edges of the skeleton to be rendered.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.MainCanvasController.update_skeleton_geometry(node_coordinates)","title":"<code>node_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_nodes, 3) array of coordinates of the nodes of the skeleton to be rendered.</p>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.RenderedSkeletonComponents","title":"RenderedSkeletonComponents  <code>dataclass</code>","text":"<pre><code>RenderedSkeletonComponents(node_store: PointsMemoryStore | None = None, node_visual: PointsVisual | None = None, node_highlight_store: PointsMemoryStore | None = None, node_highlight_visual: PointsVisual | None = None, edges_store: LinesMemoryStore | None = None, edges_visual: LinesVisual | None = None, edge_highlight_store: LinesMemoryStore | None = None, edge_highlight_visual: LinesVisual | None = None)\n</code></pre> <p>A class for storing the components for a rendered skeleton.</p> <p>These data are used for accessing the rendered skeleton in the viewer backend.</p> <p>Methods:</p> <ul> <li> <code>populated</code>             \u2013              <p>Returns True if all the components are populated.</p> </li> </ul>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.RenderedSkeletonComponents.populated","title":"populated","text":"<pre><code>populated() -&gt; bool\n</code></pre> <p>Returns True if all the components are populated.</p> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def populated(self) -&gt; bool:\n    \"\"\"Returns True if all the components are populated.\"\"\"\n    return all(\n        [\n            self.node_store is not None,\n            self.node_visual is not None,\n            self.node_highlight_store is not None,\n            self.node_highlight_visual is not None,\n            self.edges_store is not None,\n            self.edges_visual is not None,\n            self.edge_highlight_store is not None,\n            self.edge_highlight_visual is not None,\n        ]\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.ViewerController","title":"ViewerController","text":"<pre><code>ViewerController()\n</code></pre> <p>A class for controlling the viewer backend.</p> <p>Attributes:</p> <ul> <li> <code>main_canvas</code>               (<code>MainCanvasController</code>)           \u2013            <p>Get the controller for the main canvas.</p> </li> </ul> Source code in <code>skeleplex/app/_viewer_controller.py</code> <pre><code>def __init__(self):\n    viewer_model, main_canvas_scene_id = make_viewer_model()\n    self._backend = make_viewer_controller(viewer_model=viewer_model)\n\n    # make the main canvas controller\n    self._main_canvas = MainCanvasController(\n        scene_id=main_canvas_scene_id, backend=self._backend\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/_viewer_controller/#skeleplex.app._viewer_controller.ViewerController.main_canvas","title":"main_canvas  <code>property</code>","text":"<pre><code>main_canvas: MainCanvasController\n</code></pre> <p>Get the controller for the main canvas.</p>"},{"location":"reference/skeleplex/app/actions/","title":"actions","text":""},{"location":"reference/skeleplex/app/actions/#skeleplex.app.actions","title":"skeleplex.app.actions","text":"<p>Actions to be registered for the application.</p>"},{"location":"reference/skeleplex/app/functions/","title":"functions","text":""},{"location":"reference/skeleplex/app/functions/#skeleplex.app.functions","title":"skeleplex.app.functions","text":"<p>Functions for the app.</p> <p>Functions:</p> <ul> <li> <code>close</code>             \u2013              <p>Close the active window.</p> </li> </ul>"},{"location":"reference/skeleplex/app/functions/#skeleplex.app.functions.close","title":"close","text":"<pre><code>close()\n</code></pre> <p>Close the active window.</p> Source code in <code>skeleplex/app/functions.py</code> <pre><code>def close():\n    \"\"\"Close the active window.\"\"\"\n    QApplication.activeWindow().close()\n    print(\"close\")\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/","title":"cellier","text":""},{"location":"reference/skeleplex/app/cellier/#skeleplex.app.cellier","title":"skeleplex.app.cellier","text":"<p>Cellier rendering module.</p> <p>Modules:</p> <ul> <li> <code>utils</code>           \u2013            <p>Viewer controller for the Cellier renderer.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>make_viewer_controller</code>             \u2013              <p>Make the viewer controller.</p> </li> <li> <code>make_viewer_model</code>             \u2013              <p>Make the viewer controller.</p> </li> </ul>"},{"location":"reference/skeleplex/app/cellier/#skeleplex.app.cellier.make_viewer_controller","title":"make_viewer_controller","text":"<pre><code>make_viewer_controller(viewer_model: ViewerModel) -&gt; CellierController\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_controller(viewer_model: ViewerModel) -&gt; CellierController:\n    \"\"\"Make the viewer controller.\"\"\"\n    return CellierController(\n        model=viewer_model,\n        slicer_type=SlicerType.ASYNCHRONOUS,\n        populate_renderer=False,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/#skeleplex.app.cellier.make_viewer_model","title":"make_viewer_model","text":"<pre><code>make_viewer_model() -&gt; tuple[ViewerModel, str]\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_model() -&gt; tuple[ViewerModel, str]:\n    \"\"\"Make the viewer controller.\"\"\"\n    # make the data manager (empty for now)\n    data_manager = DataManager(stores={})\n\n    # make the scene coordinate system\n    coordinate_system_3d = CoordinateSystem(\n        name=\"scene_3d\", axis_labels=(\"z\", \"y\", \"x\")\n    )\n    dims_3d = DimsManager(\n        coordinate_system=coordinate_system_3d,\n        range=(RangeTuple(0, 100, 1), RangeTuple(0, 100, 1), RangeTuple(0, 100, 1)),\n        selection=AxisAlignedRegionSelector(\n            space_type=CoordinateSpace.WORLD,\n            ordered_dims=(0, 1, 2),\n            n_displayed_dims=3,\n            index_selection=(slice(None, None), slice(None, None), slice(None, None)),\n        ),\n    )\n\n    # make the canvas\n    controller = TrackballCameraController(enabled=True)\n    camera_3d = PerspectiveCamera(controller=controller)\n    canvas_3d = Canvas(camera=camera_3d)\n\n    # make the scene\n    main_viewer_scene = Scene(\n        dims=dims_3d, visuals=[], canvases={canvas_3d.id: canvas_3d}\n    )\n\n    scene_manager = SceneManager(scenes={main_viewer_scene.id: main_viewer_scene})\n\n    # make the viewer model\n    viewer_model = ViewerModel(data=data_manager, scenes=scene_manager)\n\n    return viewer_model, main_viewer_scene.id\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/utils/","title":"utils","text":""},{"location":"reference/skeleplex/app/cellier/utils/#skeleplex.app.cellier.utils","title":"skeleplex.app.cellier.utils","text":"<p>Viewer controller for the Cellier renderer.</p> <p>Functions:</p> <ul> <li> <code>make_viewer_controller</code>             \u2013              <p>Make the viewer controller.</p> </li> <li> <code>make_viewer_model</code>             \u2013              <p>Make the viewer controller.</p> </li> </ul>"},{"location":"reference/skeleplex/app/cellier/utils/#skeleplex.app.cellier.utils.make_viewer_controller","title":"make_viewer_controller","text":"<pre><code>make_viewer_controller(viewer_model: ViewerModel) -&gt; CellierController\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_controller(viewer_model: ViewerModel) -&gt; CellierController:\n    \"\"\"Make the viewer controller.\"\"\"\n    return CellierController(\n        model=viewer_model,\n        slicer_type=SlicerType.ASYNCHRONOUS,\n        populate_renderer=False,\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/cellier/utils/#skeleplex.app.cellier.utils.make_viewer_model","title":"make_viewer_model","text":"<pre><code>make_viewer_model() -&gt; tuple[ViewerModel, str]\n</code></pre> <p>Make the viewer controller.</p> Source code in <code>skeleplex/app/cellier/utils.py</code> <pre><code>def make_viewer_model() -&gt; tuple[ViewerModel, str]:\n    \"\"\"Make the viewer controller.\"\"\"\n    # make the data manager (empty for now)\n    data_manager = DataManager(stores={})\n\n    # make the scene coordinate system\n    coordinate_system_3d = CoordinateSystem(\n        name=\"scene_3d\", axis_labels=(\"z\", \"y\", \"x\")\n    )\n    dims_3d = DimsManager(\n        coordinate_system=coordinate_system_3d,\n        range=(RangeTuple(0, 100, 1), RangeTuple(0, 100, 1), RangeTuple(0, 100, 1)),\n        selection=AxisAlignedRegionSelector(\n            space_type=CoordinateSpace.WORLD,\n            ordered_dims=(0, 1, 2),\n            n_displayed_dims=3,\n            index_selection=(slice(None, None), slice(None, None), slice(None, None)),\n        ),\n    )\n\n    # make the canvas\n    controller = TrackballCameraController(enabled=True)\n    camera_3d = PerspectiveCamera(controller=controller)\n    canvas_3d = Canvas(camera=camera_3d)\n\n    # make the scene\n    main_viewer_scene = Scene(\n        dims=dims_3d, visuals=[], canvases={canvas_3d.id: canvas_3d}\n    )\n\n    scene_manager = SceneManager(scenes={main_viewer_scene.id: main_viewer_scene})\n\n    # make the viewer model\n    viewer_model = ViewerModel(data=data_manager, scenes=scene_manager)\n\n    return viewer_model, main_viewer_scene.id\n</code></pre>"},{"location":"reference/skeleplex/app/qt/","title":"qt","text":""},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt","title":"skeleplex.app.qt","text":"<p>Qt widgets for the SkelePlex app.</p> <p>Modules:</p> <ul> <li> <code>app_controls</code>           \u2013            <p>Dock widget for the Application Controls.</p> </li> <li> <code>auxiliary_views</code>           \u2013            <p>Dock widget to hold additional views of the data.</p> </li> <li> <code>flat_group_box</code>           \u2013            <p>A flat-styled group box widget.</p> </li> <li> <code>main_viewer</code>           \u2013            <p>Widgets for the main viewer.</p> </li> <li> <code>styles</code>           \u2013            <p>QSS styles for the application.</p> </li> <li> <code>window</code>           \u2013            <p>Qt implementation of the main window for the application.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>AppControlsDock</code>           \u2013            <p>A dock widget for the application controls.</p> </li> <li> <code>AuxiliaryViews</code>           \u2013            <p>A dock widget for the auxiliary views.</p> </li> <li> <code>MainWindow</code>           \u2013            <p>Qt + app-model implementation of the main window for the application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.AppControlsDock","title":"AppControlsDock","text":"<pre><code>AppControlsDock(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.AppControlsDock[AppControlsDock]\n\n              \n\n              click skeleplex.app.qt.AppControlsDock href \"\" \"skeleplex.app.qt.AppControlsDock\"\n            </code></pre> <p>A dock widget for the application controls.</p> <p>This will be used as a container GUI elements for controlling the state of the application.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n    self.setWidget(AppControlsWidget(parent=self))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.AuxiliaryViews","title":"AuxiliaryViews","text":"<pre><code>AuxiliaryViews(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.AuxiliaryViews[AuxiliaryViews]\n\n              \n\n              click skeleplex.app.qt.AuxiliaryViews href \"\" \"skeleplex.app.qt.AuxiliaryViews\"\n            </code></pre> <p>A dock widget for the auxiliary views.</p> <p>This will hold things like a view of slices along a spline.</p> Source code in <code>skeleplex/app/qt/auxiliary_views.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n\n    self.label = QLabel(\"I'm the Auxiliary Views\")\n    self.label.setMinimumWidth(self.MINIMUM_WIDTH)\n\n    self.setWidget(self.label)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.MainWindow","title":"MainWindow","text":"<pre><code>MainWindow(app: Application)\n</code></pre> <p>               Bases: <code>QModelMainWindow</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.MainWindow[MainWindow]\n\n              \n\n              click skeleplex.app.qt.MainWindow href \"\" \"skeleplex.app.qt.MainWindow\"\n            </code></pre> <p>Qt + app-model implementation of the main window for the application.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the auxiliary views dock.</p> </li> </ul> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def __init__(self, app: Application):\n    super().__init__(app)\n\n    # set the background color\n    self.setStyleSheet(MAIN_WINDOW_STYLE)\n\n    # self.tool_bar = self.addModelToolBar(MenuId.FILE, exclude={CommandId.OPEN})\n    # self.tool_bar.setStyleSheet(\"background: white;\")\n\n    self._main_viewer_widget = MainViewerWidget(parent=self)\n    self.setCentralWidget(self._main_viewer_widget)\n\n    # set the minimum window size - app will launch with this size.\n    self.setMinimumSize(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT)\n\n    # Create the app controls as a dock widget (left)\n    self._create_app_controls()\n\n    # create the auxiliary views as a dock widget (right)\n    self._create_auxiliary_views()\n\n    # create the status bar at the bottom of the window\n    self._create_status_bar()\n</code></pre>"},{"location":"reference/skeleplex/app/qt/#skeleplex.app.qt.MainWindow.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget: QWidget, name: str = '')\n</code></pre> <p>Add a widget to the auxiliary views dock.</p> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def add_auxiliary_widget(self, widget: QWidget, name: str = \"\"):\n    \"\"\"Add a widget to the auxiliary views dock.\"\"\"\n    dock_widget = QDockWidget(name)\n    dock_widget.setWidget(widget)\n    self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, dock_widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/","title":"app_controls","text":""},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls","title":"skeleplex.app.qt.app_controls","text":"<p>Dock widget for the Application Controls.</p> <p>Classes:</p> <ul> <li> <code>AppControlsDock</code>           \u2013            <p>A dock widget for the application controls.</p> </li> <li> <code>AppControlsWidget</code>           \u2013            <p>A widget for the application controls.</p> </li> <li> <code>DataSelectorWidget</code>           \u2013            <p>A widget for selecting data from the main viewer.</p> </li> <li> <code>DataViewWidget</code>           \u2013            <p>A widget for selecting which regions of the data are in view.</p> </li> <li> <code>SelectionModeWidget</code>           \u2013            <p>Widget for controlling a selection mode.</p> </li> <li> <code>ViewAllModeControls</code>           \u2013            <p>A widget for controlling the view all mode.</p> </li> <li> <code>ViewBoundingBoxControls</code>           \u2013            <p>A widget for controlling the bounding box view mode.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.AppControlsDock","title":"AppControlsDock","text":"<pre><code>AppControlsDock(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.AppControlsDock[AppControlsDock]\n\n              \n\n              click skeleplex.app.qt.app_controls.AppControlsDock href \"\" \"skeleplex.app.qt.app_controls.AppControlsDock\"\n            </code></pre> <p>A dock widget for the application controls.</p> <p>This will be used as a container GUI elements for controlling the state of the application.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n    self.setWidget(AppControlsWidget(parent=self))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.AppControlsWidget","title":"AppControlsWidget","text":"<pre><code>AppControlsWidget(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.AppControlsWidget[AppControlsWidget]\n\n              \n\n              click skeleplex.app.qt.app_controls.AppControlsWidget href \"\" \"skeleplex.app.qt.app_controls.AppControlsWidget\"\n            </code></pre> <p>A widget for the application controls.</p> <p>This is the widget embedded in the AppControlsDock.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n\n    self.load_data_widget = magicgui(self._load_data_gui)\n    stores_box = FlatVGroupBox(\n        \"Data Stores\", accent_color=\"#b7e2d8\", collapsible=True, parent=self\n    )\n    stores_box.add_widget(self.load_data_widget.native)\n\n    # widget for selecting the data view\n    self.view_box = DataViewWidget(\n        collapsible=True,\n        parent=self,\n    )\n\n    # widget for selecting the data selection mode\n    self.selection_box = DataSelectorWidget(collapsible=True, parent=self)\n\n    # make the layout\n    layout = QVBoxLayout()\n    layout.addWidget(stores_box)\n    layout.addWidget(self.view_box)\n    layout.addWidget(self.selection_box)\n    layout.addStretch()\n\n    layout.setAlignment(Qt.AlignTop)\n\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataSelectorWidget","title":"DataSelectorWidget","text":"<pre><code>DataSelectorWidget(collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>FlatHGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.DataSelectorWidget[DataSelectorWidget]\n              skeleplex.app.qt.flat_group_box.FlatHGroupBox[FlatHGroupBox]\n\n                              skeleplex.app.qt.flat_group_box.FlatHGroupBox --&gt; skeleplex.app.qt.app_controls.DataSelectorWidget\n                \n\n\n              click skeleplex.app.qt.app_controls.DataSelectorWidget href \"\" \"skeleplex.app.qt.app_controls.DataSelectorWidget\"\n              click skeleplex.app.qt.flat_group_box.FlatHGroupBox href \"\" \"skeleplex.app.qt.flat_group_box.FlatHGroupBox\"\n            </code></pre> <p>A widget for selecting data from the main viewer.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, collapsible: bool = False, parent: QWidget | None = None):\n    super().__init__(\n        title=\"Data Selector\",\n        accent_color=\"#cab8c4\",\n        collapsible=collapsible,\n        parent=parent,\n    )\n\n    self.edge_mode_box = SelectionModeWidget(title=\"Edge\", parent=self)\n    self.node_mode_box = SelectionModeWidget(title=\"Node\", parent=self)\n\n    # Add the widgets\n    self.add_widget(self.edge_mode_box)\n    self.add_widget(self.node_mode_box)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataSelectorWidget.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataSelectorWidget.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataViewWidget","title":"DataViewWidget","text":"<pre><code>DataViewWidget(collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>FlatHGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.DataViewWidget[DataViewWidget]\n              skeleplex.app.qt.flat_group_box.FlatHGroupBox[FlatHGroupBox]\n\n                              skeleplex.app.qt.flat_group_box.FlatHGroupBox --&gt; skeleplex.app.qt.app_controls.DataViewWidget\n                \n\n\n              click skeleplex.app.qt.app_controls.DataViewWidget href \"\" \"skeleplex.app.qt.app_controls.DataViewWidget\"\n              click skeleplex.app.qt.flat_group_box.FlatHGroupBox href \"\" \"skeleplex.app.qt.flat_group_box.FlatHGroupBox\"\n            </code></pre> <p>A widget for selecting which regions of the data are in view.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, collapsible: bool = False, parent: QWidget | None = None):\n    super().__init__(\n        title=\"Data View\",\n        accent_color=\"#b7e2d8\",\n        collapsible=collapsible,\n        parent=parent,\n    )\n\n    # buttons for the mode\n    self.mode_buttons = QButtonGroup(parent=self)\n    self.all_button = QRadioButton(\"All\", parent=self)\n    self.all_button.setChecked(True)\n    self.bounding_box_button = QRadioButton(\"Bounding box\", parent=self)\n    self.mode_buttons.addButton(self.all_button)\n    self.mode_buttons.addButton(self.bounding_box_button)\n    self.mode_buttons.setExclusive(True)\n    self.button_box = QGroupBox(title=\"View mode\", parent=self)\n    self.button_box.setStyleSheet(GROUP_BOX_STYLE)\n    layout = QVBoxLayout()\n    layout.addWidget(self.all_button)\n    layout.addWidget(self.bounding_box_button)\n    self.button_box.setAutoFillBackground(True)\n    self.button_box.setLayout(layout)\n\n    # Make the view all widget\n    self.view_all_controls = ViewAllModeControls(parent=self)\n\n    # make the view bounding box widget\n    self.view_bounding_box_controls = ViewBoundingBoxControls(parent=self)\n    self.view_bounding_box_controls.setVisible(False)\n\n    # connect the view all event\n    self.view_all_controls.render_requested.connect(self._on_view_requested)\n\n    # connect the view bounding box event\n    self.view_bounding_box_controls.bounding_box_widget.called.connect(\n        self._on_view_requested\n    )\n\n    # connect the mode buttons\n    self.mode_buttons.buttonClicked.connect(self._on_mode_changed)\n\n    # Add the widgets\n    self.add_widget(self.button_box)\n    self.add_widget(self.view_all_controls)\n    self.add_widget(self.view_bounding_box_controls)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataViewWidget.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.DataViewWidget.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.SelectionModeWidget","title":"SelectionModeWidget","text":"<pre><code>SelectionModeWidget(title: str = '', parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.SelectionModeWidget[SelectionModeWidget]\n\n              \n\n              click skeleplex.app.qt.app_controls.SelectionModeWidget href \"\" \"skeleplex.app.qt.app_controls.SelectionModeWidget\"\n            </code></pre> <p>Widget for controlling a selection mode.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, title: str = \"\", parent: QWidget | None = None):\n    super().__init__(title=title, parent=parent)\n\n    self.enable_checkbox = QCheckBox(\"Enable\")\n    self.selection_box = QLineEdit()\n\n    # Make the layout\n    layout = QHBoxLayout()\n    layout.addWidget(self.enable_checkbox)\n    layout.addWidget(self.selection_box)\n    self.setLayout(layout)\n\n    # set the style\n    self.setStyleSheet(GROUP_BOX_STYLE)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.ViewAllModeControls","title":"ViewAllModeControls","text":"<pre><code>ViewAllModeControls(parent=None)\n</code></pre> <p>               Bases: <code>QGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.ViewAllModeControls[ViewAllModeControls]\n\n              \n\n              click skeleplex.app.qt.app_controls.ViewAllModeControls href \"\" \"skeleplex.app.qt.app_controls.ViewAllModeControls\"\n            </code></pre> <p>A widget for controlling the view all mode.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent=None):\n    super().__init__(title=\"View all controls\", parent=parent)\n\n    # button to render the view\n    self.render_button = QPushButton(\"Render\", parent=self)\n\n    # connect the button click event\n    self.render_button.clicked.connect(self._on_render_button_clicked)\n\n    # make the layout\n    layout = QVBoxLayout()\n    layout.addWidget(self.render_button)\n    self.setLayout(layout)\n\n    # set the style\n    self.setStyleSheet(GROUP_BOX_STYLE)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.ViewBoundingBoxControls","title":"ViewBoundingBoxControls","text":"<pre><code>ViewBoundingBoxControls(parent=None)\n</code></pre> <p>               Bases: <code>QGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.app_controls.ViewBoundingBoxControls[ViewBoundingBoxControls]\n\n              \n\n              click skeleplex.app.qt.app_controls.ViewBoundingBoxControls href \"\" \"skeleplex.app.qt.app_controls.ViewBoundingBoxControls\"\n            </code></pre> <p>A widget for controlling the bounding box view mode.</p> <p>Methods:</p> <ul> <li> <code>update_bounding_box</code>             \u2013              <p>Update the bounding box controls with new minimum and maximum values.</p> </li> </ul> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def __init__(self, parent=None):\n    super().__init__(title=\"Bounding box controls\", parent=parent)\n\n    # make widget for setting bounding box\n    self.bounding_box_widget = magicgui(\n        self.update_bounding_box,\n        call_button=\"Render\",\n        minimum={\"options\": {\"max\": sys.float_info.max}},\n        maximum={\"options\": {\"max\": sys.float_info.max}},\n    )\n\n    # make the layout\n    layout = QVBoxLayout()\n    layout.addWidget(self.bounding_box_widget.native)\n    self.setLayout(layout)\n\n    # set the style\n    self.setMaximumWidth(350)\n    self.setStyleSheet(GROUP_BOX_STYLE)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/app_controls/#skeleplex.app.qt.app_controls.ViewBoundingBoxControls.update_bounding_box","title":"update_bounding_box","text":"<pre><code>update_bounding_box(minimum: tuple[float, float, float], maximum: tuple[float, float, float]) -&gt; BoundingBoxViewRequest\n</code></pre> <p>Update the bounding box controls with new minimum and maximum values.</p> Source code in <code>skeleplex/app/qt/app_controls.py</code> <pre><code>def update_bounding_box(\n    self, minimum: tuple[float, float, float], maximum: tuple[float, float, float]\n) -&gt; BoundingBoxViewRequest:\n    \"\"\"Update the bounding box controls with new minimum and maximum values.\"\"\"\n    # This method can be extended to update the bounding box controls\n    # based on the provided minimum and maximum coordinates.\n    # For now, it is a placeholder.\n    return BoundingBoxViewRequest(\n        minimum=np.asarray(minimum), maximum=np.asarray(maximum)\n    )\n</code></pre>"},{"location":"reference/skeleplex/app/qt/auxiliary_views/","title":"auxiliary_views","text":""},{"location":"reference/skeleplex/app/qt/auxiliary_views/#skeleplex.app.qt.auxiliary_views","title":"skeleplex.app.qt.auxiliary_views","text":"<p>Dock widget to hold additional views of the data.</p> <p>Classes:</p> <ul> <li> <code>AuxiliaryViews</code>           \u2013            <p>A dock widget for the auxiliary views.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/auxiliary_views/#skeleplex.app.qt.auxiliary_views.AuxiliaryViews","title":"AuxiliaryViews","text":"<pre><code>AuxiliaryViews(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QDockWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.auxiliary_views.AuxiliaryViews[AuxiliaryViews]\n\n              \n\n              click skeleplex.app.qt.auxiliary_views.AuxiliaryViews href \"\" \"skeleplex.app.qt.auxiliary_views.AuxiliaryViews\"\n            </code></pre> <p>A dock widget for the auxiliary views.</p> <p>This will hold things like a view of slices along a spline.</p> Source code in <code>skeleplex/app/qt/auxiliary_views.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n    self.setStyleSheet(DOCK_WIDGET_STYLE)\n\n    self.label = QLabel(\"I'm the Auxiliary Views\")\n    self.label.setMinimumWidth(self.MINIMUM_WIDTH)\n\n    self.setWidget(self.label)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/","title":"flat_group_box","text":""},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box","title":"skeleplex.app.qt.flat_group_box","text":"<p>A flat-styled group box widget.</p> <p>Classes:</p> <ul> <li> <code>FlatHFrame</code>           \u2013            <p>A flat-styled frame widget with a horizontal layout.</p> </li> <li> <code>FlatHGroupBox</code>           \u2013            <p>A flat-styled group box widget with a horizontal layout.</p> </li> <li> <code>FlatVFrame</code>           \u2013            <p>A flat-styled frame widget with a vertical layout.</p> </li> <li> <code>FlatVGroupBox</code>           \u2013            <p>A flat-styled group box widget with a vertical layout.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame","title":"FlatHFrame","text":"<pre><code>FlatHFrame(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QFrame</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.flat_group_box.FlatHFrame[FlatHFrame]\n\n              \n\n              click skeleplex.app.qt.flat_group_box.FlatHFrame href \"\" \"skeleplex.app.qt.flat_group_box.FlatHFrame\"\n            </code></pre> <p>A flat-styled frame widget with a horizontal layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the frame.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n\n    # set the styling\n    self.setStyleSheet(FLAT_FRAME_STYLE)\n\n    self.setLayout(QHBoxLayout())\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the frame.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the frame.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.layout().addWidget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHFrame.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox","title":"FlatHGroupBox","text":"<pre><code>FlatHGroupBox(title: str = '', accent_color: str = '#b7e2d8', background_color: str = '#f3f3f3', collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.flat_group_box.FlatHGroupBox[FlatHGroupBox]\n\n              \n\n              click skeleplex.app.qt.flat_group_box.FlatHGroupBox href \"\" \"skeleplex.app.qt.flat_group_box.FlatHGroupBox\"\n            </code></pre> <p>A flat-styled group box widget with a horizontal layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(\n    self,\n    title: str = \"\",\n    accent_color: str = \"#b7e2d8\",\n    background_color: str = \"#f3f3f3\",\n    collapsible: bool = False,\n    parent: QWidget | None = None,\n):\n    super().__init__(parent=parent)\n\n    # store the collapsible property\n    self.collapsible = collapsible\n\n    # set the background color\n    self.setStyleSheet(f\"background-color: {background_color};\")\n\n    self.title_widget = QLabel(title, parent=self)\n    self.title_widget.setStyleSheet(\n        FLAT_TITLE_STYLE.format(accent_color=accent_color)\n    )\n\n    # add an callback to toggle the collapsed state when\n    # the title is clicked.\n    self.title_widget.mousePressEvent = self._toggle_collapsed\n\n    self.frame = FlatHFrame(parent=self)\n\n    layout = QVBoxLayout()\n    layout.setSpacing(0)\n    layout.setContentsMargins(0, 0, 0, 0)\n\n    layout.addWidget(self.title_widget)\n    layout.addWidget(self.frame)\n    layout.addStretch()\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the group box. The default is \"\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(accent_color)","title":"<code>accent_color</code>","text":"(<code>str</code>, default:                   <code>'#b7e2d8'</code> )           \u2013            <p>The accent color for the group box. This is used for the title bar and other accents. Color should be a hex string. The default is \"#b7e2d8\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(background_color)","title":"<code>background_color</code>","text":"(<code>str</code>, default:                   <code>'#f3f3f3'</code> )           \u2013            <p>The background color for the group box. Color should be a hex string. The default is \"#f3f3f3\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatHGroupBox.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame","title":"FlatVFrame","text":"<pre><code>FlatVFrame(parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QFrame</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.flat_group_box.FlatVFrame[FlatVFrame]\n\n              \n\n              click skeleplex.app.qt.flat_group_box.FlatVFrame href \"\" \"skeleplex.app.qt.flat_group_box.FlatVFrame\"\n            </code></pre> <p>A flat-styled frame widget with a vertical layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the frame.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(self, parent: QWidget | None = None):\n    super().__init__(parent=parent)\n\n    # set the styling\n    self.setStyleSheet(FLAT_FRAME_STYLE)\n\n    self.setLayout(QVBoxLayout())\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the frame.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the frame.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.layout().addWidget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVFrame.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox","title":"FlatVGroupBox","text":"<pre><code>FlatVGroupBox(title: str = '', accent_color: str = '#b7e2d8', background_color: str = '#f3f3f3', collapsible: bool = False, parent: QWidget | None = None)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.flat_group_box.FlatVGroupBox[FlatVGroupBox]\n\n              \n\n              click skeleplex.app.qt.flat_group_box.FlatVGroupBox href \"\" \"skeleplex.app.qt.flat_group_box.FlatVGroupBox\"\n            </code></pre> <p>A flat-styled group box widget with a vertical layout.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def __init__(\n    self,\n    title: str = \"\",\n    accent_color: str = \"#b7e2d8\",\n    background_color: str = \"#f3f3f3\",\n    collapsible: bool = False,\n    parent: QWidget | None = None,\n):\n    super().__init__(parent=parent)\n\n    # store the collapsible property\n    self.collapsible = collapsible\n\n    # set the background color\n    self.setStyleSheet(f\"background-color: {background_color};\")\n\n    self.title_widget = QLabel(title, parent=self)\n    self.title_widget.setStyleSheet(\n        FLAT_TITLE_STYLE.format(accent_color=accent_color)\n    )\n\n    # add an callback to toggle the collapsed state when\n    # the title is clicked.\n    self.title_widget.mousePressEvent = self._toggle_collapsed\n\n    self.frame = FlatHFrame(parent=self)\n\n    layout = QVBoxLayout()\n    layout.setSpacing(0)\n    layout.setContentsMargins(0, 0, 0, 0)\n\n    layout.addWidget(self.title_widget)\n    layout.addWidget(self.frame)\n    layout.addStretch()\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>The title of the group box. The default is \"\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(accent_color)","title":"<code>accent_color</code>","text":"(<code>str</code>, default:                   <code>'#b7e2d8'</code> )           \u2013            <p>The accent color for the group box. This is used for the title bar and other accents. Color should be a hex string. The default is \"#b7e2d8\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(background_color)","title":"<code>background_color</code>","text":"(<code>str</code>, default:                   <code>'#f3f3f3'</code> )           \u2013            <p>The background color for the group box. Color should be a hex string. The default is \"#f3f3f3\".</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox(parent)","title":"<code>parent</code>","text":"(<code>QWidget | None</code>, default:                   <code>None</code> )           \u2013            <p>The parent widget. The default is None.</p>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/flat_group_box/#skeleplex.app.qt.flat_group_box.FlatVGroupBox.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/main_viewer/","title":"main_viewer","text":""},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer","title":"skeleplex.app.qt.main_viewer","text":"<p>Widgets for the main viewer.</p> <p>Classes:</p> <ul> <li> <code>ImageControls</code>           \u2013            <p>Control UI for the skeleton.</p> </li> <li> <code>MainViewerControls</code>           \u2013            <p>A widget for the main viewer controls.</p> </li> <li> <code>MainViewerFrame</code>           \u2013            <p>A frame for the main viewer canvas.</p> </li> <li> <code>MainViewerWidget</code>           \u2013            <p>A widget for the main viewer.</p> </li> <li> <code>SkeletonControls</code>           \u2013            <p>Control UI for the skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.ImageControls","title":"ImageControls","text":"<pre><code>ImageControls(parent: QWidget)\n</code></pre> <p>               Bases: <code>FlatVGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.main_viewer.ImageControls[ImageControls]\n              skeleplex.app.qt.flat_group_box.FlatVGroupBox[FlatVGroupBox]\n\n                              skeleplex.app.qt.flat_group_box.FlatVGroupBox --&gt; skeleplex.app.qt.main_viewer.ImageControls\n                \n\n\n              click skeleplex.app.qt.main_viewer.ImageControls href \"\" \"skeleplex.app.qt.main_viewer.ImageControls\"\n              click skeleplex.app.qt.flat_group_box.FlatVGroupBox href \"\" \"skeleplex.app.qt.flat_group_box.FlatVGroupBox\"\n            </code></pre> <p>Control UI for the skeleton.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(\n        title=\"Image Appearance\", accent_color=\"#92a8d7\", parent=parent\n    )\n\n    self.add_widget(QLabel(\"test\"))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.ImageControls.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.ImageControls.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerControls","title":"MainViewerControls","text":"<pre><code>MainViewerControls(parent: QWidget)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.main_viewer.MainViewerControls[MainViewerControls]\n\n              \n\n              click skeleplex.app.qt.main_viewer.MainViewerControls href \"\" \"skeleplex.app.qt.main_viewer.MainViewerControls\"\n            </code></pre> <p>A widget for the main viewer controls.</p> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(parent=parent)\n    self.skeleton_controls = SkeletonControls(parent=self)\n    self.image_controls = ImageControls(parent=self)\n\n    # set the maximum height\n    self.setMaximumHeight(100)\n\n    # layout\n    layout = QHBoxLayout()\n    layout.setContentsMargins(0, 0, 0, 0)\n    layout.addWidget(self.image_controls)\n    layout.addWidget(self.skeleton_controls)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerFrame","title":"MainViewerFrame","text":"<pre><code>MainViewerFrame(parent: QWidget)\n</code></pre> <p>               Bases: <code>QFrame</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.main_viewer.MainViewerFrame[MainViewerFrame]\n\n              \n\n              click skeleplex.app.qt.main_viewer.MainViewerFrame href \"\" \"skeleplex.app.qt.main_viewer.MainViewerFrame\"\n            </code></pre> <p>A frame for the main viewer canvas.</p> <p>Methods:</p> <ul> <li> <code>addCanvasWidget</code>             \u2013              <p>Add a canvas widget to the frame.</p> </li> </ul> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(parent=parent)\n\n    self.setStyleSheet(\"border: 1px solid black;\")\n\n    # set the minimum height\n    self.setMinimumHeight(self.MINIMUM_HEIGHT)\n\n    layout = QVBoxLayout()\n    layout.setContentsMargins(0, 0, 0, 0)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerFrame.addCanvasWidget","title":"addCanvasWidget","text":"<pre><code>addCanvasWidget(widget: QWidget)\n</code></pre> <p>Add a canvas widget to the frame.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def addCanvasWidget(self, widget: QWidget):\n    \"\"\"Add a canvas widget to the frame.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add to the frame.\n    \"\"\"\n    self.layout().addWidget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerFrame.addCanvasWidget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add to the frame.</p>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerWidget","title":"MainViewerWidget","text":"<pre><code>MainViewerWidget(parent: QWidget)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.main_viewer.MainViewerWidget[MainViewerWidget]\n\n              \n\n              click skeleplex.app.qt.main_viewer.MainViewerWidget href \"\" \"skeleplex.app.qt.main_viewer.MainViewerWidget\"\n            </code></pre> <p>A widget for the main viewer.</p> <p>Methods:</p> <ul> <li> <code>addCanvasWidget</code>             \u2013              <p>Add a canvas widget to the main viewer frame.</p> </li> </ul> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(parent=parent)\n    self.main_viewer_frame = MainViewerFrame(parent=self)\n    self.main_viewer_controls = MainViewerControls(parent=self)\n\n    layout = QVBoxLayout()\n    layout.setContentsMargins(10, 5, 10, 0)\n    layout.addWidget(self.main_viewer_frame)\n    layout.addWidget(self.main_viewer_controls)\n    self.setLayout(layout)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerWidget.addCanvasWidget","title":"addCanvasWidget","text":"<pre><code>addCanvasWidget(widget: QWidget)\n</code></pre> <p>Add a canvas widget to the main viewer frame.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def addCanvasWidget(self, widget: QWidget):\n    \"\"\"Add a canvas widget to the main viewer frame.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add to the main viewer frame.\n    \"\"\"\n    self.main_viewer_frame.addCanvasWidget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.MainViewerWidget.addCanvasWidget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add to the main viewer frame.</p>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.SkeletonControls","title":"SkeletonControls","text":"<pre><code>SkeletonControls(parent: QWidget)\n</code></pre> <p>               Bases: <code>FlatVGroupBox</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.main_viewer.SkeletonControls[SkeletonControls]\n              skeleplex.app.qt.flat_group_box.FlatVGroupBox[FlatVGroupBox]\n\n                              skeleplex.app.qt.flat_group_box.FlatVGroupBox --&gt; skeleplex.app.qt.main_viewer.SkeletonControls\n                \n\n\n              click skeleplex.app.qt.main_viewer.SkeletonControls href \"\" \"skeleplex.app.qt.main_viewer.SkeletonControls\"\n              click skeleplex.app.qt.flat_group_box.FlatVGroupBox href \"\" \"skeleplex.app.qt.flat_group_box.FlatVGroupBox\"\n            </code></pre> <p>Control UI for the skeleton.</p> <p>Methods:</p> <ul> <li> <code>add_widget</code>             \u2013              <p>Add a widget to the group box.</p> </li> </ul> Source code in <code>skeleplex/app/qt/main_viewer.py</code> <pre><code>def __init__(self, parent: QWidget):\n    super().__init__(\n        title=\"Skeleton Appearance\", accent_color=\"#92a8d7\", parent=parent\n    )\n\n    self.add_widget(QLabel(\"test\"))\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.SkeletonControls.add_widget","title":"add_widget","text":"<pre><code>add_widget(widget: QWidget)\n</code></pre> <p>Add a widget to the group box.</p> <p>Parameters:</p> Source code in <code>skeleplex/app/qt/flat_group_box.py</code> <pre><code>def add_widget(self, widget: QWidget):\n    \"\"\"Add a widget to the group box.\n\n    Parameters\n    ----------\n    widget : QWidget\n        The widget to add.\n    \"\"\"\n    self.frame.add_widget(widget)\n</code></pre>"},{"location":"reference/skeleplex/app/qt/main_viewer/#skeleplex.app.qt.main_viewer.SkeletonControls.add_widget(widget)","title":"<code>widget</code>","text":"(<code>QWidget</code>)           \u2013            <p>The widget to add.</p>"},{"location":"reference/skeleplex/app/qt/styles/","title":"styles","text":""},{"location":"reference/skeleplex/app/qt/styles/#skeleplex.app.qt.styles","title":"skeleplex.app.qt.styles","text":"<p>QSS styles for the application.</p>"},{"location":"reference/skeleplex/app/qt/window/","title":"window","text":""},{"location":"reference/skeleplex/app/qt/window/#skeleplex.app.qt.window","title":"skeleplex.app.qt.window","text":"<p>Qt implementation of the main window for the application.</p> <p>Classes:</p> <ul> <li> <code>MainWindow</code>           \u2013            <p>Qt + app-model implementation of the main window for the application.</p> </li> </ul>"},{"location":"reference/skeleplex/app/qt/window/#skeleplex.app.qt.window.MainWindow","title":"MainWindow","text":"<pre><code>MainWindow(app: Application)\n</code></pre> <p>               Bases: <code>QModelMainWindow</code></p> <pre><code>\n              flowchart TD\n              skeleplex.app.qt.window.MainWindow[MainWindow]\n\n              \n\n              click skeleplex.app.qt.window.MainWindow href \"\" \"skeleplex.app.qt.window.MainWindow\"\n            </code></pre> <p>Qt + app-model implementation of the main window for the application.</p> <p>Methods:</p> <ul> <li> <code>add_auxiliary_widget</code>             \u2013              <p>Add a widget to the auxiliary views dock.</p> </li> </ul> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def __init__(self, app: Application):\n    super().__init__(app)\n\n    # set the background color\n    self.setStyleSheet(MAIN_WINDOW_STYLE)\n\n    # self.tool_bar = self.addModelToolBar(MenuId.FILE, exclude={CommandId.OPEN})\n    # self.tool_bar.setStyleSheet(\"background: white;\")\n\n    self._main_viewer_widget = MainViewerWidget(parent=self)\n    self.setCentralWidget(self._main_viewer_widget)\n\n    # set the minimum window size - app will launch with this size.\n    self.setMinimumSize(MIN_WINDOW_WIDTH, MIN_WINDOW_HEIGHT)\n\n    # Create the app controls as a dock widget (left)\n    self._create_app_controls()\n\n    # create the auxiliary views as a dock widget (right)\n    self._create_auxiliary_views()\n\n    # create the status bar at the bottom of the window\n    self._create_status_bar()\n</code></pre>"},{"location":"reference/skeleplex/app/qt/window/#skeleplex.app.qt.window.MainWindow.add_auxiliary_widget","title":"add_auxiliary_widget","text":"<pre><code>add_auxiliary_widget(widget: QWidget, name: str = '')\n</code></pre> <p>Add a widget to the auxiliary views dock.</p> Source code in <code>skeleplex/app/qt/window.py</code> <pre><code>def add_auxiliary_widget(self, widget: QWidget, name: str = \"\"):\n    \"\"\"Add a widget to the auxiliary views dock.\"\"\"\n    dock_widget = QDockWidget(name)\n    dock_widget.setWidget(widget)\n    self.addDockWidget(Qt.DockWidgetArea.RightDockWidgetArea, dock_widget)\n</code></pre>"},{"location":"reference/skeleplex/data/","title":"data","text":""},{"location":"reference/skeleplex/data/#skeleplex.data","title":"skeleplex.data","text":"<p>Example data.</p> <p>Modules:</p> <ul> <li> <code>bifurcating_tree</code>           \u2013            <p>Creating biforcating trees as example data.</p> </li> <li> <code>fractal_trees</code>           \u2013            </li> <li> <code>skeleton_image</code>           \u2013            <p>Example skeleton images.</p> </li> <li> <code>skeletons</code>           \u2013            </li> <li> <code>tubes</code>           \u2013            <p>Drawing tubes in a volume as example data.</p> </li> <li> <code>utils</code>           \u2013            </li> <li> <code>y_junctions</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>big_t</code>             \u2013              <p>Make an image with a big T skeleton.</p> </li> <li> <code>simple_t</code>             \u2013              <p>Make an image with a simple T skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/data/#skeleplex.data.big_t","title":"big_t","text":"<pre><code>big_t() -&gt; ndarray\n</code></pre> <p>Make an image with a big T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a big T skeleton. The image has shape (100, 100, 100)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def big_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a big T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a big T skeleton.\n        The image has shape (100, 100, 100)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(50, 25), (50, 50)],\n        [(50, 50), (50, 75)],\n        [(50, 50), (75, 50)],\n    ]\n\n    # draw the image\n    image = np.zeros((100, 100, 100), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[50, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/#skeleplex.data.simple_t","title":"simple_t","text":"<pre><code>simple_t() -&gt; ndarray\n</code></pre> <p>Make an image with a simple T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a simple T skeleton. The image has shape (20, 20, 20)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def simple_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a simple T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a simple T skeleton.\n        The image has shape (20, 20, 20)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(10, 5), (10, 10)],\n        [(10, 10), (10, 15)],\n        [(10, 10), (15, 10)],\n    ]\n\n    # draw the image\n    image = np.zeros((20, 20, 20), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[10, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/","title":"bifurcating_tree","text":""},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree","title":"skeleplex.data.bifurcating_tree","text":"<p>Creating biforcating trees as example data.</p> <p>Functions:</p> <ul> <li> <code>apply_dilation_3d</code>             \u2013              <p>Apply morphological dilation to thicken the tree structure in 3D.</p> </li> <li> <code>draw_branch_2d</code>             \u2013              <p>Adds branches to a bifurcating tree in a single 2D layer.</p> </li> <li> <code>generate_tree_3d</code>             \u2013              <p>Generate a 3D bifurcating tree in a specified z-layer of a 3D image.</p> </li> </ul>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.apply_dilation_3d","title":"apply_dilation_3d","text":"<pre><code>apply_dilation_3d(image, dilation_radius=3)\n</code></pre> <p>Apply morphological dilation to thicken the tree structure in 3D.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A dilated version of the input tree image.</p> </li> </ul> Source code in <code>skeleplex/data/bifurcating_tree.py</code> <pre><code>def apply_dilation_3d(image, dilation_radius=3):\n    \"\"\"\n    Apply morphological dilation to thicken the tree structure in 3D.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        A binary 3D image containing the tree structure.\n    dilation_radius : int, optional\n        The radius of the structuring element for dilation, by default 3.\n\n    Returns\n    -------\n    np.ndarray\n        A dilated version of the input tree image.\n    \"\"\"\n    structuring_element = ball(dilation_radius)\n    dilated_image = binary_dilation(image, structure=structuring_element)\n\n    return dilated_image\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.apply_dilation_3d(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>A binary 3D image containing the tree structure.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.apply_dilation_3d(dilation_radius)","title":"<code>dilation_radius</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The radius of the structuring element for dilation, by default 3.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d","title":"draw_branch_2d","text":"<pre><code>draw_branch_2d(image, start, length, angle, level, max_levels, z_layer=10, left_angle=30, right_angle=30, length_ratio=0.7)\n</code></pre> <p>Adds branches to a bifurcating tree in a single 2D layer.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>Modifies the input image in place.</p> </li> </ul> Source code in <code>skeleplex/data/bifurcating_tree.py</code> <pre><code>def draw_branch_2d(\n    image,\n    start,\n    length,\n    angle,\n    level,\n    max_levels,\n    z_layer=10,\n    left_angle=30,\n    right_angle=30,\n    length_ratio=0.7,\n):\n    \"\"\"\n    Adds branches to a bifurcating tree in a single 2D layer.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The 3D binary image where the tree is drawn.\n    start : tuple[int, int]\n        The (y, x) starting position of the branch.\n    length : int\n        The length of the current branch.\n    angle : float\n        The angle (in degrees) at which the branch grows.\n    level : int\n        The current recursion depth (bifurcation level).\n    max_levels : int\n        The maximum number of bifurcation levels.\n    z_layer : int, optional\n        The z-plane in which the tree is drawn, by default 10.\n    left_angle : float, optional\n        The angle offset for left branches, by default 30 degrees.\n    right_angle : float, optional\n        The angle offset for right branches, by default 30 degrees.\n    length_ratio : float, optional\n        The ratio by which branch length decreases in each bifurcation, by default 0.7.\n\n    Returns\n    -------\n    None\n        Modifies the input image in place.\n    \"\"\"\n    if level &gt; max_levels or length &lt;= 0:\n        return\n\n    # Calculate the end point of the branch\n    y_end = start[0] + int(length * np.cos(np.radians(angle)))\n    x_end = start[1] + int(length * np.sin(np.radians(angle)))\n\n    # Clip endpoints to stay within the image bounds\n    y_end = np.clip(y_end, 0, image.shape[1] - 1)\n    x_end = np.clip(x_end, 0, image.shape[2] - 1)\n\n    # Draw the branch in the specific z-layer\n    rr, cc = line(start[0], start[1], y_end, x_end)\n    image[z_layer, rr, cc] = 1\n\n    # New starting point for daughter branches\n    new_start = (y_end, x_end)\n\n    # Add left and right daughter branches\n    draw_branch_2d(\n        image,\n        new_start,\n        int(length * length_ratio),\n        angle - left_angle,\n        level + 1,\n        max_levels,\n        z_layer,\n        left_angle,\n        right_angle,\n        length_ratio,\n    )  # Left branch\n\n    draw_branch_2d(\n        image,\n        new_start,\n        int(length * length_ratio),\n        angle + right_angle,\n        level + 1,\n        max_levels,\n        z_layer,\n        left_angle,\n        right_angle,\n        length_ratio,\n    )  # Right branch\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The 3D binary image where the tree is drawn.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(start)","title":"<code>start</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The (y, x) starting position of the branch.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(length)","title":"<code>length</code>","text":"(<code>int</code>)           \u2013            <p>The length of the current branch.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(angle)","title":"<code>angle</code>","text":"(<code>float</code>)           \u2013            <p>The angle (in degrees) at which the branch grows.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(level)","title":"<code>level</code>","text":"(<code>int</code>)           \u2013            <p>The current recursion depth (bifurcation level).</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(max_levels)","title":"<code>max_levels</code>","text":"(<code>int</code>)           \u2013            <p>The maximum number of bifurcation levels.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(z_layer)","title":"<code>z_layer</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The z-plane in which the tree is drawn, by default 10.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(left_angle)","title":"<code>left_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for left branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(right_angle)","title":"<code>right_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for right branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.draw_branch_2d(length_ratio)","title":"<code>length_ratio</code>","text":"(<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>The ratio by which branch length decreases in each bifurcation, by default 0.7.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d","title":"generate_tree_3d","text":"<pre><code>generate_tree_3d(shape=(100, 100, 100), num_bifurcations=1, branch_length=20, z_layer=10, left_angle=30, right_angle=30, length_ratio=0.7)\n</code></pre> <p>Generate a 3D bifurcating tree in a specified z-layer of a 3D image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 3D binary image with the generated tree structure.</p> </li> </ul> Source code in <code>skeleplex/data/bifurcating_tree.py</code> <pre><code>def generate_tree_3d(\n    shape=(100, 100, 100),\n    num_bifurcations=1,\n    branch_length=20,\n    z_layer=10,\n    left_angle=30,\n    right_angle=30,\n    length_ratio=0.7,\n):\n    \"\"\"\n    Generate a 3D bifurcating tree in a specified z-layer of a 3D image.\n\n    Parameters\n    ----------\n    shape : tuple[int, int, int], optional\n        The dimensions of the 3D image, by default (100, 100, 100).\n    num_bifurcations : int, optional\n        The number of bifurcation levels, by default 1.\n    branch_length : int, optional\n        The length of the initial trunk, by default 20.\n    z_layer : int, optional\n        The specific z-plane where the tree is generated, by default 10.\n    left_angle : float, optional\n        The angle offset for left branches, by default 30 degrees.\n    right_angle : float, optional\n        The angle offset for right branches, by default 30 degrees.\n    length_ratio : float, optional\n        The ratio by which branch length decreases per bifurcation, by default 0.7.\n\n    Returns\n    -------\n    np.ndarray\n        A 3D binary image with the generated tree structure.\n    \"\"\"\n    # Create an empty black 3D image\n    image = np.zeros(shape, dtype=bool)\n\n    # Starting point of the tree (top center of the chosen z-layer)\n    # with a border of 20 pixels\n    start = (20, shape[1] // 2)\n\n    # Add the main trunk growing downward in the specified z-layer\n    draw_branch_2d(\n        image,\n        start,\n        branch_length,\n        angle=0,\n        level=0,\n        max_levels=num_bifurcations,\n        z_layer=z_layer,\n        left_angle=left_angle,\n        right_angle=right_angle,\n        length_ratio=length_ratio,\n    )\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(shape)","title":"<code>shape</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(100, 100, 100)</code> )           \u2013            <p>The dimensions of the 3D image, by default (100, 100, 100).</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(num_bifurcations)","title":"<code>num_bifurcations</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of bifurcation levels, by default 1.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(branch_length)","title":"<code>branch_length</code>","text":"(<code>int</code>, default:                   <code>20</code> )           \u2013            <p>The length of the initial trunk, by default 20.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(z_layer)","title":"<code>z_layer</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The specific z-plane where the tree is generated, by default 10.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(left_angle)","title":"<code>left_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for left branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(right_angle)","title":"<code>right_angle</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>The angle offset for right branches, by default 30 degrees.</p>"},{"location":"reference/skeleplex/data/bifurcating_tree/#skeleplex.data.bifurcating_tree.generate_tree_3d(length_ratio)","title":"<code>length_ratio</code>","text":"(<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>The ratio by which branch length decreases per bifurcation, by default 0.7.</p>"},{"location":"reference/skeleplex/data/fractal_trees/","title":"fractal_trees","text":""},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees","title":"skeleplex.data.fractal_trees","text":"<p>Functions:</p> <ul> <li> <code>compute_distance_between_edge_nodes</code>             \u2013              <p>Compute the distance between the start and end nodes of each edge in the graph.</p> </li> <li> <code>generate_random_parameters_for_fractal_tree</code>             \u2013              <p>Generate random parameters for fractal tree generation.</p> </li> <li> <code>generate_synthetic_fractal_tree</code>             \u2013              <p>Generate a fractal tree structure in a 3D skeleton image.</p> </li> </ul>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.compute_distance_between_edge_nodes","title":"compute_distance_between_edge_nodes","text":"<pre><code>compute_distance_between_edge_nodes(graph: DiGraph)\n</code></pre> <p>Compute the distance between the start and end nodes of each edge in the graph.</p> <p>For the toy graph, this is the length of the edge.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with edge lengths annotated.</p> </li> </ul> Source code in <code>skeleplex/data/fractal_trees.py</code> <pre><code>def compute_distance_between_edge_nodes(\n    graph: nx.DiGraph,\n):\n    \"\"\"Compute the distance between the start and end nodes of each edge in the graph.\n\n    For the toy graph, this is the length of the edge.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with edge lengths annotated.\n    \"\"\"\n    distances = {}\n    for edge in graph.edges():\n        start, end = edge\n        start_pos = graph.nodes[start][NODE_COORDINATE_KEY]\n        end_pos = graph.nodes[end][NODE_COORDINATE_KEY]\n        distance = np.linalg.norm(end_pos - start_pos)\n        distances[edge] = distance\n\n    nx.set_edge_attributes(graph, distances, LENGTH_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.compute_distance_between_edge_nodes(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_random_parameters_for_fractal_tree","title":"generate_random_parameters_for_fractal_tree","text":"<pre><code>generate_random_parameters_for_fractal_tree(num_nodes_range: tuple[int, int] = (15, 33), edge_length_factor: tuple[int, int] = (4, 7), branch_angle_range: tuple[float, float] = (30, 90), wiggle_factor_range: tuple[float, float] = (0.01, 0.03), noise_magnitude_range: tuple[float, float] = (5, 15), ellipse_ratio_range: tuple[float, float] = (1.1, 1.5), dilation_size: int = 3, tip_dilation_size: float = (1.05, 1.2), use_gpu=True, seed: int = 42, inplane_rotation: float | None = (-20, 20), outplane_rotation: list[float, float, float] | None = None)\n</code></pre> <p>Generate random parameters for fractal tree generation.</p> Source code in <code>skeleplex/data/fractal_trees.py</code> <pre><code>def generate_random_parameters_for_fractal_tree(\n    num_nodes_range: tuple[int, int] = (15, 33),\n    edge_length_factor: tuple[int, int] = (4, 7),\n    branch_angle_range: tuple[float, float] = (30, 90),\n    wiggle_factor_range: tuple[float, float] = (0.01, 0.03),\n    noise_magnitude_range: tuple[float, float] = (5, 15),\n    ellipse_ratio_range: tuple[float, float] = (1.1, 1.5),\n    dilation_size: int = 3,\n    tip_dilation_size: float = (1.05, 1.2),\n    use_gpu=True,\n    seed: int = 42,\n    inplane_rotation: float | None = (-20, 20),\n    outplane_rotation: list[float, float, float] | None = None,\n):\n    \"\"\"Generate random parameters for fractal tree generation.\"\"\"\n    seed_gen = np.random.default_rng(seed)\n    num_nodes = seed_gen.choice(np.arange(*num_nodes_range, 2))\n    edge_length = num_nodes * seed_gen.integers(*edge_length_factor)\n    branch_angle = seed_gen.uniform(*branch_angle_range)\n    wiggle_factor = seed_gen.uniform(*wiggle_factor_range)\n    noise_magnitude = seed_gen.uniform(*noise_magnitude_range)\n    ellipse_ratio = (\n        seed_gen.uniform(*ellipse_ratio_range) if seed_gen.random() &gt; 0.5 else None\n    )\n    tip_dilation_size = seed_gen.uniform(*tip_dilation_size)\n    if inplane_rotation is not None:\n        inplane_rotation = seed_gen.uniform(*inplane_rotation)\n    if outplane_rotation is not None:\n        outplane_rotation = [\n            seed_gen.uniform(*outplane_rotation[0]),\n            seed_gen.uniform(*outplane_rotation[1]),\n            seed_gen.uniform(*outplane_rotation[2]),\n        ]\n    return (\n        num_nodes,\n        edge_length,\n        branch_angle,\n        wiggle_factor,\n        noise_magnitude,\n        dilation_size,\n        tip_dilation_size,\n        ellipse_ratio,\n        use_gpu,\n        seed,\n        inplane_rotation,\n        outplane_rotation,\n    )\n</code></pre>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree","title":"generate_synthetic_fractal_tree","text":"<pre><code>generate_synthetic_fractal_tree(num_nodes: int = 19, edge_length: int = 100, branch_angle: float = 45, wiggle_factor: float = 0.01, noise_magnitude: float = 5, dilation_size: int = 3, tip_dilation_size: int = 1.05, ellipse_ratio: float | None = None, use_gpu: bool = True, seed: int = 42, inplane_rotation: float | None = None, outplane_rotation: list[float, float, float] | None = None)\n</code></pre> <p>Generate a fractal tree structure in a 3D skeleton image.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/fractal_trees.py</code> <pre><code>def generate_synthetic_fractal_tree(\n    num_nodes: int = 19,\n    edge_length: int = 100,\n    branch_angle: float = 45,\n    wiggle_factor: float = 0.01,\n    noise_magnitude: float = 5,\n    dilation_size: int = 3,\n    tip_dilation_size: int = 1.05,\n    ellipse_ratio: float | None = None,\n    use_gpu: bool = True,\n    seed: int = 42,\n    inplane_rotation: float | None = None,\n    outplane_rotation: list[float, float, float] | None = None,\n):\n    \"\"\"Generate a fractal tree structure in a 3D skeleton image.\n\n    Parameters\n    ----------\n    num_nodes : int\n        Number of nodes in the tree.\n    edge_length : int\n        Total length of the initial tree edge.\n        Following generations will shrink by a factor of 0.8.\n        See `generate_toy_graph_symmetric_branch_angle` for details.\n    branch_angle : float\n        Angle between branches in degrees.\n    wiggle_factor : float, optional\n        Factor to control the amount of wiggle in the branches.\n        Default is 0.01.\n    noise_magnitude : float, optional\n        Magnitude of noise to add to the surface of the branches.\n        Default is 5.\n    dilation_size : int, optional\n        Size of the dilation applied to the skeleton image.\n        Default is 3.\n    tip_dilation_size : float, optional\n        Factor to control the size of the dilation applied to the tips of the branches.\n        Default is 1.05.\n    ellipse_ratio : float, optional\n        Ratio of the radii of the elliptic cylinder segments.\n        If None, the branches will be cylindrical.\n        Default is None.\n    use_gpu : bool, optional\n        Whether to use GPU acceleration for distance transform computation.\n        Default is True.\n    seed : int, optional\n        Seed for random number generation.\n        Default is 42.\n    inplane_rotation : float | None, optional\n        If provided, the in-plane rotation angle in degrees to apply to the tree.\n        If None, a random angle between -90 and 90 degrees will be used.\n    outplane_rotation : list[float, float, float] | None, optional\n        If provided, the rotation angles in degrees to apply to the tree.\n        If None, random angles between -30 and 30 degrees for each axis will be used\n    \"\"\"\n    seed_gen = np.random.default_rng(seed)\n    # build tree\n    g = generate_toy_graph_symmetric_branch_angle(\n        num_nodes=num_nodes, angle=branch_angle, edge_length=edge_length\n    )\n    g.graph = compute_level(g.graph, origin=-1)\n    g.graph = compute_branch_length(g.graph)\n    augment_tree(g.graph, rotation_angles=outplane_rotation)\n    add_rotation_to_tree(g.graph, rotation_angle=inplane_rotation)\n\n    g.graph = compute_distance_between_edge_nodes(g.graph)\n    pos = nx.get_node_attributes(g.graph, NODE_COORDINATE_KEY)\n\n    # build images\n    pos_values = np.array(list(pos.values()))\n    x_shift = np.abs(np.min(pos_values[:, 0])) + 20\n    y_shift = np.abs(np.min(pos_values[:, 1])) + 30\n    z_shift = np.abs(np.min(pos_values[:, 2])) + 20\n    for node in g.graph.nodes():\n        p = g.graph.nodes[node][NODE_COORDINATE_KEY]\n        p = p + np.array([x_shift, y_shift, z_shift])\n        g.graph.nodes[node][NODE_COORDINATE_KEY] = p\n\n    pos = np.asarray(list(dict(g.nodes(data=NODE_COORDINATE_KEY)).values()))\n\n    lengths = np.asarray([g.graph.edges[edge][LENGTH_KEY] for edge in g.graph.edges()])\n    radii = lengths / 3.2\n    pad_size = 2 * np.max(radii) + 10\n    # Calculate the dimensions of the skeleton image\n    x_offset = 0\n    y_offset = 0\n    z_offset = 0\n\n    x_coord = int(np.ceil(np.max(pos[:, 0]) - x_offset))\n    y_coord = int(np.ceil(np.max(pos[:, 1]) - y_offset))\n    z_coord = int(np.ceil(np.max(pos[:, 2]) - z_offset))\n\n    skeleton_img = np.pad(\n        np.zeros((x_coord, y_coord, z_coord), dtype=np.uint8), pad_width=int(pad_size)\n    )\n    branch_img = skeleton_img.copy()\n    pos_dict = nx.get_node_attributes(g.graph, NODE_COORDINATE_KEY)\n\n    # Fill in the structures\n    axis = seed_gen.integers(0, 3)  # Randomly choose an axis for wiggle\n    for i, (u, v) in enumerate(g.graph.edges()):\n        a = pos_dict[u]\n        b = pos_dict[v]\n        radius = radii[i]\n        if not ellipse_ratio:\n            draw_wiggly_cylinder_3d(\n                branch_img,\n                start_point=a,\n                end_point=b,\n                radius=int(radius),\n                wiggle_factor=wiggle_factor,\n                axis=axis,\n            )\n        else:\n            # Draw an elliptic cylinder segment\n            draw_elliptic_cylinder_segment(\n                branch_img, a=a, b=b, rx=radius, ry=radius / ellipse_ratio\n            )\n        draw_line_segment_wiggle(\n            start_point=a,\n            end_point=b,\n            skeleton_image=skeleton_img,\n            fill_value=1,\n            wiggle_factor=wiggle_factor,\n            axis=axis,\n        )\n    # Dilute the tips\n    length_dict = nx.get_edge_attributes(g.graph, LENGTH_KEY)\n    for node, _ in g.graph.degree():\n        # Get the position of the node\n        pos = pos_dict[node]\n        if node == -1:\n            edge = next(iter(list(g.graph.edges(node))))\n        else:\n            edge = next(iter(list(g.graph.in_edges(node))))\n        length = length_dict[edge]\n        radius = length / 3\n        # Dilute the tip by drawing a small cylinder\n        draw_ellipsoid_at_point(\n            branch_img,\n            pos,\n            radii=(\n                radius * tip_dilation_size,\n                radius * tip_dilation_size,\n                radius * tip_dilation_size,\n            ),\n        )\n\n    # Add noise to the branch image\n    branch_img = add_noise_to_image_surface(branch_img, noise_magnitude=noise_magnitude)\n    # Crop to content\n    branch_img, skeleton_img = crop_to_content(branch_img, skeleton_img)\n    # Compute the distance field\n    branch_img_dask = da.from_array(branch_img, chunks=(200, 200, 200))\n    depth = np.min([*list(branch_img_dask.shape), 30])\n\n    if use_gpu:\n        distance_field = branch_img_dask.map_overlap(\n            local_normalized_distance_gpu, max_ball_radius=30, depth=depth\n        ).compute()\n    else:\n        distance_field = branch_img_dask.map_overlap(\n            local_normalized_distance, max_ball_radius=30, depth=depth\n        ).compute()\n\n    # Create the skeletonization target\n    skel_target = make_skeleton_blur_image(\n        skeleton_img, dilation_size=dilation_size, gaussian_size=1.5\n    )\n    skel_target = skel_target &gt; 0.7\n    skel_target = skel_target.astype(int)\n    skel_target += branch_img\n\n    return skel_target, distance_field\n</code></pre>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(num_nodes)","title":"<code>num_nodes</code>","text":"(<code>int</code>, default:                   <code>19</code> )           \u2013            <p>Number of nodes in the tree.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(edge_length)","title":"<code>edge_length</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>Total length of the initial tree edge. Following generations will shrink by a factor of 0.8. See <code>generate_toy_graph_symmetric_branch_angle</code> for details.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(branch_angle)","title":"<code>branch_angle</code>","text":"(<code>float</code>, default:                   <code>45</code> )           \u2013            <p>Angle between branches in degrees.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(wiggle_factor)","title":"<code>wiggle_factor</code>","text":"(<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Factor to control the amount of wiggle in the branches. Default is 0.01.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(noise_magnitude)","title":"<code>noise_magnitude</code>","text":"(<code>float</code>, default:                   <code>5</code> )           \u2013            <p>Magnitude of noise to add to the surface of the branches. Default is 5.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(dilation_size)","title":"<code>dilation_size</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Size of the dilation applied to the skeleton image. Default is 3.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(tip_dilation_size)","title":"<code>tip_dilation_size</code>","text":"(<code>float</code>, default:                   <code>1.05</code> )           \u2013            <p>Factor to control the size of the dilation applied to the tips of the branches. Default is 1.05.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(ellipse_ratio)","title":"<code>ellipse_ratio</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Ratio of the radii of the elliptic cylinder segments. If None, the branches will be cylindrical. Default is None.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use GPU acceleration for distance transform computation. Default is True.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(seed)","title":"<code>seed</code>","text":"(<code>int</code>, default:                   <code>42</code> )           \u2013            <p>Seed for random number generation. Default is 42.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(inplane_rotation)","title":"<code>inplane_rotation</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the in-plane rotation angle in degrees to apply to the tree. If None, a random angle between -90 and 90 degrees will be used.</p>"},{"location":"reference/skeleplex/data/fractal_trees/#skeleplex.data.fractal_trees.generate_synthetic_fractal_tree(outplane_rotation)","title":"<code>outplane_rotation</code>","text":"(<code>list[float, float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the rotation angles in degrees to apply to the tree. If None, random angles between -30 and 30 degrees for each axis will be used</p>"},{"location":"reference/skeleplex/data/skeleton_image/","title":"skeleton_image","text":""},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image","title":"skeleplex.data.skeleton_image","text":"<p>Example skeleton images.</p> <p>Functions:</p> <ul> <li> <code>big_t</code>             \u2013              <p>Make an image with a big T skeleton.</p> </li> <li> <code>simple_bifurcating_branches</code>             \u2013              <p>Create a skeleton image with a simple bifurcating tree.</p> </li> <li> <code>simple_t</code>             \u2013              <p>Make an image with a simple T skeleton.</p> </li> </ul>"},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image.big_t","title":"big_t","text":"<pre><code>big_t() -&gt; ndarray\n</code></pre> <p>Make an image with a big T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a big T skeleton. The image has shape (100, 100, 100)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def big_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a big T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a big T skeleton.\n        The image has shape (100, 100, 100)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(50, 25), (50, 50)],\n        [(50, 50), (50, 75)],\n        [(50, 50), (75, 50)],\n    ]\n\n    # draw the image\n    image = np.zeros((100, 100, 100), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[50, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image.simple_bifurcating_branches","title":"simple_bifurcating_branches","text":"<pre><code>simple_bifurcating_branches() -&gt; ndarray\n</code></pre> <p>Create a skeleton image with a simple bifurcating tree.</p> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def simple_bifurcating_branches() -&gt; np.ndarray:\n    \"\"\"Create a skeleton image with a simple bifurcating tree.\"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(20, 100), (40, 100)],\n        [(40, 100), (60, 80)],\n        [(40, 100), (60, 120)],\n        [(60, 80), (75, 65)],\n        [(60, 80), (75, 95)],\n        [(60, 120), (75, 105)],\n        [(60, 120), (75, 135)],\n    ]\n\n    # draw the image\n    image = np.zeros((200, 200, 200), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[100, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/skeleton_image/#skeleplex.data.skeleton_image.simple_t","title":"simple_t","text":"<pre><code>simple_t() -&gt; ndarray\n</code></pre> <p>Make an image with a simple T skeleton.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A binary image with a simple T skeleton. The image has shape (20, 20, 20)</p> </li> </ul> Source code in <code>skeleplex/data/skeleton_image.py</code> <pre><code>def simple_t() -&gt; np.ndarray:\n    \"\"\"Make an image with a simple T skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        A binary image with a simple T skeleton.\n        The image has shape (20, 20, 20)\n    \"\"\"\n    # node coordinates for each branch\n    branch_coordinates = [\n        [(10, 5), (10, 10)],\n        [(10, 10), (10, 15)],\n        [(10, 10), (15, 10)],\n    ]\n\n    # draw the image\n    image = np.zeros((20, 20, 20), dtype=bool)\n\n    for branch in branch_coordinates:\n        rr, cc = line(*branch[0], *branch[1])\n        image[10, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/skeletons/","title":"skeletons","text":""},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons","title":"skeleplex.data.skeletons","text":"<p>Functions:</p> <ul> <li> <code>generate_toy_skeleton_graph_symmetric_branch_angle</code>             \u2013              <p>Generate a toy skeleton graph with a symmetric branch angle.</p> </li> </ul>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle","title":"generate_toy_skeleton_graph_symmetric_branch_angle","text":"<pre><code>generate_toy_skeleton_graph_symmetric_branch_angle(num_nodes: int = 19, angle: int = 72, edge_length: float = 20) -&gt; SkeletonGraph\n</code></pre> <p>Generate a toy skeleton graph with a symmetric branch angle.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/skeletons.py</code> <pre><code>def generate_toy_skeleton_graph_symmetric_branch_angle(\n    num_nodes: int = 19, angle: int = 72, edge_length: float = 20\n) -&gt; SkeletonGraph:\n    \"\"\"Generate a toy skeleton graph with a symmetric branch angle.\n\n    Parameters\n    ----------\n    num_nodes : int\n        The number of nodes in the graph.\n    angle : int\n        The angle between branches in degrees.\n    edge_length : float\n        The length of each edge in the graph.\n\n    \"\"\"\n    # Create a directed graph\n    graph = nx.DiGraph()\n\n    # Convert angle to radians and divide by 2 for symmetric branching\n    angle_rad = np.radians(angle / 2)\n\n    # Initialize node positions dictionary with the root node at the origin\n    node_pos_dic = {0: np.array([0, 0, 0])}\n    parent_nodes = [0]  # Start with the root node\n\n    # Add trachea node and edge\n    trachea_pos = np.array([-edge_length, 0, 0])\n    node_pos_dic[-1] = trachea_pos\n    graph.add_node(-1, node_coordinate=trachea_pos)\n    graph.add_edge(\n        -1,\n        0,\n        **{\n            EDGE_COORDINATES_KEY: np.linspace(\n                trachea_pos, np.array([0, 0, 0]), 5 + edge_length\n            )\n        },\n    )\n\n    # Initialize the first two branches\n    m = edge_length * np.cos(angle_rad)\n    n = edge_length * np.sin(angle_rad)\n    new_pos = node_pos_dic[0] + np.array([m, n, 0])\n    node_pos_dic[1] = new_pos\n    edge_coordinates = np.linspace(node_pos_dic[0], new_pos, 5 + edge_length)\n    graph.add_node(1)\n    graph.add_edge(0, 1, **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": \"left\"})\n\n    m = edge_length * np.cos(-angle_rad)\n    n = edge_length * np.sin(-angle_rad)\n    new_pos = node_pos_dic[0] + np.array([m, n, 0])\n    node_pos_dic[2] = new_pos\n    edge_coordinates = np.linspace(node_pos_dic[0], new_pos, 5 + edge_length)\n    graph.add_node(2)\n    graph.add_edge(0, 2, **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": \"right\"})\n\n    parent_nodes = [1, 2]  # Update parent nodes to the first two branches\n    i = 3  # Start adding new nodes from index 3\n\n    while i &lt; num_nodes:\n        new_parents = []\n        for parent_node in parent_nodes:\n            if i &lt; num_nodes:\n                # Add the first child node\n                angle_rad = np.radians(angle / 2)\n\n                # Get the path to the root node\n                # count the number of left vs right edges\n                path = nx.shortest_path(graph, 0, parent_node)\n                edges = [(path[j], path[j + 1]) for j in range(len(path) - 1)]\n                sides = [graph.edges[edge][\"side\"] for edge in edges]\n                left_edges = sides.count(\"left\")\n                right_edges = sides.count(\"right\")\n                num_rotations = left_edges - right_edges\n\n                # Adjust angle based on the number of rotations\n                angle_rad *= num_rotations + 1\n\n                m = edge_length * np.cos(angle_rad)\n                n = edge_length * np.sin(angle_rad)\n                side = \"left\"\n                new_pos = node_pos_dic[parent_node] + np.array([m, n, 0])\n\n                node_pos_dic[i] = new_pos\n                edge_coordinates = np.linspace(\n                    node_pos_dic[parent_node], new_pos, 5 + edge_length\n                )\n                graph.add_node(i)\n                graph.add_edge(\n                    parent_node,\n                    i,\n                    **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": side},\n                )\n                new_parents.append(i)\n                i += 1\n\n            if i &lt; num_nodes:\n                # Add the second child node and rotate in the opposite direction\n                angle_rad = np.radians(angle) / 2\n\n                path = nx.shortest_path(graph, 0, parent_node)\n                edges = [(path[j], path[j + 1]) for j in range(len(path) - 1)]\n                sides = [graph.edges[edge][\"side\"] for edge in edges]\n                left_edges = sides.count(\"left\")\n                right_edges = sides.count(\"right\")\n                num_rotations = left_edges - right_edges\n\n                angle_rad *= num_rotations - 1\n\n                m = edge_length * np.cos(angle_rad)\n                n = edge_length * np.sin(angle_rad)\n                side = \"right\"\n                new_pos = node_pos_dic[parent_node] + np.array([m, n, 0])\n                node_pos_dic[i] = new_pos\n                edge_coordinates = np.linspace(\n                    node_pos_dic[parent_node], new_pos, 5 + edge_length\n                )\n                graph.add_node(i)\n                graph.add_edge(\n                    parent_node,\n                    i,\n                    **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": side},\n                )\n                new_parents.append(i)\n                i += 1\n\n        parent_nodes = new_parents  # Update parent nodes for the next iteration\n\n    # Set node attributes for the graph\n    nx.set_node_attributes(graph, node_pos_dic, NODE_COORDINATE_KEY)\n\n    # Create a SkeletonGraph from the graph\n    skeleton_graph = SkeletonGraph.from_graph(\n        graph, EDGE_COORDINATES_KEY, NODE_COORDINATE_KEY\n    )\n    return skeleton_graph\n</code></pre>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle(num_nodes)","title":"<code>num_nodes</code>","text":"(<code>int</code>, default:                   <code>19</code> )           \u2013            <p>The number of nodes in the graph.</p>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle(angle)","title":"<code>angle</code>","text":"(<code>int</code>, default:                   <code>72</code> )           \u2013            <p>The angle between branches in degrees.</p>"},{"location":"reference/skeleplex/data/skeletons/#skeleplex.data.skeletons.generate_toy_skeleton_graph_symmetric_branch_angle(edge_length)","title":"<code>edge_length</code>","text":"(<code>float</code>, default:                   <code>20</code> )           \u2013            <p>The length of each edge in the graph.</p>"},{"location":"reference/skeleplex/data/tubes/","title":"tubes","text":""},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes","title":"skeleplex.data.tubes","text":"<p>Drawing tubes in a volume as example data.</p> <p>Functions:</p> <ul> <li> <code>draw_tube</code>             \u2013              <p>Add a tube aligned along the z-axis into an existing 3D volume.</p> </li> <li> <code>draw_tubes_image_example</code>             \u2013              <p>Creates a 3D image with multiple tubes for testing.</p> </li> </ul>"},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes.draw_tube","title":"draw_tube","text":"<pre><code>draw_tube(image: ndarray, center: tuple[int, int] = (50, 50), diameter: int = 20, z_span: tuple[int, int] = (25, 75)) -&gt; ndarray\n</code></pre> <p>Add a tube aligned along the z-axis into an existing 3D volume.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>image</code> (              <code>ndarray</code> )          \u2013            <p>The input image with the new tube added.</p> </li> </ul> Source code in <code>skeleplex/data/tubes.py</code> <pre><code>def draw_tube(\n    image: np.ndarray,\n    center: tuple[int, int] = (50, 50),\n    diameter: int = 20,\n    z_span: tuple[int, int] = (25, 75),\n) -&gt; np.ndarray:\n    \"\"\"\n    Add a tube aligned along the z-axis into an existing 3D volume.\n\n    Parameters\n    ----------\n    image : ndarray\n        3D volume (z, y, x) that will be modified in place.\n    center : tuple of int\n        (row, col) center of the tube in each xy slice.\n    diameter : int\n        Diameter of the circular cross-section.\n    z_span : tuple of int\n        (start, end) range of z-slices to fill.\n\n    Returns\n    -------\n    image : ndarray\n        The input image with the new tube added.\n    \"\"\"\n    radius = diameter // 2\n    rr, cc = disk(center, radius, shape=image.shape[1:])\n\n    for z in range(z_span[0], z_span[1]):\n        image[z, rr, cc] = 1\n\n    return image\n</code></pre>"},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes.draw_tube(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D volume (z, y, x) that will be modified in place.</p>"},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes.draw_tube(center)","title":"<code>center</code>","text":"(<code>tuple of int</code>, default:                   <code>(50, 50)</code> )           \u2013            <p>(row, col) center of the tube in each xy slice.</p>"},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes.draw_tube(diameter)","title":"<code>diameter</code>","text":"(<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Diameter of the circular cross-section.</p>"},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes.draw_tube(z_span)","title":"<code>z_span</code>","text":"(<code>tuple of int</code>, default:                   <code>(25, 75)</code> )           \u2013            <p>(start, end) range of z-slices to fill.</p>"},{"location":"reference/skeleplex/data/tubes/#skeleplex.data.tubes.draw_tubes_image_example","title":"draw_tubes_image_example","text":"<pre><code>draw_tubes_image_example() -&gt; ndarray\n</code></pre> <p>Creates a 3D image with multiple tubes for testing.</p> <p>First and empty 100x100x100 volume is created, then seven tubes with different centers, diameters, and z-spans are added to imitate different scales.</p> <p>Returns:</p> <ul> <li> <code>image</code> (              <code>ndarray</code> )          \u2013            <p>The output image is a 3D numpy array of shape 100x100x100 containing seven tubes along the z-axis with various diameters.</p> </li> </ul> Source code in <code>skeleplex/data/tubes.py</code> <pre><code>def draw_tubes_image_example() -&gt; np.ndarray:\n    \"\"\"\n    Creates a 3D image with multiple tubes for testing.\n\n    First and empty 100x100x100 volume is created, then seven tubes with different\n    centers, diameters, and z-spans are added to imitate different scales.\n\n    Returns\n    -------\n    image : ndarray\n        The output image is a 3D numpy array of shape 100x100x100 containing\n        seven tubes along the z-axis with various diameters.\n\n    \"\"\"\n    tubes_image = np.zeros((100, 100, 100), dtype=np.uint8)\n\n    draw_tube(tubes_image, center=(70, 70), diameter=45, z_span=(45, 95))\n    draw_tube(tubes_image, center=(20, 65), diameter=30, z_span=(25, 65))\n    draw_tube(tubes_image, center=(55, 25), diameter=25, z_span=(10, 45))\n    draw_tube(tubes_image, center=(25, 30), diameter=20, z_span=(45, 75))\n    draw_tube(tubes_image, center=(40, 85), diameter=14, z_span=(45, 60))\n    draw_tube(tubes_image, center=(80, 20), diameter=10, z_span=(10, 25))\n    draw_tube(tubes_image, center=(10, 10), diameter=10, z_span=(60, 75))\n\n    return tubes_image\n</code></pre>"},{"location":"reference/skeleplex/data/utils/","title":"utils","text":""},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils","title":"skeleplex.data.utils","text":"<p>Functions:</p> <ul> <li> <code>add_noise_to_image_surface</code>             \u2013              <p>Adds noise to the surface of a binary 3D image and voxelizes the result.</p> </li> <li> <code>add_rotation_to_tree</code>             \u2013              <p>Adds a random rotation between -90 and 90 degrees to each level of the tree.</p> </li> <li> <code>apply_structured_noise</code>             \u2013              <p>Apply structured noise to a mesh by displacing its vertices.</p> </li> <li> <code>augment_tree</code>             \u2013              <p>Augment a tree by rotating it along the trachea.</p> </li> <li> <code>crop_to_content</code>             \u2013              <p>Crop the branch and skeleton images to the content.</p> </li> <li> <code>draw_cylinder_segment</code>             \u2013              <p>Draw a cylinder segment in a 3D binary mask.</p> </li> <li> <code>draw_ellipsoid_at_point</code>             \u2013              <p>Draw an ellipsoid at a point in a 3D binary mask.</p> </li> <li> <code>draw_elliptic_cylinder_segment</code>             \u2013              <p>Wrapper to ensure clean Numba-compatible input types.</p> </li> <li> <code>draw_line_segment</code>             \u2013              <p>Draw a line segment in-place.</p> </li> <li> <code>draw_line_segment_wiggle</code>             \u2013              <p>Draw a line segment in-place.</p> </li> <li> <code>draw_wiggly_cylinder_3d</code>             \u2013              <p>Draw a wiggly cylinder in a 3D binary mask.</p> </li> <li> <code>generate_low_freq_noise</code>             \u2013              <p>Generate low-frequency noise for structured displacement.</p> </li> <li> <code>generate_toy_graph_symmetric_branch_angle</code>             \u2013              <p>Generate a toy skeleton graph with a symmetric branch angle.</p> </li> <li> <code>make_skeleton_blur_image</code>             \u2013              <p>Create a blurred skeleton image from a binary skeleton image.</p> </li> <li> <code>select_points_in_bounding_box</code>             \u2013              <p>Select all points inside a specified axis-aligned bounding box.</p> </li> </ul>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.add_noise_to_image_surface","title":"add_noise_to_image_surface","text":"<pre><code>add_noise_to_image_surface(image, noise_magnitude=15)\n</code></pre> <p>Adds noise to the surface of a binary 3D image and voxelizes the result.</p> <p>This function uses marching cubes to extract the surface mesh of the binary image, adds Gaussian noise to the mesh, and then voxelizes the result.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Binary voxel volume (Z, Y, X) of the noisy shape.</p> </li> </ul> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def add_noise_to_image_surface(image, noise_magnitude=15):\n    \"\"\"\n    Adds noise to the surface of a binary 3D image and voxelizes the result.\n\n    This function uses marching cubes to extract the surface mesh of the binary image,\n    adds Gaussian noise to the mesh, and then voxelizes the result.\n\n    Parameters\n    ----------\n    image : (Z, Y, X) ndarray\n        Binary image where the object is labeled as 1.\n    noise_magnitude : float\n        Magnitude of Gaussian displacement applied to the surface mesh.\n\n    Returns\n    -------\n    ndarray\n        Binary voxel volume (Z, Y, X) of the noisy shape.\n    \"\"\"\n    # Get surface mesh\n    # time_start = time()\n    verts, faces, _, _ = marching_cubes(image.astype(float), level=0.5)\n    mesh = trimesh.Trimesh(vertices=verts, faces=faces, process=False)\n    # add Gaussian noise to vertices\n    noise_field = generate_low_freq_noise(\n        image.shape, scale=noise_magnitude, smooth_sigma=10\n    )\n    mesh = apply_structured_noise(mesh, noise_field)\n    mesh.vertices += np.random.normal(\n        scale=noise_magnitude / 4, size=mesh.vertices.shape\n    )\n    # Smooth\n    mesh = trimesh.smoothing.filter_taubin(mesh, lamb=0.7, nu=-0.3, iterations=10)\n    mesh.fix_normals()\n\n    x, y, z = np.indices(image.shape)\n    coords = np.stack((x, y, z), axis=-1)  # shape:\n    coords = coords.reshape(-1, 3)  # Flatten to (N, 3)\n\n    # Compute signed distances\n    # if on windows, use igl signed distance\n    if os.name == \"nt\":\n        signed_distances, _, _, _ = signed_distance(\n            coords, np.array(mesh.vertices), np.array(mesh.faces), sign_type=1\n        )\n\n        noisey_image = signed_distances.reshape(image.shape).copy()\n        noisey_image[noisey_image &gt;= 0] = 0  # Set inside points to 1\n        noisey_image[noisey_image &lt; 0] = 1\n    else:\n        sdgf = SDF(mesh.vertices, mesh.faces)\n        noisey_image = sdgf.contains(coords).reshape(image.shape)\n\n    return noisey_image.astype(np.uint8)\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.add_noise_to_image_surface(image)","title":"<code>image</code>","text":"(<code>(Z, Y, X) ndarray</code>)           \u2013            <p>Binary image where the object is labeled as 1.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.add_noise_to_image_surface(noise_magnitude)","title":"<code>noise_magnitude</code>","text":"(<code>float</code>, default:                   <code>15</code> )           \u2013            <p>Magnitude of Gaussian displacement applied to the surface mesh.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.add_rotation_to_tree","title":"add_rotation_to_tree","text":"<pre><code>add_rotation_to_tree(tree: DiGraph, rotation_angle: float | None = None)\n</code></pre> <p>Adds a random rotation between -90 and 90 degrees to each level of the tree.</p> <p>Each node needs to contain the 3D positional coordinates (array with shape (3,)) in attribute NODE_COORDINATE_KEY. Rotation will happen along axis 0 (x-axis).</p> <p>NOTE: This function does not rotate edge coordinates. Might implement this in the future.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def add_rotation_to_tree(tree: nx.DiGraph, rotation_angle: float | None = None):\n    \"\"\"Adds a random rotation between -90 and 90 degrees to each level of the tree.\n\n    Each node needs to contain the 3D positional coordinates (array with shape (3,))\n    in attribute NODE_COORDINATE_KEY.\n    Rotation will happen along axis 0 (x-axis).\n\n    NOTE: This function does not rotate edge coordinates.\n    Might implement this in the future.\n\n    Parameters\n    ----------\n    tree: nx.DiGraph\n        The tree to rotate.\n        Eg. to graph from generate_toy_graph_symmetric_branch_angle.\n    rotation_angle: float | None\n        If provided, the rotation angle in degrees to apply to the tree.\n        If None, a random angle between -90 and 90 degrees will be used.\n    \"\"\"\n    in_edges = list(tree.in_edges())\n    in_edges_flatt = [node for edge in in_edges for node in edge]\n\n    for nodes, degree in tree.degree():\n        if rotation_angle is not None:\n            rot_degree = -np.radians(rotation_angle)\n        else:\n            rot_degree = np.radians(random.sample(list(np.linspace(-90, 90, 10)), 1))[0]\n\n        updated_positions = {}\n        if degree == 3:\n            if nodes in in_edges_flatt:\n                sub_tree = tree.subgraph(nx.dfs_tree(tree, source=nodes).nodes())\n\n                root = np.array(\n                    dict(sub_tree.nodes(data=True))[nodes][NODE_COORDINATE_KEY]\n                )\n\n                for node in sub_tree.nodes():\n                    p = tree.nodes(data=NODE_COORDINATE_KEY)[node]\n                    p = p - root\n\n                    # Rotation matrix around X-axis (axis 0)\n                    R_matrix = np.array(\n                        [\n                            [1, 0, 0],\n                            [0, np.cos(rot_degree), -np.sin(rot_degree)],\n                            [0, np.sin(rot_degree), np.cos(rot_degree)],\n                        ]\n                    )\n\n                    r = R.from_matrix(R_matrix)\n                    p_rot = r.apply(p)\n                    p_rot = p_rot + root\n                    updated_positions[node] = p_rot.flatten()\n\n            nx.set_node_attributes(tree, updated_positions, name=NODE_COORDINATE_KEY)\n\n    # avoid negative coordinates\n    pos_dict = nx.get_node_attributes(tree, NODE_COORDINATE_KEY)\n    pos_values = np.array(list(pos_dict.values()))\n\n    x_shift = np.abs(np.min(pos_values[:, 0])) + 10\n    y_shift = np.abs(np.min(pos_values[:, 1])) + 30\n    z_shift = np.abs(np.min(pos_values[:, 2])) + 10\n\n    pos = {k: v + np.array([x_shift, y_shift, z_shift]) for k, v in pos_dict.items()}\n    nx.set_node_attributes(tree, pos, NODE_COORDINATE_KEY)\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.add_rotation_to_tree(tree)","title":"<code>tree</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The tree to rotate. Eg. to graph from generate_toy_graph_symmetric_branch_angle.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.add_rotation_to_tree(rotation_angle)","title":"<code>rotation_angle</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the rotation angle in degrees to apply to the tree. If None, a random angle between -90 and 90 degrees will be used.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.apply_structured_noise","title":"apply_structured_noise","text":"<pre><code>apply_structured_noise(mesh, noise_field)\n</code></pre> <p>Apply structured noise to a mesh by displacing its vertices.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Trimesh</code>           \u2013            <p>The mesh with applied noise.</p> </li> </ul> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def apply_structured_noise(mesh, noise_field):\n    \"\"\"Apply structured noise to a mesh by displacing its vertices.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The input mesh to which noise will be applied.\n    noise_field : np.ndarray\n        3D array of noise values to displace the mesh vertices.\n\n    Returns\n    -------\n    trimesh.Trimesh\n        The mesh with applied noise.\n    \"\"\"\n    verts = mesh.vertices\n    # Round and clip coordinates to index into volume\n    coords = np.round(verts).astype(int)\n    coords = np.clip(coords, [0, 0, 0], np.array(noise_field.shape) - 1)\n\n    # Use the noise as displacement along normals\n    displacement = noise_field[coords[:, 0], coords[:, 1], coords[:, 2]]\n    normals = mesh.vertex_normals\n    verts += normals * displacement[:, np.newaxis]\n\n    mesh.vertices = verts\n    return mesh\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.apply_structured_noise(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The input mesh to which noise will be applied.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.apply_structured_noise(noise_field)","title":"<code>noise_field</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D array of noise values to displace the mesh vertices.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.augment_tree","title":"augment_tree","text":"<pre><code>augment_tree(tree: DiGraph, rotation_angles: list | None = None) -&gt; None\n</code></pre> <p>Augment a tree by rotating it along the trachea.</p> <p>Each node needs to contain the 3D positional coordinates (array with shape (3,))</p> <p>NOTE: This function does not rotate edge coordinates. Might implement this in the future.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def augment_tree(tree: nx.DiGraph, rotation_angles: list | None = None) -&gt; None:\n    \"\"\"\n    Augment a tree by rotating it along the trachea.\n\n    Each node needs to contain the 3D positional coordinates (array with shape (3,))\n\n    NOTE: This function does not rotate edge coordinates.\n    Might implement this in the future.\n\n    Parameters\n    ----------\n    tree : nx.DiGraph\n        The tree to augment.\n        Eg. to graph from generate_toy_graph_symmetric_branch_angle.\n    rotation_angles : float | None\n        If provided, the rotation angle in degrees to apply to the tree.\n        If None, a random angle between -30 and 30 degrees for each axis will be used.\n\n    \"\"\"\n    # Rotation matrices\n    if rotation_angles is not None:\n        rot_degree = np.radians(rotation_angles)\n    else:\n        # Randomly sample a rotation degree from -30 to 30 degrees\n        # for each axis\n        # 3 rotations, one for each axis\n        rot_degree = np.radians(random.sample(list(np.linspace(-30, 30, 60)), 3))\n    R_matrix_x = np.array(\n        (\n            [1, 0, 0],\n            [0, np.cos(rot_degree[0]), -np.sin(rot_degree[0])],\n            [0, np.sin(rot_degree[0]), np.cos(rot_degree[0])],\n        )\n    )\n\n    R_matrix_y = np.array(\n        (\n            [np.cos(rot_degree[1]), 0, np.sin(rot_degree[1])],\n            [0, 1, 0],\n            [-np.sin(rot_degree[1]), 0, np.cos(rot_degree[1])],\n        )\n    )\n\n    R_matrix_z = np.array(\n        (\n            [np.cos(rot_degree[2]), -np.sin(rot_degree[2]), 0],\n            [np.sin(rot_degree[2]), np.cos(rot_degree[2]), 0],\n            [0, 0, 1],\n        )\n    )\n    r_x = R.from_matrix(R_matrix_x)\n    r_y = R.from_matrix(R_matrix_y)\n    r_z = R.from_matrix(R_matrix_z)\n\n    # Augment tree by rotating it along the trachea\n    pos = nx.get_node_attributes(tree, NODE_COORDINATE_KEY)\n\n    update_pos = {}\n    for node, node_pos in pos.items():\n        root = pos[0]\n        p = node_pos - root\n\n        p_rot = r_x.apply(p)\n        p_rot = r_y.apply(p_rot)\n        p_rot = r_z.apply(p_rot)\n        p_rot = p_rot + root\n        update_pos[node] = p_rot.flatten()\n    nx.set_node_attributes(tree, update_pos, name=NODE_COORDINATE_KEY)\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.augment_tree(tree)","title":"<code>tree</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The tree to augment. Eg. to graph from generate_toy_graph_symmetric_branch_angle.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.augment_tree(rotation_angles)","title":"<code>rotation_angles</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, the rotation angle in degrees to apply to the tree. If None, a random angle between -30 and 30 degrees for each axis will be used.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.crop_to_content","title":"crop_to_content","text":"<pre><code>crop_to_content(branch_image, skeleton_image)\n</code></pre> <p>Crop the branch and skeleton images to the content.</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def crop_to_content(branch_image, skeleton_image):\n    \"\"\"Crop the branch and skeleton images to the content.\"\"\"\n    branch_nonzero = np.argwhere(branch_image)\n    if branch_nonzero.size == 0:\n        return branch_image, skeleton_image\n\n    min_coords = np.array(\n        [\n            np.min(np.where(branch_image)[0]),\n            np.min(np.where(branch_image)[1]),\n            np.min(np.where(branch_image)[2]),\n        ]\n    )\n    max_coords = np.array(\n        [\n            np.max(np.where(branch_image)[0]),\n            np.max(np.where(branch_image)[1]),\n            np.max(np.where(branch_image)[2]),\n        ]\n    )\n\n    branch_cropped = branch_image[\n        min_coords[0] : max_coords[0] + 1,\n        min_coords[1] : max_coords[1] + 1,\n        min_coords[2] : max_coords[2] + 1,\n    ]\n\n    skeleton_cropped = skeleton_image[\n        min_coords[0] : max_coords[0] + 1,\n        min_coords[1] : max_coords[1] + 1,\n        min_coords[2] : max_coords[2] + 1,\n    ]\n\n    return branch_cropped, skeleton_cropped\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_cylinder_segment","title":"draw_cylinder_segment","text":"<pre><code>draw_cylinder_segment(mask, a, b, radius)\n</code></pre> <p>Draw a cylinder segment in a 3D binary mask.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>@numba.njit(parallel=True)\ndef draw_cylinder_segment(mask, a, b, radius):\n    \"\"\"Draw a cylinder segment in a 3D binary mask.\n\n    Parameters\n    ----------\n    mask : np.ndarray\n        3D binary mask (Z, Y, X) to draw the cylinder into.\n    a : np.ndarray\n        Starting point of the cylinder in (z, y, x) coordinates.\n    b : np.ndarray\n        Ending point of the cylinder in (z, y, x) coordinates.\n    radius : float\n        Radius of the cylinder.\n    \"\"\"\n    a = np.asarray(a, dtype=np.float32)\n    b = np.asarray(b, dtype=np.float32)\n    d = b - a\n    length = np.linalg.norm(d)\n    if length == 0:\n        return\n\n    d_unit = d / length\n    radius_sq = radius * radius\n    margin = int(radius) + 2\n\n    shape = mask.shape\n    zmin = max(0, int(min(a[2], b[2]) - margin))\n    zmax = min(shape[0], int(max(a[2], b[2]) + margin + 1))\n    ymin = max(0, int(min(a[1], b[1]) - margin))\n    ymax = min(shape[1], int(max(a[1], b[1]) + margin + 1))\n    xmin = max(0, int(min(a[0], b[0]) - margin))\n    xmax = min(shape[2], int(max(a[0], b[0]) + margin + 1))\n\n    for z in numba.prange(zmin, zmax):\n        for y in range(ymin, ymax):\n            for x in range(xmin, xmax):\n                p = np.array([x, y, z], dtype=np.float32)\n                pa = p - a\n                t = np.dot(pa, d_unit)\n                if t &lt; 0:\n                    t = 0\n                elif t &gt; length:\n                    t = length\n                closest = a + t * d_unit\n                dist_sq = np.sum((p - closest) ** 2)\n                if dist_sq &lt;= radius_sq:\n                    mask[z, y, x] = 1\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_cylinder_segment(mask)","title":"<code>mask</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D binary mask (Z, Y, X) to draw the cylinder into.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_cylinder_segment(a)","title":"<code>a</code>","text":"(<code>ndarray</code>)           \u2013            <p>Starting point of the cylinder in (z, y, x) coordinates.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_cylinder_segment(b)","title":"<code>b</code>","text":"(<code>ndarray</code>)           \u2013            <p>Ending point of the cylinder in (z, y, x) coordinates.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_cylinder_segment(radius)","title":"<code>radius</code>","text":"(<code>float</code>)           \u2013            <p>Radius of the cylinder.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_ellipsoid_at_point","title":"draw_ellipsoid_at_point","text":"<pre><code>draw_ellipsoid_at_point(mask, point, radii)\n</code></pre> <p>Draw an ellipsoid at a point in a 3D binary mask.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def draw_ellipsoid_at_point(mask, point, radii):\n    \"\"\"\n    Draw an ellipsoid at a point in a 3D binary mask.\n\n    Parameters\n    ----------\n    mask : np.ndarray\n        3D binary mask (Z, Y, X)\n    point : tuple or np.ndarray\n        Center of the ellipsoid in (x, y, z) coordinates\n    radii : tuple or list\n        Radii (rx, ry, rz) along X, Y, Z\n    \"\"\"\n    px, py, pz = point[[2, 1, 0]]\n    rx, ry, rz = radii\n    shape = mask.shape\n\n    zmin = max(0, int(pz - rz) - 1)\n    zmax = min(shape[0], int(pz + rz) + 1)\n    ymin = max(0, int(py - ry) - 1)\n    ymax = min(shape[1], int(py + ry) + 1)\n    xmin = max(0, int(px - rx) - 1)\n    xmax = min(shape[2], int(px + rx) + 1)\n\n    zz, yy, xx = np.meshgrid(\n        np.arange(zmin, zmax),\n        np.arange(ymin, ymax),\n        np.arange(xmin, xmax),\n        indexing=\"ij\",\n    )\n\n    # Compute normalized squared distance\n    norm_sq = ((xx - px) / rx) ** 2 + ((yy - py) / ry) ** 2 + ((zz - pz) / rz) ** 2\n    local_mask = norm_sq &lt;= 1\n\n    mask[zmin:zmax, ymin:ymax, xmin:xmax] |= local_mask.astype(np.uint8)\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_ellipsoid_at_point(mask)","title":"<code>mask</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D binary mask (Z, Y, X)</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_ellipsoid_at_point(point)","title":"<code>point</code>","text":"(<code>tuple or ndarray</code>)           \u2013            <p>Center of the ellipsoid in (x, y, z) coordinates</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_ellipsoid_at_point(radii)","title":"<code>radii</code>","text":"(<code>tuple or list</code>)           \u2013            <p>Radii (rx, ry, rz) along X, Y, Z</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_elliptic_cylinder_segment","title":"draw_elliptic_cylinder_segment","text":"<pre><code>draw_elliptic_cylinder_segment(mask, a, b, rx, ry)\n</code></pre> <p>Wrapper to ensure clean Numba-compatible input types.</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def draw_elliptic_cylinder_segment(mask, a, b, rx, ry):\n    \"\"\"Wrapper to ensure clean Numba-compatible input types.\"\"\"\n    a = np.array(a, dtype=np.float32)\n    a = a[[2, 1, 0]]  # Convert to z,y,x order\n    b = np.array(b, dtype=np.float32)\n    b = b[[2, 1, 0]]  # Convert to z,y,x order\n    _draw_elliptic_cylinder_segment(mask, a, b, np.float32(rx), np.float32(ry))\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment","title":"draw_line_segment","text":"<pre><code>draw_line_segment(start_point: ndarray, end_point: ndarray, skeleton_image: ndarray, fill_value: int = 1)\n</code></pre> <p>Draw a line segment in-place.</p> <p>Note: line will be clipped if it extends beyond the bounding box of the skeleton_image.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def draw_line_segment(\n    start_point: np.ndarray,\n    end_point: np.ndarray,\n    skeleton_image: np.ndarray,\n    fill_value: int = 1,\n):\n    \"\"\"Draw a line segment in-place.\n\n    Note: line will be clipped if it extends beyond the\n    bounding box of the skeleton_image.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (d,) array containing the starting point of the line segment.\n        Must be an integer index.\n    end_point : np.ndarray\n        (d,) array containing the end point of the line segment.\n        Most be an integer index\n    skeleton_image : np.ndarray\n        The image in which to draw the line segment.\n        Must be the same dimensionality as start_point and end_point.\n    fill_value : int\n        The value to use for the line segment.\n        Default value is 1.\n    \"\"\"\n    branch_length = np.linalg.norm(end_point - start_point)\n    n_skeleton_points = int(2 * branch_length)\n    skeleton_points = np.linspace(start_point, end_point, n_skeleton_points)\n\n    # filter for points within the image\n    image_bounds = np.asarray(skeleton_image.shape) - 1\n    skeleton_points = select_points_in_bounding_box(\n        points=skeleton_points,\n        lower_left_corner=np.array([0, 0, 0]),\n        upper_right_corner=image_bounds,\n    ).astype(int)\n    skeleton_image[\n        skeleton_points[:, 0], skeleton_points[:, 1], skeleton_points[:, 2]\n    ] = fill_value\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(d,) array containing the starting point of the line segment. Must be an integer index.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment(end_point)","title":"<code>end_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(d,) array containing the end point of the line segment. Most be an integer index</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The image in which to draw the line segment. Must be the same dimensionality as start_point and end_point.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment(fill_value)","title":"<code>fill_value</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The value to use for the line segment. Default value is 1.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle","title":"draw_line_segment_wiggle","text":"<pre><code>draw_line_segment_wiggle(start_point: ndarray, end_point: ndarray, skeleton_image: ndarray, fill_value: int = 1, wiggle_factor: float = 0.01, axis: int | None = None)\n</code></pre> <p>Draw a line segment in-place.</p> <p>Note: line will be clipped if it extends beyond the bounding box of the skeleton_image.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def draw_line_segment_wiggle(\n    start_point: np.ndarray,\n    end_point: np.ndarray,\n    skeleton_image: np.ndarray,\n    fill_value: int = 1,\n    wiggle_factor: float = 0.01,\n    axis: int | None = None,\n):\n    \"\"\"Draw a line segment in-place.\n\n    Note: line will be clipped if it extends beyond the\n    bounding box of the skeleton_image.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (d,) array containing the starting point of the line segment.\n        Must be an integer index.\n    end_point : np.ndarray\n        (d,) array containing the end point of the line segment.\n        Most be an integer index\n    skeleton_image : np.ndarray\n        The image in which to draw the line segment.\n        Must be the same dimensionality as start_point and end_point.\n    fill_value : int\n        The value to use for the line segment.\n        Default value is 1.\n    wiggle_factor : float\n        The factor by which to wiggle the line segment.\n        Default value is 0.01.\n    axis : int, optional\n        The axis along which to apply the wiggle.\n        If None, a random axis will be chosen.\n        Default is None.\n    \"\"\"\n    branch_length = np.linalg.norm(end_point - start_point)\n    n_skeleton_points = int(2 * branch_length)\n    frequency = wiggle_factor * branch_length\n    amplitude = wiggle_factor * branch_length\n\n    skeleton_points = np.linspace(start_point, end_point, n_skeleton_points)\n\n    # Generate sinusoidal noise\n    time_points = np.linspace(0, 1, n_skeleton_points)\n    sinusoidal_noise = amplitude * np.sin(2 * np.pi * frequency * time_points)\n\n    # Add sinusoidal noise to the line\n    if axis is None:\n        axis = np.random.randint(0, 3)\n    skeleton_points[1:-1, axis] += (\n        np.random.uniform(-0.5, 0.5, size=n_skeleton_points - 2)\n        + sinusoidal_noise[1:-1]\n    )\n\n    for i in range(1, len(skeleton_points) - 1):\n        draw_line_segment(\n            skeleton_points[i],\n            skeleton_points[i + 1],\n            skeleton_image,\n            fill_value=fill_value,\n        )\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(d,) array containing the starting point of the line segment. Must be an integer index.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle(end_point)","title":"<code>end_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(d,) array containing the end point of the line segment. Most be an integer index</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The image in which to draw the line segment. Must be the same dimensionality as start_point and end_point.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle(fill_value)","title":"<code>fill_value</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The value to use for the line segment. Default value is 1.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle(wiggle_factor)","title":"<code>wiggle_factor</code>","text":"(<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>The factor by which to wiggle the line segment. Default value is 0.01.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_line_segment_wiggle(axis)","title":"<code>axis</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The axis along which to apply the wiggle. If None, a random axis will be chosen. Default is None.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d","title":"draw_wiggly_cylinder_3d","text":"<pre><code>draw_wiggly_cylinder_3d(mask, start_point, end_point, radius=2, wiggle_factor=0.01, axis=None)\n</code></pre> <p>Draw a wiggly cylinder in a 3D binary mask.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def draw_wiggly_cylinder_3d(\n    mask, start_point, end_point, radius=2, wiggle_factor=0.01, axis=None\n):\n    \"\"\"Draw a wiggly cylinder in a 3D binary mask.\n\n    Parameters\n    ----------\n    mask : np.ndarray\n        3D binary mask (Z, Y, X) to draw the cylinder into.\n    start_point : np.ndarray\n        Starting point of the cylinder in (z, y, x) coordinates.\n    end_point : np.ndarray\n        Ending point of the cylinder in (z, y, x) coordinates.\n    radius : float\n        Radius of the cylinder.\n    wiggle_factor : float\n        Factor controlling the amount of wiggle.\n    axis : int, optional\n        Axis along which to apply the wiggle (0: x, 1: y, 2: z).\n\n    \"\"\"\n    start_point = np.array(start_point)[[2, 1, 0]]\n    end_point = np.array(end_point)[[2, 1, 0]]\n    axis = np.random.randint(0, 3) if axis is None else axis\n    axis = 2 - axis  # Adjust axis for z,y,x order\n    branch_length = np.linalg.norm(end_point - start_point)\n    n_skeleton_points = int(2 * branch_length)\n    frequency = wiggle_factor * branch_length\n    amplitude = wiggle_factor * branch_length\n\n    # Linear skeleton path\n    skeleton_points = np.linspace(start_point, end_point, n_skeleton_points)\n\n    # Generate sinusoidal noise\n    time_points = np.linspace(0, 1, n_skeleton_points)\n    sinusoidal_noise = amplitude * np.sin(2 * np.pi * frequency * time_points)\n\n    # Wiggle in a random axis\n\n    skeleton_points[1:-1, axis] += (\n        np.random.uniform(-0.5, 0.5, size=n_skeleton_points - 2)\n        + sinusoidal_noise[1:-1]\n    )\n\n    # Draw cylinders along wiggly skeleton\n    for i in range(len(skeleton_points) - 1):\n        a = skeleton_points[i]\n        b = skeleton_points[i + 1]\n        draw_cylinder_segment(mask, a, b, radius=radius)\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d(mask)","title":"<code>mask</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D binary mask (Z, Y, X) to draw the cylinder into.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>Starting point of the cylinder in (z, y, x) coordinates.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d(end_point)","title":"<code>end_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>Ending point of the cylinder in (z, y, x) coordinates.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d(radius)","title":"<code>radius</code>","text":"(<code>float</code>, default:                   <code>2</code> )           \u2013            <p>Radius of the cylinder.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d(wiggle_factor)","title":"<code>wiggle_factor</code>","text":"(<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Factor controlling the amount of wiggle.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.draw_wiggly_cylinder_3d(axis)","title":"<code>axis</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Axis along which to apply the wiggle (0: x, 1: y, 2: z).</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_low_freq_noise","title":"generate_low_freq_noise","text":"<pre><code>generate_low_freq_noise(shape, scale=30, smooth_sigma=10)\n</code></pre> <p>Generate low-frequency noise for structured displacement.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Low-frequency noise array with the specified shape and scale.</p> </li> </ul> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def generate_low_freq_noise(shape, scale=30, smooth_sigma=10):\n    \"\"\"Generate low-frequency noise for structured displacement.\n\n    Parameters\n    ----------\n    shape : tuple\n        Shape of the noise array (Z, Y, X).\n    scale : float\n        Scale of the noise.\n    smooth_sigma : float\n        Standard deviation for Gaussian smoothing.\n\n    Returns\n    -------\n    np.ndarray\n        Low-frequency noise array with the specified shape and scale.\n    \"\"\"\n    noise = np.random.normal(size=shape)\n    smooth_noise = gaussian_filter(noise, sigma=smooth_sigma)\n    return smooth_noise / np.max(np.abs(smooth_noise)) * scale\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_low_freq_noise(shape)","title":"<code>shape</code>","text":"(<code>tuple</code>)           \u2013            <p>Shape of the noise array (Z, Y, X).</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_low_freq_noise(scale)","title":"<code>scale</code>","text":"(<code>float</code>, default:                   <code>30</code> )           \u2013            <p>Scale of the noise.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_low_freq_noise(smooth_sigma)","title":"<code>smooth_sigma</code>","text":"(<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Standard deviation for Gaussian smoothing.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_toy_graph_symmetric_branch_angle","title":"generate_toy_graph_symmetric_branch_angle","text":"<pre><code>generate_toy_graph_symmetric_branch_angle(num_nodes, angle=72, edge_length=20)\n</code></pre> <p>Generate a toy skeleton graph with a symmetric branch angle.</p> <p>Parameters:</p> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def generate_toy_graph_symmetric_branch_angle(num_nodes, angle=72, edge_length=20):\n    \"\"\"Generate a toy skeleton graph with a symmetric branch angle.\n\n    Parameters\n    ----------\n    num_nodes : int\n        The total number of nodes in the graph.\n    angle : float\n        The angle in degrees between branches at each node.\n        Default is 72 degrees, which corresponds to a 5-fold symmetry.\n    edge_length : int\n        The length of the start edge in the graph. Each generation shrinks by 80%.\n        Default is 20.\n\n    \"\"\"\n    # Create a directed graph\n    graph = nx.DiGraph()\n\n    # Convert angle to radians and divide by 2 for symmetric branching\n    angle_rad = np.radians(angle / 2)\n\n    # Initialize node positions dictionary with the root node at the origin\n    node_pos_dic = {0: np.array([0, 0, 0])}\n    parent_nodes = [0]  # Start with the root node\n\n    # Add trachea node and edge\n    trachea_pos = np.array([-edge_length, 0, 0])\n    node_pos_dic[-1] = trachea_pos\n    graph.add_node(-1, node_coordinate=trachea_pos)\n    graph.add_edge(\n        -1,\n        0,\n        **{\n            EDGE_COORDINATES_KEY: np.linspace(\n                trachea_pos, np.array([0, 0, 0]), 5 + edge_length\n            )\n        },\n    )\n\n    # Initialize the first two branches\n    m = edge_length * np.cos(angle_rad)\n    n = edge_length * np.sin(angle_rad)\n    new_pos = node_pos_dic[0] + np.array([m, n, 0])\n    node_pos_dic[1] = new_pos\n    edge_coordinates = np.linspace(node_pos_dic[0], new_pos, 5 + edge_length)\n    graph.add_node(1)\n    graph.add_edge(0, 1, **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": \"left\"})\n\n    m = edge_length * np.cos(-angle_rad)\n    n = edge_length * np.sin(-angle_rad)\n    new_pos = node_pos_dic[0] + np.array([m, n, 0])\n    node_pos_dic[2] = new_pos\n    edge_coordinates = np.linspace(node_pos_dic[0], new_pos, 5 + edge_length)\n    graph.add_node(2)\n    graph.add_edge(0, 2, **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": \"right\"})\n\n    parent_nodes = [1, 2]  # Update parent nodes to the first two branches\n    i = 3  # Start adding new nodes from index 3\n\n    while i &lt; num_nodes:\n        if np.log2(i - 1).is_integer():\n            edge_length = int(\n                0.79 * edge_length\n            )  # Decrease edge length for subsequent branches\n        new_parents = []\n        for parent_node in parent_nodes:\n            if i &lt; num_nodes:\n                # Add the first child node\n                angle_rad = np.radians(angle / 2)\n\n                # Get the path to the root node\n                # count the number of left vs right edges\n                path = nx.shortest_path(graph, 0, parent_node)\n                edges = [(path[j], path[j + 1]) for j in range(len(path) - 1)]\n                sides = [graph.edges[edge][\"side\"] for edge in edges]\n                left_edges = sides.count(\"left\")\n                right_edges = sides.count(\"right\")\n                num_rotations = left_edges - right_edges\n\n                # Adjust angle based on the number of rotations\n                angle_rad *= num_rotations + 1\n\n                m = edge_length * np.cos(angle_rad)\n                n = edge_length * np.sin(angle_rad)\n                side = \"left\"\n                new_pos = node_pos_dic[parent_node] + np.array([m, n, 0])\n\n                node_pos_dic[i] = new_pos\n                edge_coordinates = np.linspace(\n                    node_pos_dic[parent_node], new_pos, 5 + edge_length\n                )\n                graph.add_node(i)\n                graph.add_edge(\n                    parent_node,\n                    i,\n                    **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": side},\n                )\n                new_parents.append(i)\n                i += 1\n\n            if i &lt; num_nodes:\n                # Add the second child node and rotate in the opposite direction\n                angle_rad = np.radians(angle) / 2\n\n                path = nx.shortest_path(graph, 0, parent_node)\n                edges = [(path[j], path[j + 1]) for j in range(len(path) - 1)]\n                sides = [graph.edges[edge][\"side\"] for edge in edges]\n                left_edges = sides.count(\"left\")\n                right_edges = sides.count(\"right\")\n                num_rotations = left_edges - right_edges\n\n                angle_rad *= num_rotations - 1\n\n                m = edge_length * np.cos(angle_rad)\n                n = edge_length * np.sin(angle_rad)\n                side = \"right\"\n                new_pos = node_pos_dic[parent_node] + np.array([m, n, 0])\n                node_pos_dic[i] = new_pos\n                edge_coordinates = np.linspace(\n                    node_pos_dic[parent_node], new_pos, 5 + edge_length\n                )\n                graph.add_node(i)\n                graph.add_edge(\n                    parent_node,\n                    i,\n                    **{EDGE_COORDINATES_KEY: edge_coordinates, \"side\": side},\n                )\n                new_parents.append(i)\n                i += 1\n            # Decrease edge length for the next generation\n\n        parent_nodes = new_parents  # Update parent nodes for the next iteration\n\n    # Set node attributes for the graph\n    nx.set_node_attributes(graph, node_pos_dic, NODE_COORDINATE_KEY)\n\n    # Create a SkeletonGraph from the graph\n    skeleton_graph = SkeletonGraph.from_graph(\n        graph, EDGE_COORDINATES_KEY, NODE_COORDINATE_KEY\n    )\n    return skeleton_graph\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_toy_graph_symmetric_branch_angle(num_nodes)","title":"<code>num_nodes</code>","text":"(<code>int</code>)           \u2013            <p>The total number of nodes in the graph.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_toy_graph_symmetric_branch_angle(angle)","title":"<code>angle</code>","text":"(<code>float</code>, default:                   <code>72</code> )           \u2013            <p>The angle in degrees between branches at each node. Default is 72 degrees, which corresponds to a 5-fold symmetry.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.generate_toy_graph_symmetric_branch_angle(edge_length)","title":"<code>edge_length</code>","text":"(<code>int</code>, default:                   <code>20</code> )           \u2013            <p>The length of the start edge in the graph. Each generation shrinks by 80%. Default is 20.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.make_skeleton_blur_image","title":"make_skeleton_blur_image","text":"<pre><code>make_skeleton_blur_image(skeleton_image: ndarray, dilation_size: float, gaussian_size: float) -&gt; ndarray\n</code></pre> <p>Create a blurred skeleton image from a binary skeleton image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Blurred skeleton image, where the skeleton voxels have a value of 1, and the background is normalized to 0.</p> </li> </ul> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def make_skeleton_blur_image(\n    skeleton_image: np.ndarray, dilation_size: float, gaussian_size: float\n) -&gt; np.ndarray:\n    \"\"\"Create a blurred skeleton image from a binary skeleton image.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        Binary image where the skeleton is represented by non-zero values.\n        Should be a 3D array.\n    dilation_size : float\n        Size of the structuring element used for dilation.\n        This controls how much the skeleton is dilated before blurring.\n    gaussian_size : float\n        Standard deviation for the Gaussian filter used for blurring.\n        This controls the amount of blurring applied to the skeleton.\n\n    Returns\n    -------\n    np.ndarray\n        Blurred skeleton image, where the skeleton voxels have a value of 1,\n        and the background is normalized to 0.\n    \"\"\"\n    # make a blurred skeleton\n    dilated_skeleton = binary_dilation(skeleton_image, ball(dilation_size))\n    skeleton_blur = gaussian(dilated_skeleton, gaussian_size)\n\n    # normalize the values\n    skeleton_blur /= skeleton_blur.max()\n\n    # ensure the skeleton voxels have a value of 1\n    skeleton_coordinates = np.where(skeleton_image)\n    skeleton_blur[skeleton_coordinates] = 1\n\n    return skeleton_blur\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.make_skeleton_blur_image(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>Binary image where the skeleton is represented by non-zero values. Should be a 3D array.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.make_skeleton_blur_image(dilation_size)","title":"<code>dilation_size</code>","text":"(<code>float</code>)           \u2013            <p>Size of the structuring element used for dilation. This controls how much the skeleton is dilated before blurring.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.make_skeleton_blur_image(gaussian_size)","title":"<code>gaussian_size</code>","text":"(<code>float</code>)           \u2013            <p>Standard deviation for the Gaussian filter used for blurring. This controls the amount of blurring applied to the skeleton.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.select_points_in_bounding_box","title":"select_points_in_bounding_box","text":"<pre><code>select_points_in_bounding_box(points: ndarray, lower_left_corner: ndarray, upper_right_corner: ndarray) -&gt; ndarray\n</code></pre> <p>Select all points inside a specified axis-aligned bounding box.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>points_in_box</code> (              <code>ndarray</code> )          \u2013            <p>The n x d array containing the n points inside of the specified bounding box.</p> </li> </ul> Source code in <code>skeleplex/data/utils.py</code> <pre><code>def select_points_in_bounding_box(\n    points: np.ndarray,\n    lower_left_corner: np.ndarray,\n    upper_right_corner: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Select all points inside a specified axis-aligned bounding box.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        The n x d array containing the n, d-dimensional points to check.\n    lower_left_corner : np.ndarray\n        The point corresponding to the corner of the bounding box\n        with lowest coordinate values.\n    upper_right_corner : np.ndarray\n        The point corresponding to the corner of the bounding box\n        with the highest coordinate values.\n\n    Returns\n    -------\n    points_in_box : np.ndarray\n        The n x d array containing the n points inside of the\n        specified bounding box.\n    \"\"\"\n    in_box_mask = np.all(\n        np.logical_and(lower_left_corner &lt;= points, upper_right_corner &gt;= points),\n        axis=1,\n    )\n    return points[in_box_mask]\n</code></pre>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.select_points_in_bounding_box(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>The n x d array containing the n, d-dimensional points to check.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.select_points_in_bounding_box(lower_left_corner)","title":"<code>lower_left_corner</code>","text":"(<code>ndarray</code>)           \u2013            <p>The point corresponding to the corner of the bounding box with lowest coordinate values.</p>"},{"location":"reference/skeleplex/data/utils/#skeleplex.data.utils.select_points_in_bounding_box(upper_right_corner)","title":"<code>upper_right_corner</code>","text":"(<code>ndarray</code>)           \u2013            <p>The point corresponding to the corner of the bounding box with the highest coordinate values.</p>"},{"location":"reference/skeleplex/data/y_junctions/","title":"y_junctions","text":""},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions","title":"skeleplex.data.y_junctions","text":"<p>Functions:</p> <ul> <li> <code>generate_y_junction</code>             \u2013              <p>Generate a Y-junction structure in a 3D skeleton image.</p> </li> <li> <code>random_parameters_y_junctions</code>             \u2013              <p>Generate random parameters for Y-junction generation.</p> </li> </ul>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction","title":"generate_y_junction","text":"<pre><code>generate_y_junction(length_parent: int, length_d1: int, length_d2: int, radius_parent: int, radius_d1: int, radius_d2: int, d1_angle: float, d2_angle: float, wiggle_factor: float = 0.022, noise_magnitude: float = 5, ellipse_ratio: float | None = None, dilation_size: int = 4, use_gpu: bool = True, seed: int = 42)\n</code></pre> <p>Generate a Y-junction structure in a 3D skeleton image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>skeleton</code> (              <code>ndarray</code> )          \u2013            <p>A 3D numpy array representing the generated Y-junction structure.</p> </li> </ul> Source code in <code>skeleplex/data/y_junctions.py</code> <pre><code>def generate_y_junction(\n    length_parent: int,\n    length_d1: int,\n    length_d2: int,\n    radius_parent: int,\n    radius_d1: int,\n    radius_d2: int,\n    d1_angle: float,\n    d2_angle: float,\n    wiggle_factor: float = 0.022,\n    noise_magnitude: float = 5,\n    ellipse_ratio: float | None = None,\n    dilation_size: int = 4,\n    use_gpu: bool = True,\n    seed: int = 42,\n):\n    \"\"\"Generate a Y-junction structure in a 3D skeleton image.\n\n    Parameters\n    ----------\n    length_parent : int\n        Length of the parent branch.\n    length_d1 : int\n        Length of the first daughter branch.\n    length_d2 : int\n        Length of the second daughter branch.\n    radius_parent : int\n        Radius of the parent branch.\n    radius_d1 : int\n        Radius of the first daughter branch.\n    radius_d2 : int\n        Radius of the second daughter branch.\n    d1_angle : float cecc\n        Angle of the first daughter branch relative to the parent branch in degrees.\n    d2_angle : float\n        Angle of the second daughter branch relative to the parent branch in degrees.\n    wiggle_factor : float, optional\n        Factor to control the amount of wiggle in the branches.\n        Default is 0.022.\n    noise_magnitude : float, optional\n        Magnitude of noise to add to the surface of the branches.\n        Default is 5.\n    ellipse_ratio : float, optional\n        Ratio of the radii of the elliptic cylinder segments.\n        If None, the branches will be cylindrical.\n        Default is None.\n    dilation_size : int, optional\n        Size of the dilation applied to the skeleton image.\n        Default is 4.\n    use_gpu : bool, optional\n        Whether to use GPU acceleration for distance transform computation.\n        Default is True.\n    seed : int, optional\n        Seed for random number generation.\n        Default is 42.\n\n    Returns\n    -------\n    skeleton : np.ndarray\n        A 3D numpy array representing the generated Y-junction structure.\n    \"\"\"\n    seed_gen = np.random.default_rng(seed)\n    # Initialize the transformation matrices for the angles\n    theta = np.radians(d1_angle)\n    iota = np.radians(d2_angle)\n    M = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n    N = np.array([[np.cos(iota), -np.sin(iota)], [np.sin(iota), np.cos(iota)]])\n    max_radius = max(radius_parent, radius_d1, radius_d2)\n    max_length = length_parent + np.max([length_d1, length_d2])\n    skeleton = np.zeros([max_length] * 3, dtype=np.uint8)\n    skeleton = np.pad(\n        skeleton, pad_width=max_radius * 2, mode=\"constant\", constant_values=0\n    )\n    branch = skeleton.copy()\n\n    # Draw the main branch\n    origin = np.array(\n        [skeleton.shape[0] // 2, max_radius * 2]\n    )  # Start at the middle of the image\n    p1 = origin + np.array([0, length_parent])\n\n    # translate parent vector\n    parent_vector = p1 - origin\n\n    # rotate parent unit vector\n    d1 = M @ parent_vector\n    d1 = unit_vector(d1) * length_d1\n    d1 = p1 + d1\n\n    d2 = N @ parent_vector\n    d2 = unit_vector(d2) * length_d2\n    d2 = p1 + d2\n\n    # transform to 3D\n    origin = np.array([origin[0], origin[1], skeleton.shape[2] // 2])\n    p1 = np.array([p1[0], p1[1], skeleton.shape[2] // 2])\n    d1 = np.array([d1[0], d1[1], skeleton.shape[2] // 2])\n    d2 = np.array([d2[0], d2[1], skeleton.shape[2] // 2])\n\n    # rotate d2 around y axis\n    d2_angle_z = np.radians(seed_gen.uniform(-90, 90))\n    d2_pivot = d2 - p1\n    rotation_matrix = np.array(\n        [\n            [np.cos(d2_angle_z), 0, np.sin(d2_angle_z)],\n            [0, 1, 0],\n            [-np.sin(d2_angle_z), 0, np.cos(d2_angle_z)],\n        ]\n    )\n    d2 = rotation_matrix @ d2_pivot\n    d2 = d2 + p1\n\n    # get wiggle axis\n    axis = seed_gen.integers(0, 3)\n\n    for i, line in enumerate([[origin, p1], [p1, d1], [p1, d2]]):\n        radius = [radius_parent, radius_d1, radius_d2][i]\n        # Draw the line segments with wiggle\n        draw_line_segment_wiggle(\n            line[0], line[1], skeleton, wiggle_factor=wiggle_factor, axis=axis\n        )\n        # Draw the cylinders for the branches\n        if not ellipse_ratio:\n            draw_wiggly_cylinder_3d(\n                branch,\n                line[0],\n                line[1],\n                radius=radius,\n                wiggle_factor=wiggle_factor,\n                axis=axis,\n            )\n        else:\n            # Draw an elliptic cylinder segment\n            draw_elliptic_cylinder_segment(\n                branch, line[0], line[1], rx=radius, ry=radius / ellipse_ratio\n            )\n\n    # dilute the tips\n    if not ellipse_ratio:\n        for i, point in enumerate([origin, d1, d2]):\n            r_tip = [radius_parent, radius_d1, radius_d2][i]\n            draw_ellipsoid_at_point(\n                branch,\n                point,\n                radii=(\n                    r_tip * seed_gen.uniform(1.01, 1.3),\n                    r_tip * seed_gen.uniform(1.01, 1.3),\n                    r_tip * seed_gen.uniform(1.01, 1.3),\n                ),\n            )\n\n    branch_noisey = add_noise_to_image_surface(branch, noise_magnitude=noise_magnitude)\n\n    # crop to content\n    branch_noisey, skeleton = crop_to_content(branch_noisey, skeleton)\n\n    branch_noisey_dask = da.from_array(branch_noisey, chunks=(100, 100, 100))\n    depth = np.min([*list(branch_noisey_dask.shape), 30])\n    if use_gpu:\n        distance_field = da.map_overlap(\n            local_normalized_distance_gpu,\n            branch_noisey_dask,\n            max_ball_radius=30,\n            depth=depth,\n        ).compute()\n    else:\n        distance_field = da.map_overlap(\n            local_normalized_distance,\n            branch_noisey_dask,\n            max_ball_radius=30,\n            depth=depth,\n        ).compute()\n\n    distance_field[distance_field == 1] = 0  # remove hot pixels\n\n    skeletonization_blur = make_skeleton_blur_image(\n        skeleton,\n        dilation_size=dilation_size,\n        gaussian_size=1.5,\n    )\n    skeletonization_target = skeletonization_blur &gt; 0.7\n    skeletonization_target = skeletonization_target.astype(int)\n    skeletonization_target += branch_noisey\n\n    return skeletonization_target, distance_field\n</code></pre>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(length_parent)","title":"<code>length_parent</code>","text":"(<code>int</code>)           \u2013            <p>Length of the parent branch.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(length_d1)","title":"<code>length_d1</code>","text":"(<code>int</code>)           \u2013            <p>Length of the first daughter branch.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(length_d2)","title":"<code>length_d2</code>","text":"(<code>int</code>)           \u2013            <p>Length of the second daughter branch.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(radius_parent)","title":"<code>radius_parent</code>","text":"(<code>int</code>)           \u2013            <p>Radius of the parent branch.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(radius_d1)","title":"<code>radius_d1</code>","text":"(<code>int</code>)           \u2013            <p>Radius of the first daughter branch.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(radius_d2)","title":"<code>radius_d2</code>","text":"(<code>int</code>)           \u2013            <p>Radius of the second daughter branch.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(d1_angle)","title":"<code>d1_angle</code>","text":"(<code>float cecc</code>)           \u2013            <p>Angle of the first daughter branch relative to the parent branch in degrees.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(d2_angle)","title":"<code>d2_angle</code>","text":"(<code>float</code>)           \u2013            <p>Angle of the second daughter branch relative to the parent branch in degrees.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(wiggle_factor)","title":"<code>wiggle_factor</code>","text":"(<code>float</code>, default:                   <code>0.022</code> )           \u2013            <p>Factor to control the amount of wiggle in the branches. Default is 0.022.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(noise_magnitude)","title":"<code>noise_magnitude</code>","text":"(<code>float</code>, default:                   <code>5</code> )           \u2013            <p>Magnitude of noise to add to the surface of the branches. Default is 5.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(ellipse_ratio)","title":"<code>ellipse_ratio</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>Ratio of the radii of the elliptic cylinder segments. If None, the branches will be cylindrical. Default is None.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(dilation_size)","title":"<code>dilation_size</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Size of the dilation applied to the skeleton image. Default is 4.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(use_gpu)","title":"<code>use_gpu</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use GPU acceleration for distance transform computation. Default is True.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.generate_y_junction(seed)","title":"<code>seed</code>","text":"(<code>int</code>, default:                   <code>42</code> )           \u2013            <p>Seed for random number generation. Default is 42.</p>"},{"location":"reference/skeleplex/data/y_junctions/#skeleplex.data.y_junctions.random_parameters_y_junctions","title":"random_parameters_y_junctions","text":"<pre><code>random_parameters_y_junctions(length_parent_range: tuple[int, int] = (80, 120), length_d1_range: tuple[int, int] = (70, 100), length_d2_range: tuple[int, int] = (70, 100), radius_parent_range: tuple[int, int] = (60, 90), radius_d1_range: tuple[int, int] = (30, 55), radius_d2_range: tuple[int, int] = (30, 55), d1_angle_range: tuple[int, int] = (-90, 30), d2_angle_range: tuple[int, int] = (20, 100), wiggle_factor_range: tuple[float, float] = (0.01, 0.03), noise_magnitude_range: tuple[float, float] = (8, 25), ellipse_ratio_range: tuple[float, float] = (1.1, 1.5), dilation_size: int = 4, use_gpu: bool = False, seed: int = 42)\n</code></pre> <p>Generate random parameters for Y-junction generation.</p> Source code in <code>skeleplex/data/y_junctions.py</code> <pre><code>def random_parameters_y_junctions(\n    length_parent_range: tuple[int, int] = (80, 120),\n    length_d1_range: tuple[int, int] = (70, 100),\n    length_d2_range: tuple[int, int] = (70, 100),\n    radius_parent_range: tuple[int, int] = (60, 90),\n    radius_d1_range: tuple[int, int] = (30, 55),\n    radius_d2_range: tuple[int, int] = (30, 55),\n    d1_angle_range: tuple[int, int] = (-90, 30),\n    d2_angle_range: tuple[int, int] = (20, 100),\n    wiggle_factor_range: tuple[float, float] = (0.01, 0.03),\n    noise_magnitude_range: tuple[float, float] = (8, 25),\n    ellipse_ratio_range: tuple[float, float] = (1.1, 1.5),\n    dilation_size: int = 4,\n    use_gpu: bool = False,\n    seed: int = 42,\n):\n    \"\"\"Generate random parameters for Y-junction generation.\"\"\"\n    seed_gen = np.random.default_rng(seed)\n    length_parent = seed_gen.integers(*length_parent_range)\n    length_d1 = seed_gen.integers(*length_d1_range)\n    length_d2 = seed_gen.integers(*length_d2_range)\n    radius_parent = seed_gen.integers(*radius_parent_range)\n    radius_d1 = seed_gen.integers(*radius_d1_range)\n    radius_d2 = seed_gen.integers(*radius_d2_range)\n    d1_angle = seed_gen.uniform(*d1_angle_range)\n    d2_angle = seed_gen.uniform(*d2_angle_range)\n    wiggle_factor = seed_gen.uniform(*wiggle_factor_range)\n    noise_magnitude = seed_gen.uniform(*noise_magnitude_range)\n    # make half of them elliptic\n    ellipse_ratio = (\n        seed_gen.uniform(*ellipse_ratio_range) if seed_gen.random() &gt; 0.5 else None\n    )\n    return (\n        length_parent,\n        length_d1,\n        length_d2,\n        radius_parent,\n        radius_d1,\n        radius_d2,\n        d1_angle,\n        d2_angle,\n        wiggle_factor,\n        noise_magnitude,\n        ellipse_ratio,\n        dilation_size,\n        use_gpu,\n        seed,\n    )\n</code></pre>"},{"location":"reference/skeleplex/graph/","title":"graph","text":""},{"location":"reference/skeleplex/graph/#skeleplex.graph","title":"skeleplex.graph","text":"<p>Tools to create a graph of a skeleton.</p> <p>Modules:</p> <ul> <li> <code>break_detection</code>           \u2013            <p>Functions for detecting and fixing breaks in skeletonized segmentations.</p> </li> <li> <code>constants</code>           \u2013            <p>Constants used for interacting with the graph objects.</p> </li> <li> <code>image_to_graph</code>           \u2013            <p>Utilities to convert a skeleton image to a graph.</p> </li> <li> <code>image_to_graph_lazy</code>           \u2013            <p>Functions for creating a graph from a skeleton image using lazy computation.</p> </li> <li> <code>modify_graph</code>           \u2013            </li> <li> <code>sample</code>           \u2013            <p>Functions for sampling images using the SkeletonGraph.</p> </li> <li> <code>skeleton_graph</code>           \u2013            <p>Data class for a skeleton graph.</p> </li> <li> <code>spline</code>           \u2013            <p>Utilities for fitting and working with splines.</p> </li> <li> <code>utils</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>SkeletonGraph</code>           \u2013            <p>Data class for a skeleton graph.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph","title":"SkeletonGraph","text":"<pre><code>SkeletonGraph(graph: Graph, origin: int | None = None, image_path: str | None = None, image_key: str | None = None, voxel_size_um: float | None = None)\n</code></pre> <p>Data class for a skeleton graph.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>compute_branch_lengths</code>             \u2013              <p>Return a dictionary of edge lengths.</p> </li> <li> <code>from_graph</code>             \u2013              <p>Return a SkeletonGraph from a networkx graph.</p> </li> <li> <code>from_json_file</code>             \u2013              <p>Return a SkeletonGraph from a JSON file.</p> </li> <li> <code>from_skeleton_image</code>             \u2013              <p>Return a SkeletonGraph from a skeleton image.</p> </li> <li> <code>orient_splines</code>             \u2013              <p>Orient the splines in the graph.</p> </li> <li> <code>sample_volume_slices_from_spline</code>             \u2013              <p>Sample volume slices from the splines in the graph.</p> </li> <li> <code>sample_volume_slices_from_spline_parallel</code>             \u2013              <p>Sample volume slices from the splines in the graph in parallel.</p> </li> <li> <code>to_directed</code>             \u2013              <p>Return a directed graph from the skeleton graph.</p> </li> <li> <code>to_json_file</code>             \u2013              <p>Return a JSON representation of the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>backend</code>               (<code>str</code>)           \u2013            <p>Return the backend used to store the graph.</p> </li> <li> <code>edge_splines</code>               (<code>dict</code>)           \u2013            <p>Return a list of edge splines.</p> </li> <li> <code>edges</code>           \u2013            <p>Return a list of edges.</p> </li> <li> <code>node_coordinates</code>               (<code>dict</code>)           \u2013            <p>Return a dictionary of node coordinates.</p> </li> <li> <code>node_coordinates_array</code>               (<code>ndarray</code>)           \u2013            <p>Return a numpy array of node coordinates.</p> </li> <li> <code>nodes</code>           \u2013            <p>Return a list of nodes.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.Graph,\n    origin: int | None = None,\n    image_path: str | None = None,\n    image_key: str | None = None,\n    voxel_size_um: float | None = None,\n):\n    self.graph = graph\n    self.origin = origin\n    self.image_path = image_path\n    self.image_key = image_key\n    self.voxel_size_um = voxel_size_um\n    self.origin = origin\n    self.image_path = image_path\n    self.image_key = image_key\n    self.voxel_size_um = voxel_size_um\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The skeleton graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(origin)","title":"<code>origin</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The origin node of the graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(image_path)","title":"<code>image_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image the graph was extracted from.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key of the image in the image file.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the image in the image file. We keep the graph scaled to um for easier handling.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(origin)","title":"<code>origin</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The origin node of the graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(image_path)","title":"<code>image_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image the graph was extracted from.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key of the image in the image file.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the image in the image file. We keep the graph scaled to um for easier handling.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: str\n</code></pre> <p>Return the backend used to store the graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.edge_splines","title":"edge_splines  <code>property</code>","text":"<pre><code>edge_splines: dict\n</code></pre> <p>Return a list of edge splines.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.edges","title":"edges  <code>property</code>","text":"<pre><code>edges\n</code></pre> <p>Return a list of edges.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: dict\n</code></pre> <p>Return a dictionary of node coordinates.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.node_coordinates_array","title":"node_coordinates_array  <code>property</code>","text":"<pre><code>node_coordinates_array: ndarray\n</code></pre> <p>Return a numpy array of node coordinates.</p> <p>The array is of shape (n_nodes, n_dimensions). The order of the nodes is the same as the order of the nodes attribute.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Return a list of nodes.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.compute_branch_lengths","title":"compute_branch_lengths","text":"<pre><code>compute_branch_lengths() -&gt; dict\n</code></pre> <p>Return a dictionary of edge lengths.</p> <p>The keys of the dictionary are the edge tuples, the values are arc lengths of the fitted splines. Units will be the same as voxel scale.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def compute_branch_lengths(self) -&gt; dict:\n    \"\"\"Return a dictionary of edge lengths.\n\n    The keys of the dictionary are the edge tuples, the values are arc lengths\n    of the fitted splines. Units will be the same as voxel scale.\n    \"\"\"\n    edge_lengths = {}\n    for u, v, attr in self.graph.edges(data=True):\n        edge_lengths[(u, v)] = attr[EDGE_SPLINE_KEY].arc_length\n\n    nx.set_edge_attributes(self.graph, edge_lengths, LENGTH_KEY)\n    return edge_lengths\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph","title":"from_graph  <code>classmethod</code>","text":"<pre><code>from_graph(graph, edge_coordinate_key, node_coordinate_key, voxel_size_um: float | None = None, scale_to_um: bool = True) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a networkx graph.</p> <p>The edges and nodes need to have an attribute with the specified keys containing the coordinates of the nodes and edges as an np.ndarray. Requires edge coordinates of length greater than 4 to successfully create a spline.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_graph(\n    cls,\n    graph,\n    edge_coordinate_key,\n    node_coordinate_key,\n    voxel_size_um: float | None = None,\n    scale_to_um: bool = True,\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a networkx graph.\n\n    The edges and nodes need to have an attribute with the specified keys\n    containing the coordinates of the nodes and edges as an np.ndarray.\n    Requires edge coordinates of length greater than 4\n    to successfully create a spline.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The graph to convert to a SkeletonGraph.\n    edge_coordinate_key : str\n        The key to use for the edge coordinates.\n    node_coordinate_key : str\n        The key to use for the node coordinates.\n    voxel_size_um : float | None\n        Spacing of the voxels. Used to transform graph coordinates to um.\n    scale_to_um : bool\n        Whether to scale the coordinates to micrometers using the voxel size.\n    \"\"\"\n    graph_mod = graph.copy()\n    for _, _, attr in graph_mod.edges(data=True):\n        # attr[EDGE_COORDINATES_KEY] = attr.pop(edge_coordinate_key)\n        edge_coords = attr[edge_coordinate_key]\n        # add spline\n        if scale_to_um and voxel_size_um is not None:\n            edge_coords = edge_coords * voxel_size_um\n        attr[EDGE_COORDINATES_KEY] = edge_coords\n        spline = B3Spline.from_points(attr[EDGE_COORDINATES_KEY])\n        attr[EDGE_SPLINE_KEY] = spline\n    for _, node_data in graph_mod.nodes(data=True):\n        node_coords = node_data.pop(node_coordinate_key)\n        if scale_to_um and voxel_size_um is not None:\n            node_coords = node_coords * voxel_size_um\n        node_data[NODE_COORDINATE_KEY] = node_coords\n    return cls(graph=graph_mod, voxel_size_um=voxel_size_um)\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The graph to convert to a SkeletonGraph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(edge_coordinate_key)","title":"<code>edge_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the edge coordinates.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(node_coordinate_key)","title":"<code>node_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the node coordinates.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Spacing of the voxels. Used to transform graph coordinates to um.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_graph(scale_to_um)","title":"<code>scale_to_um</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to scale the coordinates to micrometers using the voxel size.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_json_file","title":"from_json_file  <code>classmethod</code>","text":"<pre><code>from_json_file(file_path: str)\n</code></pre> <p>Return a SkeletonGraph from a JSON file.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_json_file(cls, file_path: str):\n    \"\"\"Return a SkeletonGraph from a JSON file.\"\"\"\n    with open(file_path) as file:\n        object_dict = json.load(file, object_hook=skeleton_graph_decoder)\n    graph = nx.node_link_graph(object_dict[\"graph\"], edges=\"edges\")\n    skeleton_object = cls(graph=graph)\n    # do only if keys exist\n    if \"origin\" in object_dict:\n        skeleton_object.origin = object_dict[\"origin\"]\n    if \"image_path\" in object_dict:\n        skeleton_object.image_path = object_dict[\"image_path\"]\n    if \"image_key\" in object_dict:\n        skeleton_object.image_key = object_dict[\"image_key\"]\n    if \"voxel_size_um\" in object_dict:\n        voxel_size_um = object_dict[\"voxel_size_um\"]\n        if isinstance(voxel_size_um, float | int):\n            voxel_size_um = (voxel_size_um, voxel_size_um, voxel_size_um)\n        skeleton_object.voxel_size_um = voxel_size_um\n\n    return skeleton_object\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image","title":"from_skeleton_image  <code>classmethod</code>","text":"<pre><code>from_skeleton_image(skeleton_image: ndarray, max_spline_knots: int = 10, image_voxel_size_um: float = 1) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a skeleton image.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_skeleton_image(\n    cls,\n    skeleton_image: np.ndarray,\n    max_spline_knots: int = 10,\n    image_voxel_size_um: float = 1,\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a skeleton image.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        The skeleton image to convert to a graph.\n    max_spline_knots : int\n        The maximum number of knots to use for the spline fit to the branch path.\n        If the number of data points in the branch is less than this number,\n        the spline will use n_data_points - 1 knots.\n        See the splinebox Spline class docs for more information.\n    image_voxel_size_um  : float or array of float\n        Spacing of the voxels. Used to transform graph coordinates to um.\n    \"\"\"\n    graph = image_to_graph_skan(\n        skeleton_image=skeleton_image,\n        max_spline_knots=max_spline_knots,\n        image_voxel_size_um=image_voxel_size_um,\n    )\n    return cls(graph=graph)\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton image to convert to a graph.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image(max_spline_knots)","title":"<code>max_spline_knots</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of knots to use for the spline fit to the branch path. If the number of data points in the branch is less than this number, the spline will use n_data_points - 1 knots. See the splinebox Spline class docs for more information.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.from_skeleton_image(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Spacing of the voxels. Used to transform graph coordinates to um.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.orient_splines","title":"orient_splines","text":"<pre><code>orient_splines(approximate_positions: bool = False) -&gt; DiGraph\n</code></pre> <p>Orient the splines in the graph.</p> <p>This modifies the graph in place.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def orient_splines(self, approximate_positions: bool = False) -&gt; nx.DiGraph:\n    \"\"\"Orient the splines in the graph.\n\n    This modifies the graph in place.\n\n    Parameters\n    ----------\n    approximate_positions : bool\n        Whether to use approximate positions for the spline evaluation.\n        This is faster but less accurate. Default is False.\n    \"\"\"\n    self.graph = orient_splines(\n        self.graph, approximate_positions=approximate_positions\n    )\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.orient_splines(approximate_positions)","title":"<code>approximate_positions</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use approximate positions for the spline evaluation. This is faster but less accurate. Default is False.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline","title":"sample_volume_slices_from_spline","text":"<pre><code>sample_volume_slices_from_spline(volume: ndarray, slice_spacing: float, slice_size_um: float, sample_grid_spacing_um: float, interpolation_order: int = 3, max_generation: int | None = None, segmentation: ndarray | None = None, approx: bool = False)\n</code></pre> <p>Sample volume slices from the splines in the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of image slices.</p> </li> <li> <code>Optional</code> (              <code>tuple(dict, dict)</code> )          \u2013            <p>A tuple of dictionaries of image and segmentation slices. Only if segmentation is not None.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_volume_slices_from_spline(\n    self,\n    volume: np.ndarray,\n    slice_spacing: float,\n    slice_size_um: float,\n    sample_grid_spacing_um: float,\n    interpolation_order: int = 3,\n    max_generation: int | None = None,\n    segmentation: np.ndarray | None = None,\n    approx: bool = False,\n):\n    \"\"\"Sample volume slices from the splines in the graph.\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        The volume to sample slices from.\n    slice_spacing : float\n        The spacing between slices. Normalized between 0 and 1.\n    slice_size_um : float\n        The edge length of the slices in microns.\n        The slice is square.\n    sample_grid_spacing_um : float\n        The spacing of the sample points in microns.\n        This is the size of the pixels in microns in the resulting slices.\n    interpolation_order : int\n        The order of the interpolation to use for the spline.\n        For labels use 0\n    max_generation : int\n        The maximum generation of the spline to sample.\n        If None, all levels are sampled.\n    segmentation : np.ndarray | None\n        The segmentation to sample slices from.\n        If None, only the image is sampled.\n    approx : bool\n        If True, use a quick conversion from normalized arc length\n        coordinates to spline parameter coordinates.\n        The more evenly spaced the spline knots are, the more accurate this\n        approximation becomes.\n        If False, use a binary search to find the parameterized arc length\n        that corresponds to the normalized arc length coordinates.\n        Default value is False.\n\n    Returns\n    -------\n    dict\n        A dictionary of image slices.\n\n    Optional: tuple(dict, dict)\n        A tuple of dictionaries of image and segmentation slices.\n        Only if segmentation is not None.\n\n    \"\"\"\n    image_voxel_size_um = self.voxel_size_um\n\n    origin = self.origin\n    if not origin and origin != 0:\n        raise ValueError(\"No origin node provided. Please set origin.\")\n\n    if image_voxel_size_um is None:\n        logger.warning(\"No voxel size provided. Assuming pixel size is 1 \u00b5m.\")\n        image_voxel_size_um = (1, 1, 1)\n\n    graph = self.graph.copy()\n    generation_dict = nx.get_edge_attributes(graph, GENERATION_KEY)\n    spline_dict = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n\n    image_slice_dict = {}\n    segmentation_slice_dict = {}\n\n    for u, v in nx.breadth_first_search.bfs_edges(graph, source=origin):\n        logger.info(f\"Sampling slices from edge ({u}, {v})\")\n\n        if max_generation and (generation_dict[(u, v)] &gt;= max_generation):\n            break\n        spline = spline_dict[(u, v)]\n        positions = np.linspace(0.1, 0.9, np.ceil(1 / slice_spacing).astype(int))\n        image_slice = spline.sample_volume_2d(\n            volume,\n            positions,\n            grid_shape_um=(slice_size_um, slice_size_um),\n            grid_spacing_um=(sample_grid_spacing_um, sample_grid_spacing_um),\n            sample_interpolation_order=interpolation_order,\n            image_voxel_size_um=image_voxel_size_um,\n            approx=approx,\n        )\n        image_slice_dict[(u, v)] = image_slice\n\n        if segmentation is not None:\n            segmentation_slice = spline.sample_volume_2d(\n                segmentation,\n                positions,\n                grid_shape_um=(slice_size_um, slice_size_um),\n                grid_spacing_um=(sample_grid_spacing_um, sample_grid_spacing_um),\n                sample_interpolation_order=0,\n                image_voxel_size_um=image_voxel_size_um,\n                approx=approx,\n            )\n            segmentation_slice_dict[(u, v)] = segmentation_slice\n\n    if segmentation is not None:\n        return image_slice_dict, segmentation_slice_dict\n    else:\n        return image_slice_dict\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The volume to sample slices from.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(slice_spacing)","title":"<code>slice_spacing</code>","text":"(<code>float</code>)           \u2013            <p>The spacing between slices. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(slice_size_um)","title":"<code>slice_size_um</code>","text":"(<code>float</code>)           \u2013            <p>The edge length of the slices in microns. The slice is square.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(sample_grid_spacing_um)","title":"<code>sample_grid_spacing_um</code>","text":"(<code>float</code>)           \u2013            <p>The spacing of the sample points in microns. This is the size of the pixels in microns in the resulting slices.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the interpolation to use for the spline. For labels use 0</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(max_generation)","title":"<code>max_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(segmentation)","title":"<code>segmentation</code>","text":"(<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The segmentation to sample slices from. If None, only the image is sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a quick conversion from normalized arc length coordinates to spline parameter coordinates. The more evenly spaced the spline knots are, the more accurate this approximation becomes. If False, use a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates. Default value is False.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel","title":"sample_volume_slices_from_spline_parallel","text":"<pre><code>sample_volume_slices_from_spline_parallel(volume_path: Array, slice_spacing: float, slice_size_um: float, sample_grid_spacing_um: float, interpolation_order: int = 3, max_generation: int | None = None, min_generation: int | None = None, segmentation_path: Array | None = None, num_workers: int = cpu_count() - 2, approx: bool = False)\n</code></pre> <p>Sample volume slices from the splines in the graph in parallel.</p> <p>Loads volume and segmentation data lazily and processes edges in parallel.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_volume_slices_from_spline_parallel(\n    self,\n    volume_path: da.Array,\n    slice_spacing: float,\n    slice_size_um: float,\n    sample_grid_spacing_um: float,\n    interpolation_order: int = 3,\n    max_generation: int | None = None,\n    min_generation: int | None = None,\n    segmentation_path: da.Array | None = None,\n    num_workers: int = os.cpu_count() - 2,\n    approx: bool = False,\n):\n    \"\"\"Sample volume slices from the splines in the graph in parallel.\n\n    Loads volume and segmentation data lazily and processes edges in parallel.\n\n    Parameters\n    ----------\n    volume_path : str\n        The volume path to sample slices from.\n        Must be path to a zarr file. Otherwise its not pickleable.\n    slice_spacing : float\n        The spacing between slices. Normalized between 0 and 1.\n    slice_size_um : int\n        The edge length slices in microns. The slices are square.\n    sample_grid_spacing_um : float\n        The spacing of the sample points in microns.\n        This is the size of the pixels in microns in the resulting slices.\n    interpolation_order : int\n        The order of the interpolation to use for the spline.\n        For labels use 0\n    max_generation : int\n        The maximum generation of the spline to sample.\n        If None, all levels are sampled.\n    min_generation : int\n        The minimum generation of the spline to sample.\n        If None, all levels are sampled.\n    segmentation_path : str | None\n        The segmentation path to sample slices from.\n        Must be path to a zarr file. Otherwise its not pickleable.\n        If None, only the image is sampled.\n    num_workers : int\n        The number of workers to use for parallel processing.\n        Defaults to the number of CPU cores minus 2.\n    approx : bool\n        If True, use the approximate spline evaluation.\n        If False, use the exact spline evaluation.\n\n    \"\"\"\n    image_voxel_size_um = self.voxel_size_um\n    origin = self.origin\n    if not origin and origin != 0:\n        raise ValueError(\"No origin node provided. Please set origin.\")\n\n    if image_voxel_size_um is None:\n        logger.warning(\"No voxel size provided. Assuming pixel size is 1 \u00b5m.\")\n        image_voxel_size_um = (1, 1, 1)\n\n    generation_dict = nx.get_edge_attributes(self.graph, GENERATION_KEY)\n    spline_dict = nx.get_edge_attributes(self.graph, EDGE_SPLINE_KEY)\n\n    # Prepare a list of edges to process\n    edges_to_process = [\n        (u, v)\n        for u, v in nx.breadth_first_search.bfs_edges(self.graph, source=origin)\n        if (max_generation is None or generation_dict[(u, v)] &lt;= max_generation)\n        and (min_generation is None or generation_dict[(u, v)] &gt; min_generation)\n    ]\n\n    # Define a function to process each edge,\n    # needs to be local to be pickable, required for laziness\n    def process_edge(edge):\n        u, v = edge\n        spline = spline_dict[(u, v)]\n        positions = np.linspace(0.1, 0.9, np.ceil(1 / slice_spacing).astype(int))\n        return sample_slices_for_edge(\n            u,\n            v,\n            spline,\n            volume_path,\n            segmentation_path,\n            positions,\n            slice_size_um,\n            sample_grid_spacing_um,\n            interpolation_order,\n            image_voxel_size_um,\n            approx,\n        )\n\n    # Use Dask delayed to process edges in parallel\n    tasks = [delayed(process_edge)(edge) for edge in edges_to_process]\n\n    # Compute all tasks in parallel\n    logger.info(f\"Processing {len(tasks)} edges in parallel.\")\n    with ProgressBar():\n        results = dask.compute(\n            *tasks, num_workers=num_workers, scheduler=\"processes\"\n        )\n\n    # Combine results into dictionaries\n    image_slice_dict = {}\n    segmentation_slice_dict = {}\n\n    for result in results:\n        (u, v), image_slice, segmentation_slice = result\n        image_slice_dict[(u, v)] = image_slice\n        if segmentation_path is not None:\n            segmentation_slice_dict[(u, v)] = segmentation_slice\n    if segmentation_path is not None:\n        return (\n            image_slice_dict,\n            segmentation_slice_dict,\n        )\n    return image_slice_dict\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(volume_path)","title":"<code>volume_path</code>","text":"(<code>str</code>)           \u2013            <p>The volume path to sample slices from. Must be path to a zarr file. Otherwise its not pickleable.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(slice_spacing)","title":"<code>slice_spacing</code>","text":"(<code>float</code>)           \u2013            <p>The spacing between slices. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(slice_size_um)","title":"<code>slice_size_um</code>","text":"(<code>int</code>)           \u2013            <p>The edge length slices in microns. The slices are square.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(sample_grid_spacing_um)","title":"<code>sample_grid_spacing_um</code>","text":"(<code>float</code>)           \u2013            <p>The spacing of the sample points in microns. This is the size of the pixels in microns in the resulting slices.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the interpolation to use for the spline. For labels use 0</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(max_generation)","title":"<code>max_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(min_generation)","title":"<code>min_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The minimum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(segmentation_path)","title":"<code>segmentation_path</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The segmentation path to sample slices from. Must be path to a zarr file. Otherwise its not pickleable. If None, only the image is sampled.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(num_workers)","title":"<code>num_workers</code>","text":"(<code>int</code>, default:                   <code>cpu_count() - 2</code> )           \u2013            <p>The number of workers to use for parallel processing. Defaults to the number of CPU cores minus 2.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use the approximate spline evaluation. If False, use the exact spline evaluation.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.to_directed","title":"to_directed","text":"<pre><code>to_directed(origin: int) -&gt; DiGraph\n</code></pre> <p>Return a directed graph from the skeleton graph.</p> <p>The directed graph has the same nodes and edges as the skeleton graph. Stores the origin node as an attribute.</p> <p>The directed graph is stored in-place.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_directed(self, origin: int) -&gt; nx.DiGraph:\n    \"\"\"Return a directed graph from the skeleton graph.\n\n    The directed graph has the same nodes and edges as the skeleton graph.\n    Stores the origin node as an attribute.\n\n    The directed graph is stored in-place.\n\n    Parameters\n    ----------\n    origin : int\n        The node to use as the origin node for the directed graph.\n        The origin node will have no incoming edges.\n    \"\"\"\n    self.graph = make_graph_directed(self.graph, origin)\n    self.origin = origin\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.to_directed(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The node to use as the origin node for the directed graph. The origin node will have no incoming edges.</p>"},{"location":"reference/skeleplex/graph/#skeleplex.graph.SkeletonGraph.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(file_path: str)\n</code></pre> <p>Return a JSON representation of the graph.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_json_file(self, file_path: str):\n    \"\"\"Return a JSON representation of the graph.\"\"\"\n    graph_dict = nx.node_link_data(self.graph, edges=\"edges\")\n    # if one of the attributes is not None, add it to the dict\n    # if not add a placeholder\n\n    object_dict = {\n        \"graph\": graph_dict,\n        \"origin\": self.origin,\n        \"image_path\": self.image_path,\n        \"image_key\": self.image_key,\n        \"voxel_size_um\": self.voxel_size_um,\n    }\n\n    with open(file_path, \"w\") as file:\n        json.dump(object_dict, file, indent=2, default=skeleton_graph_encoder)\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/","title":"break_detection","text":""},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection","title":"skeleplex.graph.break_detection","text":"<p>Functions for detecting and fixing breaks in skeletonized segmentations.</p> <p>This module provides utilities to prune short branches and iteratively fix breaks in skeletons, using KDTree-based proximity search and background intersection checks.</p> <p>Functions:</p> <ul> <li> <code>check_background_intersection</code>             \u2013              <p>Check if a line segment intersects background in a label image.</p> </li> <li> <code>filter_points_from_same_branch</code>             \u2013              <p>Filter points that are on the same branch as the start point.</p> </li> <li> <code>find_breaks_in_skeleton</code>             \u2013              <p>Find breaks in a skeleton and suggest connections to fix them.</p> </li> <li> <code>find_missing_branches</code>             \u2013              <p>Find the nearest points in a segmentation for given start points.</p> </li> <li> <code>find_missing_branches_angle</code>             \u2013              <p>Find the nearest and straightest points in a segmentation for given start points.</p> </li> <li> <code>find_nearest_and_straightest_point_in_segmentation</code>             \u2013              <p>Find the nearest and straightest point in a segmentation for a given start point.</p> </li> <li> <code>find_nearest_point_in_segmentation</code>             \u2013              <p>Find the nearest point in a segmentation for a given start point.</p> </li> <li> <code>prune_and_fix_skeleton</code>             \u2013              <p>Iteratively prunes short branches and fixes breaks in a skeleton until none remain.</p> </li> <li> <code>unit_vector_numba</code>             \u2013              <p>Compute the unit vector of a given vector.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.check_background_intersection","title":"check_background_intersection","text":"<pre><code>check_background_intersection(start_point: ndarray, end_point: ndarray, label_image: ndarray, skeleton_label_image: ndarray, step_size: float) -&gt; tuple[bool, float]\n</code></pre> <p>Check if a line segment intersects background in a label image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>intersects_background</code> (              <code>bool</code> )          \u2013            <p>True if the line segment intersects background, False otherwise.</p> </li> <li> <code>line_length</code> (              <code>float</code> )          \u2013            <p>The length of the line segment.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(nopython=True, fastmath=True, cache=True, nogil=True)\ndef check_background_intersection(\n    start_point: np.ndarray,\n    end_point: np.ndarray,\n    label_image: np.ndarray,\n    skeleton_label_image: np.ndarray,\n    step_size: float,\n) -&gt; tuple[bool, float]:\n    \"\"\"Check if a line segment intersects background in a label image.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (3,) array containing the starting point of the line segment.\n    end_point : np.ndarray\n        (3,) array containing the end point of the line segment.\n    label_image : np.ndarray\n        The label image to check for background intersection.\n    skeleton_label_image : np.ndarray\n        The skeleton label image to check for branch intersection.\n    step_size : float\n        The distance between points to sample along the line segment.\n\n    Returns\n    -------\n    intersects_background : bool\n        True if the line segment intersects background, False otherwise.\n    line_length : float\n        The length of the line segment.\n    \"\"\"\n    line_length = np.linalg.norm(end_point - start_point)\n    num_points = floor(line_length / step_size)\n\n    # unit vector in the direction to check\n    unit_vector = (end_point - start_point) / line_length\n    step_vector = step_size * unit_vector\n\n    # get the branch label values for the start and end point\n    start_skeleton_value = skeleton_label_image[\n        int(start_point[0]), int(start_point[1]), int(start_point[2])\n    ]\n    end_skeleton_value = skeleton_label_image[\n        int(end_point[0]), int(end_point[1]), int(end_point[2])\n    ]\n\n    for step_index in range(num_points):\n        query_point = start_point + step_index * step_vector\n        label_value = label_image[\n            int(query_point[0]), int(query_point[1]), int(query_point[2])\n        ]\n        skeleton_value = skeleton_label_image[\n            int(query_point[0]), int(query_point[1]), int(query_point[2])\n        ]\n        if label_value == 0:\n            # line intersects background\n            return False, line_length\n        if not (\n            (skeleton_value == 0)\n            or (skeleton_value == start_skeleton_value)\n            or (skeleton_value == end_skeleton_value)\n        ):\n            # line intersects a different branch\n            return False, line_length\n\n    return True, line_length\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.check_background_intersection(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array containing the starting point of the line segment.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.check_background_intersection(end_point)","title":"<code>end_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array containing the end point of the line segment.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.check_background_intersection(label_image)","title":"<code>label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The label image to check for background intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.check_background_intersection(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.check_background_intersection(step_size)","title":"<code>step_size</code>","text":"(<code>float</code>)           \u2013            <p>The distance between points to sample along the line segment.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.filter_points_from_same_branch","title":"filter_points_from_same_branch","text":"<pre><code>filter_points_from_same_branch(start_point: ndarray, query_points: ndarray, skeleton_label_image: ndarray) -&gt; ndarray\n</code></pre> <p>Filter points that are on the same branch as the start point.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(m,) boolean array where True indicates the point is on a different branch.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(nopython=True, fastmath=True, cache=True)\ndef filter_points_from_same_branch(\n    start_point: np.ndarray, query_points: np.ndarray, skeleton_label_image: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Filter points that are on the same branch as the start point.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (3,) array of the coordinates of the start point.\n    query_points : np.ndarray\n        (m, 3) array of the coordinates of the points to check.\n    skeleton_label_image : np.ndarray\n        The skeleton label image to check for branch intersection.\n\n    Returns\n    -------\n    np.ndarray\n        (m,) boolean array where True indicates the point is on a different branch.\n    \"\"\"\n    start_point_label_value = skeleton_label_image[\n        int(start_point[0]), int(start_point[1]), int(start_point[2])\n    ]\n\n    # loop through the query points\n    n_query_points = query_points.shape[0]\n    point_in_different_branch = np.zeros((n_query_points,), bool_)\n    for query_point_index in range(n_query_points):\n        query_label_value = skeleton_label_image[\n            int(query_points[query_point_index, 0]),\n            int(query_points[query_point_index, 1]),\n            int(query_points[query_point_index, 2]),\n        ]\n        if query_label_value == start_point_label_value:\n            point_in_different_branch[query_point_index] = False\n        else:\n            point_in_different_branch[query_point_index] = True\n\n    return point_in_different_branch\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.filter_points_from_same_branch(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array of the coordinates of the start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.filter_points_from_same_branch(query_points)","title":"<code>query_points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(m, 3) array of the coordinates of the points to check.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.filter_points_from_same_branch(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton","title":"find_breaks_in_skeleton","text":"<pre><code>find_breaks_in_skeleton(skeleton_obj: Skeleton, end_point_radius: float, segmentation_label_image: ndarray, skeleton_label_image: ndarray, n_workers: int = -1, include_angles=True, angle_threshold=90, weight: float = 0.5) -&gt; tuple[ndarray, ndarray, ndarray]\n</code></pre> <p>Find breaks in a skeleton and suggest connections to fix them.</p> <p>If angles are included, the function will consider the direction of existing branches when suggesting connections, preferring those that align with the branch direction. The weighting between distance and angle is currently fixed at 50/50. The points are only suggested if they do not intersect background or other branches.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>node_ids</code> (              <code>ndarray</code> )          \u2013            <p>The IDs of the nodes in the skeleton that are end points with detected breaks.</p> </li> <li> <code>source_coordinates</code> (              <code>ndarray</code> )          \u2013            <p>The coordinates of the end points with detected breaks.</p> </li> <li> <code>destination_coordinates</code> (              <code>ndarray</code> )          \u2013            <p>The coordinates of the suggested connection points to fix the breaks.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>def find_breaks_in_skeleton(\n    skeleton_obj: Skeleton,\n    end_point_radius: float,\n    segmentation_label_image: np.ndarray,\n    skeleton_label_image: np.ndarray,\n    n_workers: int = -1,\n    include_angles=True,\n    angle_threshold=90,\n    weight: float = 0.5,\n) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n    \"\"\"Find breaks in a skeleton and suggest connections to fix them.\n\n    If angles are included, the function will consider the direction of existing\n    branches when suggesting connections,\n    preferring those that align with the branch direction.\n    The weighting between distance and angle is currently fixed at 50/50.\n    The points are only suggested if they do not intersect background or other branches.\n\n\n    Parameters\n    ----------\n    skeleton_obj : Skeleton\n        The skan skeleton object to find breaks in.\n    end_point_radius : float\n        The radius around each end point to search for potential connections.\n    segmentation_label_image : np.ndarray\n        The segmentation label image used to check for background intersection.\n    skeleton_label_image : np.ndarray\n        The skeleton label image used to check for branch intersection.\n    n_workers : int\n        The number of workers to use for parallel processing.\n        Default is -1 (use all available).\n    include_angles : bool\n        Whether to include angle consideration when finding breaks. Default is True.\n    angle_threshold : float\n        The maximum angle (in degrees) allowed between the existing branch direction\n        and the direction to the potential connection point.\n        Only used if include_angles is True. Default is 90.\n    weight : float\n        The weight given to distance in the combined score. Default is 0.5.\n\n    Returns\n    -------\n    node_ids : np.ndarray\n        The IDs of the nodes in the skeleton that are end points with detected breaks.\n    source_coordinates : np.ndarray\n        The coordinates of the end points with detected breaks.\n    destination_coordinates : np.ndarray\n        The coordinates of the suggested connection points to fix the breaks.\n    \"\"\"\n    # build the tree for finding points in radius\n    skeleton_coordinates = skeleton_obj.coordinates.astype(float)\n    skeleton_tree = KDTree(skeleton_obj.coordinates)\n\n    # get points proximal to end points\n    degree_1_nodes = _get_degree_1_nodes(skeleton_obj)\n\n    proximal_points = skeleton_tree.query_ball_point(\n        degree_1_nodes, r=end_point_radius, workers=n_workers\n    )\n\n    points_numba = List(np.array(indices) for indices in proximal_points)\n\n    if include_angles:\n        degree_1_nodes_ids = _get_degree_1_nodes_ids(skeleton_obj)\n        degree_1_vectors = _get_edge_vectors_degree1(skeleton_obj)\n        edge_vectors, row_indices = _vector_dict_to_array(\n            degree_1_nodes_ids, degree_1_vectors\n        )\n\n        nearest_points = find_missing_branches_angle(\n            start_points=degree_1_nodes,\n            start_point_ids=row_indices,\n            proximal_points=points_numba,\n            vector_array=edge_vectors,\n            skeleton_coordinates=skeleton_coordinates,\n            label_image=segmentation_label_image,\n            skeleton_label_image=skeleton_label_image,\n            angle_threshold=angle_threshold,\n            weight=weight,\n        )\n    else:\n        nearest_points = find_missing_branches(\n            start_points=degree_1_nodes,\n            proximal_points=points_numba,\n            skeleton_coordinates=skeleton_coordinates,\n            label_image=segmentation_label_image,\n            skeleton_label_image=skeleton_label_image,\n        )\n\n    to_join_mask = np.logical_not(np.any(np.isnan(nearest_points), axis=1))\n    source_coordinates = degree_1_nodes[to_join_mask]\n    destination_coordinates = nearest_points[to_join_mask]\n\n    # get the ids of the nodes of the source_coordinates\n    degree_1_node_ids = np.squeeze(np.argwhere(skeleton_obj.degrees == 1))\n    node_ids = degree_1_node_ids[to_join_mask]\n    return node_ids, source_coordinates, destination_coordinates\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(skeleton_obj)","title":"<code>skeleton_obj</code>","text":"(<code>Skeleton</code>)           \u2013            <p>The skan skeleton object to find breaks in.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(end_point_radius)","title":"<code>end_point_radius</code>","text":"(<code>float</code>)           \u2013            <p>The radius around each end point to search for potential connections.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(segmentation_label_image)","title":"<code>segmentation_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The segmentation label image used to check for background intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image used to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(n_workers)","title":"<code>n_workers</code>","text":"(<code>int</code>, default:                   <code>-1</code> )           \u2013            <p>The number of workers to use for parallel processing. Default is -1 (use all available).</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(include_angles)","title":"<code>include_angles</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to include angle consideration when finding breaks. Default is True.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(angle_threshold)","title":"<code>angle_threshold</code>","text":"(<code>float</code>, default:                   <code>90</code> )           \u2013            <p>The maximum angle (in degrees) allowed between the existing branch direction and the direction to the potential connection point. Only used if include_angles is True. Default is 90.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_breaks_in_skeleton(weight)","title":"<code>weight</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The weight given to distance in the combined score. Default is 0.5.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches","title":"find_missing_branches","text":"<pre><code>find_missing_branches(start_points: ndarray, proximal_points: List[ndarray], skeleton_coordinates: ndarray, label_image: ndarray, skeleton_label_image: ndarray) -&gt; ndarray\n</code></pre> <p>Find the nearest points in a segmentation for given start points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(n, 3) array of the coordinates of the nearest points.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(nopython=True, fastmath=True, cache=True, parallel=True)\ndef find_missing_branches(\n    start_points: np.ndarray,\n    proximal_points: List[np.ndarray],\n    skeleton_coordinates: np.ndarray,\n    label_image: np.ndarray,\n    skeleton_label_image: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Find the nearest points in a segmentation for given start points.\n\n    Parameters\n    ----------\n    start_points : np.ndarray\n        (n, 3) array of the coordinates of the start points.\n    proximal_points : List[np.ndarray]\n        List of arrays containing the indices of points proximal to each start point.\n    skeleton_coordinates : np.ndarray\n        (m, 3) array of the coordinates of the skeleton points.\n    label_image : np.ndarray\n        The label image to check for background intersection.\n    skeleton_label_image : np.ndarray\n        The skeleton label image to check for branch intersection.\n\n    Returns\n    -------\n    np.ndarray\n        (n, 3) array of the coordinates of the nearest points.\n    \"\"\"\n    n_proximal_points = len(proximal_points)\n\n    # loop through the start points\n    all_nearest_points = np.zeros((n_proximal_points, 3))\n    for point_index in prange(n_proximal_points):\n        points_in_radius = skeleton_coordinates[proximal_points[point_index]]\n\n        # get the start point\n        start_point = start_points[point_index]\n\n        nearest_point = find_nearest_point_in_segmentation(\n            start_point=start_point,\n            points_to_check=points_in_radius,\n            label_image=label_image,\n            skeleton_label_image=skeleton_label_image,\n        )\n        all_nearest_points[point_index, :] = nearest_point\n\n    return all_nearest_points\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches(start_points)","title":"<code>start_points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n, 3) array of the coordinates of the start points.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches(proximal_points)","title":"<code>proximal_points</code>","text":"(<code>List[ndarray]</code>)           \u2013            <p>List of arrays containing the indices of points proximal to each start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches(skeleton_coordinates)","title":"<code>skeleton_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(m, 3) array of the coordinates of the skeleton points.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches(label_image)","title":"<code>label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The label image to check for background intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle","title":"find_missing_branches_angle","text":"<pre><code>find_missing_branches_angle(start_points: ndarray, start_point_ids: ndarray, proximal_points, vector_array, skeleton_coordinates, label_image, skeleton_label_image, angle_threshold, weight: float = 0.5)\n</code></pre> <p>Find the nearest and straightest points in a segmentation for given start points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(n, 3) array of the coordinates of the nearest and straightest points.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(parallel=True, fastmath=True, cache=True)\ndef find_missing_branches_angle(\n    start_points: np.ndarray,\n    start_point_ids: np.ndarray,  # now row indices (not raw IDs)\n    proximal_points,\n    vector_array,\n    skeleton_coordinates,\n    label_image,\n    skeleton_label_image,\n    angle_threshold,\n    weight: float = 0.5,\n):\n    \"\"\"Find the nearest and straightest points in a segmentation for given start points.\n\n    Parameters\n    ----------\n    start_points : np.ndarray\n        (n, 3) array of the coordinates of the start points.\n    start_point_ids : np.ndarray\n        (n,) array of the row indices of the start points in the vector_array.\n    proximal_points : List[np.ndarray]\n        List of arrays containing the indices of points proximal to each start point.\n    vector_array : np.ndarray\n        (m, 3) array of the direction vectors for each start point.\n    skeleton_coordinates : np.ndarray\n        (p, 3) array of the coordinates of the skeleton points.\n    label_image : np.ndarray\n        The label image to check for background intersection.\n    skeleton_label_image : np.ndarray\n        The skeleton label image to check for branch intersection.\n    angle_threshold : float\n        The maximum angle (in degrees) allowed between the existing branch direction\n        and the direction to the potential connection point.\n    weight : float\n        The weight given to distance in the combined score. Default is 0.5.\n\n    Returns\n    -------\n    np.ndarray\n        (n, 3) array of the coordinates of the nearest and straightest points.\n    \"\"\"\n    n_proximal_points = len(proximal_points)\n    all_nearest_and_straight_points = np.zeros((n_proximal_points, 3), dtype=np.float32)\n\n    for point_index in prange(n_proximal_points):\n        points_in_radius = skeleton_coordinates[proximal_points[point_index]]\n\n        row_idx = start_point_ids[point_index]\n        base_vector = vector_array[row_idx]\n        start_point = start_points[point_index]\n\n        nearest_straight_point = find_nearest_and_straightest_point_in_segmentation(\n            start_point=start_point,\n            base_vector=base_vector,\n            points_to_check=points_in_radius,\n            label_image=label_image,\n            skeleton_label_image=skeleton_label_image,\n            angle_threshold=angle_threshold,\n            weight=weight,\n        )\n        all_nearest_and_straight_points[point_index, :] = nearest_straight_point\n\n    return all_nearest_and_straight_points\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(start_points)","title":"<code>start_points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n, 3) array of the coordinates of the start points.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(start_point_ids)","title":"<code>start_point_ids</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of the row indices of the start points in the vector_array.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(proximal_points)","title":"<code>proximal_points</code>","text":"(<code>List[ndarray]</code>)           \u2013            <p>List of arrays containing the indices of points proximal to each start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(vector_array)","title":"<code>vector_array</code>","text":"(<code>ndarray</code>)           \u2013            <p>(m, 3) array of the direction vectors for each start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(skeleton_coordinates)","title":"<code>skeleton_coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(p, 3) array of the coordinates of the skeleton points.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(label_image)","title":"<code>label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The label image to check for background intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(angle_threshold)","title":"<code>angle_threshold</code>","text":"(<code>float</code>)           \u2013            <p>The maximum angle (in degrees) allowed between the existing branch direction and the direction to the potential connection point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_missing_branches_angle(weight)","title":"<code>weight</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The weight given to distance in the combined score. Default is 0.5.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation","title":"find_nearest_and_straightest_point_in_segmentation","text":"<pre><code>find_nearest_and_straightest_point_in_segmentation(start_point: ndarray, base_vector: ndarray, points_to_check: ndarray, label_image: ndarray, skeleton_label_image: ndarray, angle_threshold: float = 90, weight: float = 0.5) -&gt; ndarray\n</code></pre> <p>Find the nearest and straightest point in a segmentation for a given start point.</p> <p>The function finds points that do not intersect background or other branches, and selects the one that minimizes a combined score of distance and angle to the base vector. The weighting between distance and angle is currently fixed at 50/50.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(3,) array of the coordinates of the nearest and straightest point.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(nopython=True, fastmath=True, cache=True)\ndef find_nearest_and_straightest_point_in_segmentation(\n    start_point: np.ndarray,\n    base_vector: np.ndarray,\n    points_to_check: np.ndarray,\n    label_image: np.ndarray,\n    skeleton_label_image: np.ndarray,\n    angle_threshold: float = 90,\n    weight: float = 0.5,\n) -&gt; np.ndarray:\n    \"\"\"Find the nearest and straightest point in a segmentation for a given start point.\n\n    The function finds points that do not intersect background or other branches,\n    and selects the one that minimizes a combined score of distance and angle to the\n    base vector.\n    The weighting between distance and angle is currently fixed at 50/50.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (3,) array of the coordinates of the start point.\n    base_vector : np.ndarray\n        (3,) array of the direction vector for the start point.\n    points_to_check : np.ndarray\n        (m, 3) array of the coordinates of the points to check.\n    label_image : np.ndarray\n        The label image to check for background intersection.\n    skeleton_label_image : np.ndarray\n        The skeleton label image to check for branch intersection.\n    angle_threshold : float\n        The maximum angle (in degrees) allowed between the existing branch direction\n        and the direction to the potential connection point. Default is 90.\n    weight : float\n        The weight given to distance in the combined score. Default is 0.5.\n\n    Returns\n    -------\n    np.ndarray\n        (3,) array of the coordinates of the nearest and straightest point.\n    \"\"\"\n    # get the points to query\n    points_to_query_mask = filter_points_from_same_branch(\n        start_point,\n        points_to_check,\n        skeleton_label_image,\n    )\n    points_to_query = points_to_check[points_to_query_mask]\n\n    # loop through array\n    n_query_points = points_to_query.shape[0]\n    all_intersects_background = np.zeros((n_query_points,), dtype=bool_)\n    all_distances = np.zeros((n_query_points,), dtype=float32)\n    all_angles = np.zeros((n_query_points,), dtype=float32)\n    for query_point_index in range(n_query_points):\n        query_point = points_to_query[query_point_index]\n\n        intersects_background, distance = check_background_intersection(\n            start_point=start_point,\n            end_point=query_point,\n            label_image=label_image,\n            skeleton_label_image=skeleton_label_image,\n            step_size=0.5,\n        )\n\n        # compute angle\n        query_vector = unit_vector_numba(query_point - start_point)\n        cos_angle = np.dot(base_vector, query_vector)\n        angle = np.arccos(cos_angle) * 180 / np.pi\n\n        # store the values\n        all_intersects_background[query_point_index] = intersects_background\n        all_distances[query_point_index] = distance\n        all_angles[query_point_index] = angle\n\n    # find the shortest distance that doesn't intersect background\n    if all_intersects_background.sum() == 0:\n        # return nans if no point passes the filters\n        return np.array([np.nan, np.nan, np.nan])\n    else:\n        scores = weight * (all_distances / all_distances.max()) + (1.0 - weight) * (\n            all_angles / all_angles.max()\n        )\n        best_index = np.argmin(scores[all_intersects_background])\n        # if best_index is using a large angle, return nan\n        if all_angles[all_intersects_background][best_index] &gt; angle_threshold:\n            return np.array([np.nan, np.nan, np.nan])\n        return points_to_query[all_intersects_background][best_index]\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array of the coordinates of the start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(base_vector)","title":"<code>base_vector</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array of the direction vector for the start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(points_to_check)","title":"<code>points_to_check</code>","text":"(<code>ndarray</code>)           \u2013            <p>(m, 3) array of the coordinates of the points to check.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(label_image)","title":"<code>label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The label image to check for background intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(angle_threshold)","title":"<code>angle_threshold</code>","text":"(<code>float</code>, default:                   <code>90</code> )           \u2013            <p>The maximum angle (in degrees) allowed between the existing branch direction and the direction to the potential connection point. Default is 90.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_and_straightest_point_in_segmentation(weight)","title":"<code>weight</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The weight given to distance in the combined score. Default is 0.5.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_point_in_segmentation","title":"find_nearest_point_in_segmentation","text":"<pre><code>find_nearest_point_in_segmentation(start_point: ndarray, points_to_check: ndarray, label_image: ndarray, skeleton_label_image: ndarray) -&gt; ndarray\n</code></pre> <p>Find the nearest point in a segmentation for a given start point.</p> <p>The function finds points that do not intersect background or other branches, and selects the nearest one.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(3,) array of the coordinates of the nearest point.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(nopython=True, fastmath=True, cache=True)\ndef find_nearest_point_in_segmentation(\n    start_point: np.ndarray,\n    points_to_check: np.ndarray,\n    label_image: np.ndarray,\n    skeleton_label_image: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Find the nearest point in a segmentation for a given start point.\n\n    The function finds points that do not intersect background or other branches,\n    and selects the nearest one.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (3,) array of the coordinates of the start point.\n    points_to_check : np.ndarray\n        (m, 3) array of the coordinates of the points to check.\n    label_image : np.ndarray\n        The label image to check for background intersection.\n    skeleton_label_image : np.ndarray\n        The skeleton label image to check for branch intersection.\n\n    Returns\n    -------\n    np.ndarray\n        (3,) array of the coordinates of the nearest point.\n    \"\"\"\n    # get the points to query\n    points_to_query_mask = filter_points_from_same_branch(\n        start_point,\n        points_to_check,\n        skeleton_label_image,\n    )\n    points_to_query = points_to_check[points_to_query_mask]\n\n    # loop through array\n    n_query_points = points_to_query.shape[0]\n    all_intersects_background = np.zeros((n_query_points,), dtype=bool_)\n    all_distances = np.zeros((n_query_points,), dtype=float32)\n    for query_point_index in range(n_query_points):\n        query_point = points_to_query[query_point_index]\n\n        intersects_background, distance = check_background_intersection(\n            start_point=start_point,\n            end_point=query_point,\n            label_image=label_image,\n            skeleton_label_image=skeleton_label_image,\n            step_size=0.5,\n        )\n\n        # store the values\n        all_intersects_background[query_point_index] = intersects_background\n        all_distances[query_point_index] = distance\n\n    # find the shortest distance that doesn't intersect background\n    if all_intersects_background.sum() == 0:\n        # return nans if no point passes the filters\n        return np.array([np.nan, np.nan, np.nan])\n    else:\n        shortest_distance_index = all_distances[all_intersects_background].argmin()\n        return points_to_query[all_intersects_background][shortest_distance_index]\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_point_in_segmentation(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array of the coordinates of the start point.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_point_in_segmentation(points_to_check)","title":"<code>points_to_check</code>","text":"(<code>ndarray</code>)           \u2013            <p>(m, 3) array of the coordinates of the points to check.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_point_in_segmentation(label_image)","title":"<code>label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The label image to check for background intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.find_nearest_point_in_segmentation(skeleton_label_image)","title":"<code>skeleton_label_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton label image to check for branch intersection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.prune_and_fix_skeleton","title":"prune_and_fix_skeleton","text":"<pre><code>prune_and_fix_skeleton(skeplex_skeleton, segmentation, branch_trimming_len=10, break_distance=20)\n</code></pre> <p>Iteratively prunes short branches and fixes breaks in a skeleton until none remain.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Skeleton</code>           \u2013            <p>The final pruned and fixed Skeleton object.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>def prune_and_fix_skeleton(\n    skeplex_skeleton, segmentation, branch_trimming_len=10, break_distance=20\n):\n    \"\"\"\n    Iteratively prunes short branches and fixes breaks in a skeleton until none remain.\n\n    Parameters\n    ----------\n    skeplex_skeleton : ndarray\n        Binary skeleton image.\n    segmentation : ndarray\n        Segmentation image used for break detection.\n    branch_trimming_len : float\n        Maximum length of branches to prune.\n    break_distance : float\n        Maximum distance for detecting breaks.\n\n    Returns\n    -------\n    Skeleton\n        The final pruned and fixed Skeleton object.\n    \"\"\"\n    skeleton_obj = Skeleton(skeplex_skeleton)\n    total_pruned = 0\n    total_breaks_fixed = 0\n\n    while True:\n        # --- Step 1: Prune short branches ---\n        df = summarize(skeleton_obj)\n        print(\n            \"num_deg1 pre prune\",\n            len(skeleton_obj.coordinates[skeleton_obj.degrees == 1]),\n        )\n\n        short_branches = df.loc[\n            (df[\"branch-distance\"] &lt; branch_trimming_len) &amp; (df[\"branch-type\"] != 2)\n        ]\n        short_branch_indices = short_branches.index.to_list()\n\n        if short_branch_indices:\n            skeleton_obj = skeleton_obj.prune_paths(short_branch_indices)\n            total_pruned += len(short_branch_indices)\n            print(f\"{len(short_branch_indices)} branches pruned\")\n        else:\n            print(\"No short branches left to prune.\")\n        # --- Step 2: Detect and fix breaks ---\n        skeleton_label_fill = skeleton_obj.skeleton_image.copy()\n        skelplex_fill = label(skeleton_label_fill)\n\n        node_ids, source_coords, target_coords = find_breaks_in_skeleton(\n            skeleton_obj, break_distance, segmentation, skelplex_fill\n        )\n        print(f\"Found {len(node_ids)} breaks in skeleton\")\n\n        if len(node_ids) &gt; 0:\n            for source, target in zip(source_coords, target_coords, strict=False):\n                draw_line_segment(source, target, skelplex_fill)\n            total_breaks_fixed += len(node_ids)\n            skeleton_obj = Skeleton(skelplex_fill &gt; 0)  # Update skeleton\n        else:\n            print(\"No breaks found.\")\n        # --- Exit condition ---\n        if not short_branch_indices and not len(node_ids) &gt; 0:\n            print(\"Pruning and break fixing complete. \")\n            break\n\n    return skelplex_fill\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.prune_and_fix_skeleton(skeplex_skeleton)","title":"<code>skeplex_skeleton</code>","text":"(<code>ndarray</code>)           \u2013            <p>Binary skeleton image.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.prune_and_fix_skeleton(segmentation)","title":"<code>segmentation</code>","text":"(<code>ndarray</code>)           \u2013            <p>Segmentation image used for break detection.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.prune_and_fix_skeleton(branch_trimming_len)","title":"<code>branch_trimming_len</code>","text":"(<code>float</code>, default:                   <code>10</code> )           \u2013            <p>Maximum length of branches to prune.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.prune_and_fix_skeleton(break_distance)","title":"<code>break_distance</code>","text":"(<code>float</code>, default:                   <code>20</code> )           \u2013            <p>Maximum distance for detecting breaks.</p>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.unit_vector_numba","title":"unit_vector_numba","text":"<pre><code>unit_vector_numba(vector)\n</code></pre> <p>Compute the unit vector of a given vector.</p> <p>Is numba compatible.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(3,) array of the unit vector.</p> </li> </ul> Source code in <code>skeleplex/graph/break_detection.py</code> <pre><code>@jit(fastmath=True, cache=True)\ndef unit_vector_numba(vector):\n    \"\"\"Compute the unit vector of a given vector.\n\n    Is numba compatible.\n\n    Parameters\n    ----------\n    vector : np.ndarray\n        (3,) array of the vector to normalize.\n\n    Returns\n    -------\n    np.ndarray\n        (3,) array of the unit vector.\n    \"\"\"\n    norm = np.sqrt(np.sum(vector * vector))\n    if norm == 0:\n        return vector\n    return vector / norm\n</code></pre>"},{"location":"reference/skeleplex/graph/break_detection/#skeleplex.graph.break_detection.unit_vector_numba(vector)","title":"<code>vector</code>","text":"(<code>ndarray</code>)           \u2013            <p>(3,) array of the vector to normalize.</p>"},{"location":"reference/skeleplex/graph/constants/","title":"constants","text":""},{"location":"reference/skeleplex/graph/constants/#skeleplex.graph.constants","title":"skeleplex.graph.constants","text":"<p>Constants used for interacting with the graph objects.</p> <p>Generally, these are property or key names.</p>"},{"location":"reference/skeleplex/graph/image_to_graph/","title":"image_to_graph","text":""},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph","title":"skeleplex.graph.image_to_graph","text":"<p>Utilities to convert a skeleton image to a graph.</p> <p>Functions:</p> <ul> <li> <code>image_to_graph_skan</code>             \u2013              <p>Convert a skeleton image to a graph using skan.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan","title":"image_to_graph_skan","text":"<pre><code>image_to_graph_skan(skeleton_image: ndarray, max_spline_knots: int = 10, image_voxel_size_um: float = 1) -&gt; MultiGraph\n</code></pre> <p>Convert a skeleton image to a graph using skan.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/image_to_graph.py</code> <pre><code>def image_to_graph_skan(\n    skeleton_image: np.ndarray,\n    max_spline_knots: int = 10,\n    image_voxel_size_um: float = 1,\n) -&gt; nx.MultiGraph:\n    \"\"\"Convert a skeleton image to a graph using skan.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        The image to convert to a skeleton graph.\n        The image should be a binary image and already skeletonized.\n    max_spline_knots : int\n        The maximum number of knots to use for the spline fit to the branch path.\n        If the number of data points in the branch is less than this number,\n        the spline will use n_data_points - 1 knots.\n        See the splinebox Spline class docs for more information.\n    image_voxel_size_um  : float or array of float\n        Spacing of the voxels. Used to transform graph coordinates to um.\n    \"\"\"\n    # make the skeleton\n    skeleton = SkanSkeleton(skeleton_image=skeleton_image, spacing=image_voxel_size_um)\n    summary_table = summarize(skeleton, separator=\"_\")\n\n    # get all of the nodes\n    # this might be slow - may need to speed up\n    # source_nodes = set(summary_table[\"node_id_src\"])\n    # destination_nodes = set(summary_table[\"node_id_dst\"])\n    # all_nodes = source_nodes.union(destination_nodes)\n\n    skeleton_graph = nx.MultiGraph()\n    for row in summary_table.itertuples(name=\"Edge\"):\n        # Iterate over the rows in the table.\n        # Each row is an edge in the graph\n        index = row.Index\n        i = row.node_id_src\n        j = row.node_id_dst\n\n        # fit a spline to the path\n        # todo: factor our to spline module\n        # todo: reconsider how the number of knots is set\n        spline_path = skeleton.path_coordinates(index)\n        spline_path *= image_voxel_size_um  # scale to um\n        n_points = len(spline_path)\n        if n_points &lt;= max_spline_knots:\n            n_spline_knots = n_points - 1\n            if n_spline_knots &lt;= 3:  # min for b3 spline\n                # interpolate with a line to get more knots\n                spline_path = np.linspace(\n                    spline_path[0], spline_path[-1], max_spline_knots\n                )\n                n_spline_knots = max_spline_knots - 1\n        else:\n            n_spline_knots = max_spline_knots\n        spline = B3Spline.from_points(\n            points=spline_path,\n            n_knots=n_spline_knots,\n        )\n        # Nodes are added if they don't exist so only need to add edges\n        skeleton_graph.add_edge(\n            i,\n            j,\n            **{EDGE_COORDINATES_KEY: spline_path, EDGE_SPLINE_KEY: spline},\n        )\n\n    # add the node coordinates\n    new_node_data = {}\n    for node_index, node_data in skeleton_graph.nodes(data=True):\n        node_coordinate = np.asarray(skeleton.coordinates[node_index])\n        node_coordinate *= image_voxel_size_um  # scale to um\n        node_data[NODE_COORDINATE_KEY] = node_coordinate\n        new_node_data[node_index] = node_data\n\n    nx.set_node_attributes(skeleton_graph, new_node_data)\n\n    return skeleton_graph\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The image to convert to a skeleton graph. The image should be a binary image and already skeletonized.</p>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan(max_spline_knots)","title":"<code>max_spline_knots</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of knots to use for the spline fit to the branch path. If the number of data points in the branch is less than this number, the spline will use n_data_points - 1 knots. See the splinebox Spline class docs for more information.</p>"},{"location":"reference/skeleplex/graph/image_to_graph/#skeleplex.graph.image_to_graph.image_to_graph_skan(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Spacing of the voxels. Used to transform graph coordinates to um.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/","title":"image_to_graph_lazy","text":""},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy","title":"skeleplex.graph.image_to_graph_lazy","text":"<p>Functions for creating a graph from a skeleton image using lazy computation.</p> <p>These functions are adapted from Genevieve Buckley's distributed-skeleton-analysis repo: https://github.com/GenevieveBuckley/distributed-skeleton-analysis</p> <p>Functions:</p> <ul> <li> <code>assign_unique_ids</code>             \u2013              <p>Assign a unique integer label to each skeleton voxel in a binary skeleton image.</p> </li> <li> <code>build_pixel_indices</code>             \u2013              <p>Compute global coordinates of all nonzero skeleton voxels.</p> </li> <li> <code>compute_degrees</code>             \u2013              <p>Compute the degrees image from a binary skeleton image.</p> </li> <li> <code>construct_dataframe</code>             \u2013              <p>Construct a Dask DataFrame of connected voxels from a labeled skeleton image.</p> </li> <li> <code>remove_isolated_voxels</code>             \u2013              <p>Remove isolated voxels from the skeleton image using the degrees image.</p> </li> <li> <code>skeleton_graph_func</code>             \u2013              <p>Create delayed computation to extract connections from a labeled skeleton chunk.</p> </li> <li> <code>skeleton_image_to_graph</code>             \u2013              <p>Build a NetworkX graph from a skeleton image and graph edges.</p> </li> <li> <code>slices_from_chunks_overlap</code>             \u2013              <p>Compute slices for extracting overlapping chunks from an array.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.assign_unique_ids","title":"assign_unique_ids","text":"<pre><code>assign_unique_ids(skeleton_image: Array) -&gt; tuple[Array, int]\n</code></pre> <p>Assign a unique integer label to each skeleton voxel in a binary skeleton image.</p> <p>Each foreground voxel in the skeleton is assigned a unique integer ID starting from 1 using a 3x3x3 kernel. Background voxels remain 0. This effectively enumerates all skeleton voxels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>labeled_skeleton</code> (              <code>Array</code> )          \u2013            <p>Array of same shape as skeleton_image with unique integer labels assigned to each connected component.</p> </li> <li> <code>num_features</code> (              <code>int</code> )          \u2013            <p>The total number of skeleton voxels labeled.</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def assign_unique_ids(\n    skeleton_image: da.Array,\n) -&gt; tuple[da.Array, int]:\n    \"\"\"\n    Assign a unique integer label to each skeleton voxel in a binary skeleton image.\n\n    Each foreground voxel in the skeleton is assigned a unique integer ID\n    starting from 1 using a 3x3x3 kernel. Background voxels remain 0. This\n    effectively enumerates all skeleton voxels.\n\n    Parameters\n    ----------\n    skeleton_image : dask.array.Array\n        Binary skeleton image where non-zero values indicate skeleton voxels.\n\n    Returns\n    -------\n    labeled_skeleton : dask.array.Array\n        Array of same shape as skeleton_image with unique integer labels\n        assigned to each connected component.\n    num_features : int\n        The total number of skeleton voxels labeled.\n    \"\"\"\n    ndim = skeleton_image.ndim\n    structure_kernel = np.zeros((3,) * ndim)\n    structure_kernel[(1,) * ndim] = 1\n\n    labeled_skeleton, num_features = label(\n        skeleton_image,\n        structure=structure_kernel,\n    )\n\n    return labeled_skeleton, num_features\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.assign_unique_ids(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>Array</code>)           \u2013            <p>Binary skeleton image where non-zero values indicate skeleton voxels.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.build_pixel_indices","title":"build_pixel_indices","text":"<pre><code>build_pixel_indices(skeleton_image: Array) -&gt; ndarray\n</code></pre> <p>Compute global coordinates of all nonzero skeleton voxels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of voxel coordinates with shape (N, ndim).</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def build_pixel_indices(skeleton_image: da.Array) -&gt; np.ndarray:\n    \"\"\"\n    Compute global coordinates of all nonzero skeleton voxels.\n\n    Parameters\n    ----------\n    skeleton_image : dask.array.Array\n        Binary skeleton image.\n\n    Returns\n    -------\n    np.ndarray\n        Array of voxel coordinates with shape (N, ndim).\n    \"\"\"\n\n    def extract_coords_block(block, key):\n        coords = np.argwhere(block &gt; 0)\n        if coords.size == 0:\n            return np.empty((0, block.ndim), dtype=np.int32)\n        offset = np.array([k * s for k, s in zip(key, block.shape, strict=False)])\n        return coords + offset\n\n    delayed_blocks = skeleton_image.to_delayed().flatten()\n    delayed_coords = [\n        delayed(extract_coords_block)(block, block.key[1:]) for block in delayed_blocks\n    ]\n\n    coords_list = compute(*delayed_coords)\n    all_coords = np.vstack(coords_list)\n\n    pixel_indices = np.concatenate(\n        ([np.zeros(skeleton_image.ndim)], all_coords), axis=0\n    )\n\n    return pixel_indices\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.build_pixel_indices(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>Array</code>)           \u2013            <p>Binary skeleton image.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.compute_degrees","title":"compute_degrees","text":"<pre><code>compute_degrees(skeleton_image: Array) -&gt; Array\n</code></pre> <p>Compute the degrees image from a binary skeleton image.</p> <p>This function counts, for each voxel in the skeleton, how many of its neighbors also belong to the skeleton. It performs a convolution of the binary skeleton image with a 3x3x3 kernel to compute the neighbor count.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>degrees_image</code> (              <code>Array</code> )          \u2013            <p>An image of the same shape as skeleton_image. Each foreground voxel stores the count of neighboring skeleton voxels.</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def compute_degrees(skeleton_image: da.Array) -&gt; da.Array:\n    \"\"\"\n    Compute the degrees image from a binary skeleton image.\n\n    This function counts, for each voxel in the skeleton,\n    how many of its neighbors also belong to the skeleton.\n    It performs a convolution of the binary skeleton image with\n    a 3x3x3 kernel to compute the neighbor count.\n\n    Parameters\n    ----------\n    skeleton_image : dask.array.Array\n        Binary skeleton image where non-zero values indicate skeleton voxels.\n\n    Returns\n    -------\n    degrees_image : dask.array.Array\n        An image of the same shape as skeleton_image. Each foreground voxel\n        stores the count of neighboring skeleton voxels.\n    \"\"\"\n    ndim = skeleton_image.ndim\n    degree_kernel = np.ones((3,) * ndim, dtype=np.uint8)\n    degree_kernel[(1,) * ndim] = 0\n\n    degrees_image = convolve(\n        skeleton_image.astype(np.uint8), degree_kernel, mode=\"constant\"\n    )\n\n    degrees_image = degrees_image * skeleton_image\n\n    return degrees_image\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.compute_degrees(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>Array</code>)           \u2013            <p>Binary skeleton image where non-zero values indicate skeleton voxels.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.construct_dataframe","title":"construct_dataframe","text":"<pre><code>construct_dataframe(labeled_skeleton_image: Array) -&gt; DataFrame\n</code></pre> <p>Construct a Dask DataFrame of connected voxels from a labeled skeleton image.</p> <p>This function processes a labeled skeleton image in overlapping chunks. For each chunk, it computes connections between neighboring labeled voxels and returns the combined result as a single Dask DataFrame.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>Dask DataFrame with graph edges. Columns:     - 'row': int         Label of the source voxel.     - 'col': int         Label of the neighboring target voxel.     - 'data': float         Euclidean distance between the connected voxels.</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def construct_dataframe(labeled_skeleton_image: da.Array) -&gt; dd.DataFrame:\n    \"\"\"\n    Construct a Dask DataFrame of connected voxels from a labeled skeleton image.\n\n    This function processes a labeled skeleton image in overlapping chunks.\n    For each chunk, it computes connections between neighboring labeled voxels and\n    returns the combined result as a single Dask DataFrame.\n\n    Parameters\n    ----------\n    labeled_skeleton_image : dask.array.Array\n        Labeled skeleton image where each nonzero voxel has a unique integer label.\n    overlap_depth : int, optional\n        Number of voxels to overlap between neighboring chunks\n        when extracting chunks from the array. Default is 1.\n\n    Returns\n    -------\n    dask.dataframe.DataFrame\n        Dask DataFrame with graph edges.\n        Columns:\n            - 'row': int\n                Label of the source voxel.\n            - 'col': int\n                Label of the neighboring target voxel.\n            - 'data': float\n                Euclidean distance between the connected voxels.\n    \"\"\"\n    chunk_iterator = zip(\n        np.ndindex(*labeled_skeleton_image.numblocks),\n        map(\n            functools.partial(operator.getitem, labeled_skeleton_image),\n            slices_from_chunks_overlap(\n                labeled_skeleton_image.chunks, labeled_skeleton_image.shape, depth=1\n            ),\n        ),\n        strict=False,\n    )\n\n    meta = dd.utils.make_meta(\n        [(\"row\", np.int64), (\"col\", np.int64), (\"data\", np.float64)]\n    )\n    chunk_graphs = [\n        dd.from_delayed(skeleton_graph_func(chunk), meta=meta)\n        for _, chunk in chunk_iterator\n    ]\n\n    graph_edges_ddf = dd.concat(chunk_graphs)\n    graph_edges_ddf = graph_edges_ddf.drop_duplicates()\n\n    return graph_edges_ddf\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.construct_dataframe(labeled_skeleton_image)","title":"<code>labeled_skeleton_image</code>","text":"(<code>Array</code>)           \u2013            <p>Labeled skeleton image where each nonzero voxel has a unique integer label.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.construct_dataframe(overlap_depth)","title":"<code>overlap_depth</code>","text":"(<code>int</code>)           \u2013            <p>Number of voxels to overlap between neighboring chunks when extracting chunks from the array. Default is 1.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.remove_isolated_voxels","title":"remove_isolated_voxels","text":"<pre><code>remove_isolated_voxels(skeleton_image: Array, degrees_image: Array) -&gt; Array\n</code></pre> <p>Remove isolated voxels from the skeleton image using the degrees image.</p> <p>This function removes skeleton voxels whose degree is 0, i.e. voxels that do not have any neighboring skeleton voxels.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>cleaned_skeleton</code> (              <code>Array</code> )          \u2013            <p>Binary skeleton image with isolated voxels removed.</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def remove_isolated_voxels(\n    skeleton_image: da.Array,\n    degrees_image: da.Array,\n) -&gt; da.Array:\n    \"\"\"\n    Remove isolated voxels from the skeleton image using the degrees image.\n\n    This function removes skeleton voxels whose degree is 0,\n    i.e. voxels that do not have any neighboring skeleton voxels.\n\n    Parameters\n    ----------\n    skeleton_image : dask.array.Array\n        Binary skeleton image where non-zero values indicate skeleton voxels.\n    degrees_image : dask.array.Array\n        Degrees image where each voxel stores the number of neighboring skeleton voxels.\n\n    Returns\n    -------\n    cleaned_skeleton : dask.array.Array\n        Binary skeleton image with isolated voxels removed.\n    \"\"\"\n    cleaned_skeleton = skeleton_image &amp; (degrees_image &gt; 0)\n\n    return cleaned_skeleton\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.remove_isolated_voxels(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>Array</code>)           \u2013            <p>Binary skeleton image where non-zero values indicate skeleton voxels.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.remove_isolated_voxels(degrees_image)","title":"<code>degrees_image</code>","text":"(<code>Array</code>)           \u2013            <p>Degrees image where each voxel stores the number of neighboring skeleton voxels.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_graph_func","title":"skeleton_graph_func","text":"<pre><code>skeleton_graph_func(labeled_skeleton_chunk: ndarray, spacing: float = 1) -&gt; DataFrame\n</code></pre> <p>Create delayed computation to extract connections from a labeled skeleton chunk.</p> <p>This function analyzes a chunk of a labeled skeleton image to identify connections between neighboring skeleton voxels. It constructs a DataFrame listing each pair of connected voxels and the Euclidean distance between them. The computation is delayed and only executes when explicitly computed.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Delayed</code>           \u2013            <p>A delayed computation producing a pandas DataFrame with columns:     - 'row' : int         Label of the source voxel.     - 'col' : int         Label of the neighboring target voxel.     - 'data' : float         Euclidean distance between the connected voxels.</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>@delayed\ndef skeleton_graph_func(\n    labeled_skeleton_chunk: np.ndarray, spacing: float = 1\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Create delayed computation to extract connections from a labeled skeleton chunk.\n\n    This function analyzes a chunk of a labeled skeleton image to identify\n    connections between neighboring skeleton voxels. It constructs a DataFrame\n    listing each pair of connected voxels and the Euclidean distance\n    between them. The computation is delayed and only executes when explicitly computed.\n\n    Parameters\n    ----------\n    labeled_skeleton_chunk : np.ndarray\n        A chunk of the labeled skeleton image. Each voxel contains either\n        0 or a unique positive integer label assigned to a skeleton voxel.\n    spacing : float, optional\n        Spacing between voxels in the skeleton, by default 1.\n\n    Returns\n    -------\n    dask.delayed.Delayed\n        A delayed computation producing a pandas DataFrame with columns:\n            - 'row' : int\n                Label of the source voxel.\n            - 'col' : int\n                Label of the neighboring target voxel.\n            - 'data' : float\n                Euclidean distance between the connected voxels.\n    \"\"\"\n    ndim = labeled_skeleton_chunk.ndim\n    spacing = np.ones(ndim, dtype=float) * spacing\n    num_edges = _num_edges(labeled_skeleton_chunk.astype(bool))\n    padded_chunk = np.pad(labeled_skeleton_chunk, 1)\n    steps, distances = raveled_steps_to_neighbors(\n        padded_chunk.shape, ndim, spacing=spacing\n    )\n\n    row = np.empty(num_edges, dtype=int)\n    col = np.empty(num_edges, dtype=int)\n    data = np.empty(num_edges, dtype=float)\n    _write_pixel_graph(padded_chunk, steps, distances, row, col, data)\n\n    return pd.DataFrame({\"row\": row, \"col\": col, \"data\": data})\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_graph_func(labeled_skeleton_chunk)","title":"<code>labeled_skeleton_chunk</code>","text":"(<code>ndarray</code>)           \u2013            <p>A chunk of the labeled skeleton image. Each voxel contains either 0 or a unique positive integer label assigned to a skeleton voxel.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_graph_func(spacing)","title":"<code>spacing</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Spacing between voxels in the skeleton, by default 1.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_image_to_graph","title":"skeleton_image_to_graph","text":"<pre><code>skeleton_image_to_graph(skeleton_image: Array, degrees_image: Array, graph_edges_df: DataFrame, spacing: float = 1.0, image_voxel_size_um: float = 1.0) -&gt; Graph\n</code></pre> <p>Build a NetworkX graph from a skeleton image and graph edges.</p> <p>This function constructs a NetworkX graph directly from a skeleton image, its degrees image, and the edge list DataFrame. It computes the voxel coordinates for each skeleton node and stores them as node attributes in the graph. Edge paths are attached as edge attributes.</p> <p>The node coordinates and edge path coordinates are scaled to microns using the provided image_voxel_size_um.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>nx_graph</code> (              <code>Graph</code> )          \u2013            <p>NetworkX graph representing the skeleton. - Each edge has a 'path' attribute (Nx3 array of coordinates). - Each node has a 'node_coordinate' attribute (1x3 array).</p> </li> </ul> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def skeleton_image_to_graph(\n    skeleton_image: da.Array,\n    degrees_image: da.Array,\n    graph_edges_df: pd.DataFrame,\n    spacing: float = 1.0,\n    image_voxel_size_um: float = 1.0,\n) -&gt; nx.Graph:\n    \"\"\"\n    Build a NetworkX graph from a skeleton image and graph edges.\n\n    This function constructs a NetworkX graph directly from a\n    skeleton image, its degrees image, and the edge list DataFrame.\n    It computes the voxel coordinates for each skeleton node and stores\n    them as node attributes in the graph. Edge paths are attached as\n    edge attributes.\n\n    The node coordinates and edge path coordinates are scaled to microns\n    using the provided image_voxel_size_um.\n\n    Parameters\n    ----------\n    skeleton_image : dask.array.Array\n        Binary skeleton image.\n    degrees_image : dask.array.Array\n        Degrees image indicating the number of neighbors for each voxel.\n    graph_edges_df : pandas.DataFrame\n        DataFrame of graph edges with columns: 'row', 'col', 'data'.\n    spacing : float, optional\n        Spacing between voxels. Default is 1.0.\n        This does not scale the graph to um.\n    image_voxel_size_um : float, optional\n        Spacing of the voxels. Used to transform graph coordinates to um.\n        Default is 1.0.\n\n    Returns\n    -------\n    nx_graph : networkx.Graph\n        NetworkX graph representing the skeleton.\n        - Each edge has a 'path' attribute (Nx3 array of coordinates).\n        - Each node has a 'node_coordinate' attribute (1x3 array).\n    \"\"\"\n    row = graph_edges_df[\"row\"].values\n    col = graph_edges_df[\"col\"].values\n    data = graph_edges_df[\"data\"].values\n    adj = sparse.coo_matrix((data, (row, col))).tocsr()\n\n    skel_obj = Skeleton(np.eye(3))\n    skel_obj.skeleton_image = skeleton_image\n    # this doesnt scale the coordinates\n    skel_obj.spacing = [spacing] * skeleton_image.ndim\n    skel_obj.graph = adj\n    skel_obj.degrees_image = degrees_image\n\n    skel_obj.coordinates = build_pixel_indices(skeleton_image)\n\n    nonzero_degree_values = degrees_image[degrees_image &gt; 0].compute()\n    degrees = np.concatenate(([0], nonzero_degree_values))\n    skel_obj.degrees = degrees\n\n    nbgraph = csr_to_nbgraph(adj)\n    skel_obj.nbgraph = nbgraph\n    paths = _build_skeleton_path_graph(nbgraph)\n    skel_obj.paths = paths\n    skel_obj.n_paths = paths.shape[0]\n    skel_obj._distances_initialized = False\n    skel_obj.distances = np.empty(skel_obj.n_paths, dtype=float)\n    skel_obj.path_lengths()\n\n    summary_df = summarize(skel_obj, separator=\"_\")\n\n    nx_graph = nx.Graph()\n\n    for row in summary_df.itertuples(name=\"Edge\"):\n        index = row.Index\n        node_src = row.node_id_src\n        node_dst = row.node_id_dst\n\n        # path coordinates are not scaled to voxel size.\n        # here we scale them to microns\n        edge_coords = skel_obj.path_coordinates(index)\n        edge_coords = edge_coords * image_voxel_size_um  # scale to um\n\n        if len(edge_coords) &lt;= 3:\n            edge_coords = np.insert(edge_coords, -1, edge_coords[-1] - 0.1, axis=0)\n            if len(edge_coords) &lt;= 3:\n                edge_coords = np.insert(edge_coords, -1, edge_coords[-1] - 0.01, axis=0)\n\n        if len(edge_coords) &lt; 15:\n            edge_coords = np.linspace(edge_coords[0], edge_coords[-1], 20)\n\n        nx_graph.add_edge(\n            node_src,\n            node_dst,\n            path=edge_coords,\n        )\n\n    # add node coordinates\n    for node_index in nx_graph.nodes():\n        node_coord = (\n            np.asarray(skel_obj.coordinates[node_index]) * image_voxel_size_um\n        )  # scale to um\n        nx_graph.nodes[node_index][\"node_coordinate\"] = node_coord\n\n    return nx_graph\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_image_to_graph(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>Array</code>)           \u2013            <p>Binary skeleton image.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_image_to_graph(degrees_image)","title":"<code>degrees_image</code>","text":"(<code>Array</code>)           \u2013            <p>Degrees image indicating the number of neighbors for each voxel.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_image_to_graph(graph_edges_df)","title":"<code>graph_edges_df</code>","text":"(<code>DataFrame</code>)           \u2013            <p>DataFrame of graph edges with columns: 'row', 'col', 'data'.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_image_to_graph(spacing)","title":"<code>spacing</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Spacing between voxels. Default is 1.0. This does not scale the graph to um.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.skeleton_image_to_graph(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Spacing of the voxels. Used to transform graph coordinates to um. Default is 1.0.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.slices_from_chunks_overlap","title":"slices_from_chunks_overlap","text":"<pre><code>slices_from_chunks_overlap(chunks: tuple[tuple[int, ...], ...], array_shape: tuple[int, ...], depth: int = 1) -&gt; list[tuple[slice, ...]]\n</code></pre> <p>Compute slices for extracting overlapping chunks from an array.</p> <p>Given the chunk structure of a Dask array, this function generates a list of slice tuples that define how to extract each chunk along with a border of overlapping voxels around it. The overlap is applied on all sides, except where the chunk is at the array edge.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list of tuple of slice</code>           \u2013            <p>A list of tuples of slice objects, one per chunk. Each tuple can be used to index into the array to extract that chunk plus its overlap.</p> </li> </ul> Example <p>slices_from_chunks_overlap(((4,), (7, 7)), (4, 14), depth=1) [(slice(0, 5, None), slice(0, 8, None)),  (slice(0, 5, None), slice(6, 15, None))]</p> Source code in <code>skeleplex/graph/image_to_graph_lazy.py</code> <pre><code>def slices_from_chunks_overlap(\n    chunks: tuple[tuple[int, ...], ...], array_shape: tuple[int, ...], depth: int = 1\n) -&gt; list[tuple[slice, ...]]:\n    \"\"\"\n    Compute slices for extracting overlapping chunks from an array.\n\n    Given the chunk structure of a Dask array, this function generates a list\n    of slice tuples that define how to extract each chunk along with a border\n    of overlapping voxels around it. The overlap is applied on all sides,\n    except where the chunk is at the array edge.\n\n    Parameters\n    ----------\n    chunks : tuple of tuples of int\n        The chunk sizes in each dimension, as returned by Dask's `.chunks` attribute.\n        For example: ((4,), (7, 7))\n    array_shape : tuple of int\n        Shape of the full array.\n    depth : int, optional\n        Number of voxels to include as overlap around each chunk.\n        Defaults to 1.\n\n    Returns\n    -------\n    list of tuple of slice\n        A list of tuples of slice objects, one per chunk. Each tuple can be\n        used to index into the array to extract that chunk plus its overlap.\n\n    Example\n    -------\n    &gt;&gt;&gt; slices_from_chunks_overlap(((4,), (7, 7)), (4, 14), depth=1)\n    [(slice(0, 5, None), slice(0, 8, None)),\n     (slice(0, 5, None), slice(6, 15, None))]\n    \"\"\"\n    cumdims = [cached_cumsum(bds, initial_zero=True) for bds in chunks]\n\n    slices = []\n    for starts, shapes, maxshape in zip(cumdims, chunks, array_shape, strict=False):\n        inner_slices = []\n        for s, dim in zip(starts, shapes, strict=False):\n            slice_start = s\n            slice_stop = s + dim\n            if slice_start &gt; 0:\n                slice_start -= depth\n            if slice_stop &gt;= maxshape:\n                slice_stop += depth\n            inner_slices.append(slice(slice_start, slice_stop))\n        slices.append(inner_slices)\n\n    return list(product(*slices))\n</code></pre>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.slices_from_chunks_overlap(chunks)","title":"<code>chunks</code>","text":"(<code>tuple of tuples of int</code>)           \u2013            <p>The chunk sizes in each dimension, as returned by Dask's <code>.chunks</code> attribute. For example: ((4,), (7, 7))</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.slices_from_chunks_overlap(array_shape)","title":"<code>array_shape</code>","text":"(<code>tuple of int</code>)           \u2013            <p>Shape of the full array.</p>"},{"location":"reference/skeleplex/graph/image_to_graph_lazy/#skeleplex.graph.image_to_graph_lazy.slices_from_chunks_overlap(depth)","title":"<code>depth</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Number of voxels to include as overlap around each chunk. Defaults to 1.</p>"},{"location":"reference/skeleplex/graph/modify_graph/","title":"modify_graph","text":""},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph","title":"skeleplex.graph.modify_graph","text":"<p>Functions:</p> <ul> <li> <code>connect_without_merging</code>             \u2013              <p>Connect two nodes without merging them.</p> </li> <li> <code>delete_edge</code>             \u2013              <p>Delete edge in skeleton graph.</p> </li> <li> <code>length_pruning</code>             \u2013              <p>Prune all edges with length below threshold.</p> </li> <li> <code>merge_edge</code>             \u2013              <p>Merge edges in graph and add edge attributes.</p> </li> <li> <code>merge_nodes</code>             \u2013              <p>Merge two nodes in a graph.</p> </li> <li> <code>move_branch_point_along_edge</code>             \u2013              <p>Move Branch point along edge.</p> </li> <li> <code>prune_degree_2_nodes</code>             \u2013              <p>Remove all degree-2 nodes by merging their incoming and outgoing edges.</p> </li> <li> <code>split_edge</code>             \u2013              <p>Split an edge at a given position.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.connect_without_merging","title":"connect_without_merging","text":"<pre><code>connect_without_merging(skeleton_graph: SkeletonGraph, node1: int, node2: int, return_graph: bool = False)\n</code></pre> <p>Connect two nodes without merging them.</p> <p>A line is just drawn between the two nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The modified skeleton graph with the new edge added.</p> </li> </ul> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def connect_without_merging(\n    skeleton_graph: SkeletonGraph, node1: int, node2: int, return_graph: bool = False\n):\n    \"\"\"Connect two nodes without merging them.\n\n    A line is just drawn between the two nodes.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The skeleton graph object.\n    node1 : int\n        The first node to connect.\n    node2 : int\n        The second node to connect.\n    return_graph : bool, optional\n        If True, return the modified graph.\n        Default is False.\n\n    Returns\n    -------\n    nx.DiGraph\n        The modified skeleton graph with the new edge added.\n    \"\"\"\n    # check if directed\n    if not skeleton_graph.graph.is_directed():\n        ValueError(\"Graph is not directed. Convert to directed graph.\")\n    # copy graph\n    graph = skeleton_graph.graph.copy()\n    # check if nodes are already connected\n    if graph.has_edge(node1, node2):\n        logger.warning(f\"Nodes {node1} and {node2} are already connected.\")\n\n    u_coordinates = skeleton_graph.graph.nodes[node1][NODE_COORDINATE_KEY]\n    v_coordinates = skeleton_graph.graph.nodes[node2][NODE_COORDINATE_KEY]\n    path = np.linspace(u_coordinates, v_coordinates, num=20)\n    spline = B3Spline.from_points(path)\n\n    g = skeleton_graph.graph.copy()\n    g.add_edge(\n        node1,\n        node2,\n        **{\n            EDGE_COORDINATES_KEY: path,\n            EDGE_SPLINE_KEY: spline,\n            START_NODE_KEY: node1,\n            END_NODE_KEY: node2,\n        },\n    )\n\n    skeleton_graph.graph = g\n    if return_graph:\n        return skeleton_graph.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.connect_without_merging(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The skeleton graph object.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.connect_without_merging(node1)","title":"<code>node1</code>","text":"(<code>int</code>)           \u2013            <p>The first node to connect.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.connect_without_merging(node2)","title":"<code>node2</code>","text":"(<code>int</code>)           \u2013            <p>The second node to connect.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.connect_without_merging(return_graph)","title":"<code>return_graph</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the modified graph. Default is False.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.delete_edge","title":"delete_edge","text":"<pre><code>delete_edge(skeleton_graph: SkeletonGraph, edge: tuple[int, int])\n</code></pre> <p>Delete edge in skeleton graph.</p> <p>To maintain a dichotomous structure, the edge is deleted and the resulting degree 2 node is merged with its neighbors.</p> <pre><code>    \"Delete (2,4)\"\n</code></pre> <p>1               1 |               | |               | 2------4   --&gt;  | |               | |               | 3               3</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def delete_edge(skeleton_graph: SkeletonGraph, edge: tuple[int, int]):\n    \"\"\"Delete edge in skeleton graph.\n\n    To maintain a dichotomous structure, the edge is deleted and the\n    resulting degree 2 node is merged with its neighbors.\n\n            \"Delete (2,4)\"\n    1               1\n    |               |\n    |               |\n    2------4   --&gt;  |\n    |               |\n    |               |\n    3               3\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The graph to delete the edge from.\n    edge : Tuple[int, int]\n        The edge to delete.\n    \"\"\"\n    # check if directed\n    if not skeleton_graph.graph.is_directed():\n        ValueError(\"Graph is not directed. Convert to directed graph.\")\n    # copy graph\n    graph = skeleton_graph.graph.copy()\n    graph.remove_edge(*edge)\n\n    # detect all changes\n    changed_edges = set(skeleton_graph.graph.edges) - set(graph.edges)\n    skeleton_graph.graph = graph\n    for edge in changed_edges:\n        for node in edge:\n            if skeleton_graph.graph.degree(node) == 0:\n                skeleton_graph.graph.remove_node(node)\n            # merge edges if node has degree 2\n            elif skeleton_graph.graph.degree(node) == 2:\n                # merge\n                in_edge = list(skeleton_graph.graph.in_edges(node))\n                out_edge = list(skeleton_graph.graph.out_edges(node))\n                if len(in_edge) == 0:\n                    raise ValueError(\n                        (\"Deleting the edge would break the graph\"),\n                        \"Are you trying to delete the origin?\",\n                    )\n\n                merge_edge(skeleton_graph, in_edge[0][0], node, out_edge[0][1])\n                logger.info(\"merge\")\n\n    # check if graph is still connected, if not remove orphaned nodes\n    skeleton_graph.graph.remove_nodes_from(list(nx.isolates(skeleton_graph.graph)))\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.delete_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The graph to delete the edge from.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.delete_edge(edge)","title":"<code>edge</code>","text":"(<code>Tuple[int, int]</code>)           \u2013            <p>The edge to delete.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.length_pruning","title":"length_pruning","text":"<pre><code>length_pruning(skeleton_graph: SkeletonGraph, length_threshold: int)\n</code></pre> <p>Prune all edges with length below threshold.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def length_pruning(skeleton_graph: SkeletonGraph, length_threshold: int):\n    \"\"\"Prune all edges with length below threshold.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The graph to prune.\n    length_threshold : int\n        The threshold for the length of the edges.\n\n\n    \"\"\"\n    # check if directed\n    if not skeleton_graph.graph.is_directed():\n        ValueError(\"Graph is not directed. Convert to directed graph.\")\n\n    graph = skeleton_graph.graph\n    g_unmodified = graph.copy()\n\n    # check if length is already computed\n    if len(nx.get_edge_attributes(graph, LENGTH_KEY)) == 0:\n        len_dict = skeleton_graph.compute_branch_lengths()\n        nx.set_edge_attributes(graph, len_dict, LENGTH_KEY)\n\n    for node, degree in g_unmodified.degree():\n        if (degree == 1) and (node != skeleton_graph.origin):\n            edge = next(iter(graph.in_edges(node)))\n            path_length = graph.edges[edge[0], edge[1]].get(LENGTH_KEY)\n            # start_node = edge[0]\n            if path_length &lt; length_threshold:\n                # check if edge still exists in original graph\n                if edge not in skeleton_graph.graph.edges:\n                    continue\n                try:\n                    delete_edge(skeleton_graph, edge)\n                    logger.info(f\"Deleted {edge}\")\n                except KeyError:\n                    logger.warning(f\"Edge {edge} not found in graph, could not delete.\")\n                except Exception as e:\n                    logger.error(f\"Unexpected error while deleting {edge}: {e}\")\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.length_pruning(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The graph to prune.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.length_pruning(length_threshold)","title":"<code>length_threshold</code>","text":"(<code>int</code>)           \u2013            <p>The threshold for the length of the edges.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge","title":"merge_edge","text":"<pre><code>merge_edge(skeleton_graph: SkeletonGraph, n1: int, v1: int, n2: int)\n</code></pre> <p>Merge edges in graph and add edge attributes.</p> <p>n1 is merged with n2. v1 is removed.</p> <pre><code>        \"n1 = 1, v1 = 2, n2 = 3\"\n</code></pre> <p>1               1 |               | |               | 2   --&gt;         | |               | |               | 3               3</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def merge_edge(skeleton_graph: SkeletonGraph, n1: int, v1: int, n2: int):\n    \"\"\"Merge edges in graph and add edge attributes.\n\n    n1 is merged with n2. v1 is removed.\n\n                \"n1 = 1, v1 = 2, n2 = 3\"\n    1               1\n    |               |\n    |               |\n    2   --&gt;         |\n    |               |\n    |               |\n    3               3\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The graph to merge the edges in.\n    n1 : int\n        The start node of the first edge.\n    v1 : int\n        The end node of the first edge and the start node of the second edge.\n        This node is removed.\n    n2 : int\n        The end node of the second edge.\n\n\n    \"\"\"\n    graph = skeleton_graph.graph.copy()\n\n    start_node = graph.nodes(data=True)[n1][NODE_COORDINATE_KEY]\n    end_node = graph.nodes(data=True)[n2][NODE_COORDINATE_KEY]\n    middle_node = graph.nodes(data=True)[v1][NODE_COORDINATE_KEY]\n\n    if graph.degree(v1) != 2:\n        raise ValueError(\n            f\"Node {v1} has degree {graph.degree(middle_node)}. \"\n            \"Only nodes with degree 2 can be merged.\"\n        )\n\n    # adapt for directed graphs\n    if graph.has_edge(n1, v1) and graph.has_edge(v1, n2):\n        edge1 = (n1, v1)\n        edge2 = (v1, n2)\n        merge_edge = (n1, n2)\n    # first flipped\n    elif graph.has_edge(v1, n2) and graph.has_edge(n1, v1):\n        edge1 = (v1, n2)\n        edge2 = (n1, v1)\n        merge_edge = (n2, n1)\n    # second flipped\n    elif graph.has_edge(n1, v1) and graph.has_edge(n2, v1):\n        edge1 = (n1, v1)\n        edge2 = (n2, v1)\n        merge_edge = (n1, n2)\n    # both flipped\n    elif graph.has_edge(v1, n2) and graph.has_edge(n2, v1):\n        edge1 = (v1, n2)\n        edge2 = (n2, v1)\n        merge_edge = (n1, n2)\n    else:\n        raise ValueError(\n            f\"Edges {n1, v1} and {v1, n2} not found in graph. \"\n            \"Are you trying to merge nodes that are not connected?\"\n        )\n\n    # edge1 = (start_node, middle_node)\n    # edge2 = (middle_node, end_node)\n\n    edge_attributes1 = graph.get_edge_data(edge1[0], edge1[1])\n    edge_attributes2 = graph.get_edge_data(edge2[0], edge2[1])\n    graph.remove_edge(edge1[0], edge1[1])\n    graph.remove_edge(edge2[0], edge2[1])\n    graph.remove_node(edge1[1])\n    # merge_edge = (edge1[0], edge2[1])\n    merge_attributes = {}\n    for key in edge_attributes1:\n        if key == VALIDATION_KEY:\n            if edge_attributes1[key] and edge_attributes2[key]:\n                merge_attributes[key] = True\n            else:\n                merge_attributes[key] = False\n\n        if key == EDGE_SPLINE_KEY:\n            points1 = edge_attributes1[EDGE_COORDINATES_KEY]\n            points2 = edge_attributes2[EDGE_COORDINATES_KEY]\n\n            # start and end node coordinates\n            # this checking is probably not necessary as we use directed graphs\n            # but just to be sure\n            if np.allclose(points1[0], start_node) &amp; np.allclose(\n                points2[0], middle_node\n            ):\n                logger.info(\"None of the edges need to be flipped\")\n                spline_points = np.vstack((points1, points2))\n\n            elif np.allclose(points1[-1], start_node) &amp; np.allclose(\n                points2[0], middle_node\n            ):\n                logger.info(f\"flip edge {edge1}\")\n                spline_points = np.vstack((np.flip(points1, axis=0), points2))\n            elif np.allclose(points1[0], start_node) &amp; np.allclose(\n                points2[-1], middle_node\n            ):\n                logger.info(f\"flip {edge2}\")\n                spline_points = np.vstack((points1, np.flip(points2, axis=0)))\n            elif np.allclose(points1[-1], start_node) &amp; np.allclose(\n                points2[-1], middle_node\n            ):\n                logger.info(f\"flip {edge1} and {edge2}\")\n                spline_points = np.vstack(\n                    (np.flip(points1, axis=0), np.flip(points2, axis=0))\n                )\n            else:\n                logger.warning(\"Warning: Edge splines not connected.\")\n                spline_points = np.vstack((points1, points2))\n            # sanity check\n            if np.allclose(spline_points[-1], end_node):\n                logger.info(\"sanity check passed\")\n\n            _, idx = np.unique(spline_points, axis=0, return_index=True)\n            spline_points = spline_points[np.sort(idx)]\n            spline = B3Spline.from_points(spline_points)\n            merge_attributes[key] = spline\n            merge_attributes[EDGE_COORDINATES_KEY] = spline_points\n        if key == START_NODE_KEY:\n            merge_attributes[key] = n1\n        if key == END_NODE_KEY:\n            merge_attributes[key] = n2\n        if key == GENERATION_KEY:\n            merge_attributes[key] = edge_attributes1[key]\n\n        if key == LENGTH_KEY:\n            merge_attributes[key] = merge_attributes[EDGE_SPLINE_KEY].arc_length\n\n        if key not in [\n            VALIDATION_KEY,\n            EDGE_COORDINATES_KEY,\n            EDGE_SPLINE_KEY,\n            START_NODE_KEY,\n            END_NODE_KEY,\n            GENERATION_KEY,\n            LENGTH_KEY,\n        ]:\n            logger.warning(\n                (f\"Warning: Attribute {key} not merged. \", \"Consider recomputing.\")\n            )\n\n    graph.add_edge(*merge_edge, **merge_attributes)\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The graph to merge the edges in.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(n1)","title":"<code>n1</code>","text":"(<code>int</code>)           \u2013            <p>The start node of the first edge.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(v1)","title":"<code>v1</code>","text":"(<code>int</code>)           \u2013            <p>The end node of the first edge and the start node of the second edge. This node is removed.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_edge(n2)","title":"<code>n2</code>","text":"(<code>int</code>)           \u2013            <p>The end node of the second edge.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_nodes","title":"merge_nodes","text":"<pre><code>merge_nodes(skeleton_graph: SkeletonGraph, node_to_keep: int, node_to_merge: int)\n</code></pre> <p>Merge two nodes in a graph.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def merge_nodes(\n    skeleton_graph: SkeletonGraph,\n    node_to_keep: int,\n    node_to_merge: int,\n):\n    \"\"\"Merge two nodes in a graph.\n\n    Parameters\n    ----------\n    skeleton_graph : nx.Graph\n        The skeleton in which to perform the merging.\n    node_to_keep : int\n        The index of the merged nodes to keep in the graph.\n    node_to_merge : int\n        The index of the merged nodes that should be removed.\n\n\n    \"\"\"\n    degree_of_merge = skeleton_graph.graph.degree(node_to_merge)\n    if degree_of_merge != 1:\n        raise ValueError(\n            f\"Node {node_to_merge} has degree {degree_of_merge}. \"\n            \"Only nodes with degree 1 can be merged.\"\n        )\n    edge_to_merge = skeleton_graph.graph.in_edges(node_to_merge)\n    second_node_to_keep = next(iter(edge_to_merge))[0]\n    skeleton_graph.graph = connect_without_merging(\n        skeleton_graph=skeleton_graph,\n        node1=node_to_keep,\n        node2=node_to_merge,\n        return_graph=True,\n    )\n\n    merge_edge(\n        skeleton_graph=skeleton_graph,\n        n1=node_to_keep,\n        v1=node_to_merge,\n        n2=second_node_to_keep,\n    )\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_nodes(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The skeleton in which to perform the merging.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_nodes(node_to_keep)","title":"<code>node_to_keep</code>","text":"(<code>int</code>)           \u2013            <p>The index of the merged nodes to keep in the graph.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.merge_nodes(node_to_merge)","title":"<code>node_to_merge</code>","text":"(<code>int</code>)           \u2013            <p>The index of the merged nodes that should be removed.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge","title":"move_branch_point_along_edge","text":"<pre><code>move_branch_point_along_edge(skeleton_graph: SkeletonGraph, node: int, edge_to_shorten: tuple, edge_to_elongate: tuple, edge_to_remodel: tuple, distance)\n</code></pre> <p>Move Branch point along edge.</p> <p>Moves the branch point along the edge_to_shorten by distance and splits the edge_to_shorten at the new position. The second daughter edge is remoddled as a straight line.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def move_branch_point_along_edge(\n    skeleton_graph: SkeletonGraph,\n    node: int,\n    edge_to_shorten: tuple,\n    edge_to_elongate: tuple,\n    edge_to_remodel: tuple,\n    distance,\n):\n    \"\"\"\n    Move Branch point along edge.\n\n    Moves the branch point along the edge_to_shorten by distance and\n    splits the edge_to_shorten at the new position. The second daughter edge is\n    remoddled as a straight line.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The skeleton graph object.\n    node : int\n        The node to move.\n    edge_to_shorten : Tuple\n        The edge to shorten.\n    edge_to_elongate : Tuple\n        The edge to elongate.\n    edge_to_remodel : Tuple\n        The edge to remodel.\n    distance : float\n        The distance to move the node along the edge_to_shorten.\n        Normalized between 0 and 1.\n    \"\"\"\n    graph = skeleton_graph.graph\n    spline_to_shorten = graph.edges[edge_to_shorten][EDGE_SPLINE_KEY]\n    # move branch point\n    point_on_edge_to_shorten = spline_to_shorten.eval(distance)\n\n    # split edge_coordinates into two parts at the point_on_in_edge\n    edge_to_shoorten_coords = graph.edges[edge_to_shorten][EDGE_COORDINATES_KEY]\n    # rather get the closest point\n    idx = np.argmin(\n        np.linalg.norm(edge_to_shoorten_coords - point_on_edge_to_shorten, axis=1)\n    )\n    # split\n    edge_coordinates_1 = edge_to_shoorten_coords[: idx + 1]\n    edge_coordinates_2 = edge_to_shoorten_coords[idx:]\n\n    # check if edge is long enough\n    if len(edge_coordinates_1) &lt; 4:\n        logger.warning(\n            f\"Edge {edge_to_shorten} is to short to split at {distance}.\"\n            \" Approximate edge as line.\"\n        )\n        edge_coordinates_1 = np.linspace(\n            edge_coordinates_1[0], edge_coordinates_1[-1], 5\n        )\n    out_edge_coordinates = graph.edges[edge_to_elongate][EDGE_COORDINATES_KEY]\n\n    # maybe it makes sense to take the sampled point of the spline,\n    # instead it takes the underlying coordinates. Could be more robust\n    new_node_pos = edge_to_shoorten_coords[idx]\n\n    new_out_edge_coordinates = np.concatenate(\n        (edge_coordinates_2, out_edge_coordinates)\n    )\n\n    # filter duplicates\n    new_out_edge_coordinates, indices = np.unique(\n        new_out_edge_coordinates, axis=0, return_index=True\n    )\n    new_out_edge_coordinates = new_out_edge_coordinates[np.argsort(indices)]\n\n    new_in_edge_coordinates = edge_coordinates_1\n\n    # update edges\n    graph.edges[edge_to_shorten][EDGE_COORDINATES_KEY] = new_in_edge_coordinates\n    graph.edges[edge_to_elongate][EDGE_COORDINATES_KEY] = new_out_edge_coordinates\n    graph.nodes[node][NODE_COORDINATE_KEY] = new_node_pos\n\n    # update splines\n    graph.edges[edge_to_shorten][EDGE_SPLINE_KEY] = B3Spline.from_points(\n        new_in_edge_coordinates\n    )\n    graph.edges[edge_to_elongate][EDGE_SPLINE_KEY] = B3Spline.from_points(\n        new_out_edge_coordinates\n    )\n\n    # draw new edge for the other out edge\n    out_edge_node2 = edge_to_remodel[1]\n    out_edge_node2_pos = graph.nodes[out_edge_node2][NODE_COORDINATE_KEY]\n    new_out_edge_coordinates = np.linspace(new_node_pos, out_edge_node2_pos, 10)\n\n    # update edge\n    graph.edges[edge_to_remodel][EDGE_COORDINATES_KEY] = new_out_edge_coordinates\n    graph.edges[edge_to_remodel][EDGE_SPLINE_KEY] = B3Spline.from_points(\n        new_out_edge_coordinates\n    )\n\n    # update graph\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The skeleton graph object.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(node)","title":"<code>node</code>","text":"(<code>int</code>)           \u2013            <p>The node to move.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(edge_to_shorten)","title":"<code>edge_to_shorten</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to shorten.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(edge_to_elongate)","title":"<code>edge_to_elongate</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to elongate.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(edge_to_remodel)","title":"<code>edge_to_remodel</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to remodel.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.move_branch_point_along_edge(distance)","title":"<code>distance</code>","text":"(<code>float</code>)           \u2013            <p>The distance to move the node along the edge_to_shorten. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.prune_degree_2_nodes","title":"prune_degree_2_nodes","text":"<pre><code>prune_degree_2_nodes(skeleton_graph: SkeletonGraph)\n</code></pre> <p>Remove all degree-2 nodes by merging their incoming and outgoing edges.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def prune_degree_2_nodes(skeleton_graph: SkeletonGraph):\n    \"\"\"Remove all degree-2 nodes by merging their incoming and outgoing edges.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The graph to prune.\n\n    \"\"\"\n    graph = skeleton_graph.graph.copy()\n    origin = skeleton_graph.origin\n\n    nodes_to_merge = []\n    for node in graph.nodes:\n        if node == origin:\n            continue\n        if graph.degree(node) == 2:\n            in_edges = list(graph.in_edges(node))\n            out_edges = list(graph.out_edges(node))\n            if len(in_edges) == 1 and len(out_edges) == 1:\n                u = in_edges[0][0]\n                w = out_edges[0][1]\n                nodes_to_merge.append((u, node, w))\n\n    logger.info(f\"Found {len(nodes_to_merge)} degree-2 nodes to merge.\")\n\n    for u, v, w in nodes_to_merge:\n        try:\n            merge_edge(skeleton_graph, u, v, w)  # just calling, not assigning\n            logger.info(f\"Merged node {v} between {u} and {w}\")\n        except Exception as e:\n            logger.warning(f\"Could not merge node {v} between {u} and {w}: {e}\")\n\n    # reload graph because merge_edge modifies skeleton_graph.graph\n    graph = skeleton_graph.graph\n\n    # remove any isolates\n    graph.remove_nodes_from(list(nx.isolates(graph)))\n\n    # save updated graph back\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.prune_degree_2_nodes(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The graph to prune.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge","title":"split_edge","text":"<pre><code>split_edge(skeleton_graph: SkeletonGraph, edge_to_split_ID: tuple, split_pos: float)\n</code></pre> <p>Split an edge at a given position.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/modify_graph.py</code> <pre><code>def split_edge(\n    skeleton_graph: SkeletonGraph, edge_to_split_ID: tuple, split_pos: float\n):\n    \"\"\"Split an edge at a given position.\n\n    Parameters\n    ----------\n    skeleton_graph : SkeletonGraph\n        The skeleton graph object.\n    edge_to_split_ID : Tuple\n        The edge to split.\n    split_pos : float\n        The position to split the edge at. Normalized between 0 and 1.\n    \"\"\"\n    # test if edge is in tree\n    if edge_to_split_ID not in skeleton_graph.graph.edges:\n        ValueError(f\"Edge {edge_to_split_ID} not in graph.\")\n    graph = skeleton_graph.graph.copy()\n    spline = skeleton_graph.graph.edges[edge_to_split_ID][EDGE_SPLINE_KEY]\n    edge_coordinates = graph.edges[edge_to_split_ID][EDGE_COORDINATES_KEY]\n    coordinate_to_split = spline.eval(split_pos)\n    split_index = np.argmin(\n        np.linalg.norm(edge_coordinates - coordinate_to_split, axis=1)\n    )\n    new_node_number = get_next_node_key(graph)\n    graph.add_node(new_node_number, node_coordinate=coordinate_to_split)\n    new_edge_coords1 = edge_coordinates[: split_index + 1]\n    if len(new_edge_coords1) &lt; 4:\n        logger.warning(\n            f\"Edge {edge_to_split_ID} is to short to split at {split_pos}.\"\n            \" Approximate edge as line.\"\n        )\n        new_edge_coords1 = np.linspace(new_edge_coords1[0], new_edge_coords1[-1], 5)\n    new_edge_dict1 = {\n        EDGE_COORDINATES_KEY: new_edge_coords1,\n        START_NODE_KEY: new_node_number,\n        END_NODE_KEY: edge_to_split_ID[1],\n        EDGE_SPLINE_KEY: B3Spline.from_points(\n            new_edge_coords1,\n        ),\n    }\n    graph.add_edge(edge_to_split_ID[0], new_node_number, **new_edge_dict1)\n\n    # add second piece\n    new_edge_coords2 = edge_coordinates[split_index:]\n    if len(new_edge_coords2) &lt; 4:\n        logger.warning(\n            f\"Edge {edge_to_split_ID} is to short to split at {split_pos}.\"\n            \" Approximate edge as line.\"\n        )\n        new_edge_coords2 = np.linspace(new_edge_coords2[0], new_edge_coords2[-1], 5)\n\n    new_edge_dict2 = {\n        EDGE_COORDINATES_KEY: new_edge_coords2,\n        START_NODE_KEY: edge_to_split_ID[0],\n        END_NODE_KEY: new_node_number,\n        EDGE_SPLINE_KEY: B3Spline.from_points(\n            new_edge_coords2,\n        ),\n    }\n\n    graph.add_edge(new_node_number, edge_to_split_ID[1], **new_edge_dict2)\n\n    graph.remove_edge(*edge_to_split_ID)\n\n    skeleton_graph.graph = graph\n</code></pre>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge(skeleton_graph)","title":"<code>skeleton_graph</code>","text":"(<code>SkeletonGraph</code>)           \u2013            <p>The skeleton graph object.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge(edge_to_split_ID)","title":"<code>edge_to_split_ID</code>","text":"(<code>Tuple</code>)           \u2013            <p>The edge to split.</p>"},{"location":"reference/skeleplex/graph/modify_graph/#skeleplex.graph.modify_graph.split_edge(split_pos)","title":"<code>split_pos</code>","text":"(<code>float</code>)           \u2013            <p>The position to split the edge at. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/sample/","title":"sample","text":""},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample","title":"skeleplex.graph.sample","text":"<p>Functions for sampling images using the SkeletonGraph.</p> <p>Functions:</p> <ul> <li> <code>generate_2d_grid</code>             \u2013              <p>Generate a 2D sampling grid with specified shape and spacing.</p> </li> <li> <code>generate_3d_grid</code>             \u2013              <p>Generate a 3D sampling grid with specified shape and spacing.</p> </li> <li> <code>sample_volume_at_coordinates</code>             \u2013              <p>Sample a volume with spline interpolation at specific coordinates.</p> </li> <li> <code>sample_volume_at_coordinates_lazy</code>             \u2013              <p>Sample a volume with spline interpolation at specific coordinates.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_2d_grid","title":"generate_2d_grid","text":"<pre><code>generate_2d_grid(grid_shape: tuple[int, int] = (10, 10), grid_spacing: tuple[float, float] = (1, 1)) -&gt; ndarray\n</code></pre> <p>Generate a 2D sampling grid with specified shape and spacing.</p> <p>The grid generated is centered on the origin, lying on the plane with normal vector [1, 0, 0], has shape (w, h, 3) for grid_shape (w, h), and spacing grid_spacing between neighboring points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Coordinate of points forming the 2D grid.</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def generate_2d_grid(\n    grid_shape: tuple[int, int] = (10, 10), grid_spacing: tuple[float, float] = (1, 1)\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate a 2D sampling grid with specified shape and spacing.\n\n    The grid generated is centered on the origin, lying on the plane with normal\n    vector [1, 0, 0], has shape (w, h, 3) for grid_shape (w, h), and spacing\n    grid_spacing between neighboring points.\n\n    Parameters\n    ----------\n    grid_shape : Tuple[int, int]\n        The number of grid points along each axis.\n    grid_spacing : Tuple[float, float]\n        Spacing between points in the sampling grid.\n\n    Returns\n    -------\n    np.ndarray\n        Coordinate of points forming the 2D grid.\n    \"\"\"\n    grid = generate_3d_grid(\n        grid_shape=(1, *grid_shape), grid_spacing=(1, *grid_spacing)\n    )\n    return einops.rearrange(grid, \"1 w h xyz -&gt; w h xyz\")\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_2d_grid(grid_shape)","title":"<code>grid_shape</code>","text":"(<code>Tuple[int, int]</code>, default:                   <code>(10, 10)</code> )           \u2013            <p>The number of grid points along each axis.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_2d_grid(grid_spacing)","title":"<code>grid_spacing</code>","text":"(<code>Tuple[float, float]</code>, default:                   <code>(1, 1)</code> )           \u2013            <p>Spacing between points in the sampling grid.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_3d_grid","title":"generate_3d_grid","text":"<pre><code>generate_3d_grid(grid_shape: tuple[int, int, int] = (10, 10, 10), grid_spacing: tuple[float, float, float] = (1, 1, 1)) -&gt; ndarray\n</code></pre> <p>Generate a 3D sampling grid with specified shape and spacing.</p> <p>The grid generated is centered on the origin, has shape (w, h, d, 3) for grid_shape (w, h, d), and spacing grid_spacing between neighboring points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Coordinate of points forming the 3D grid.</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def generate_3d_grid(\n    grid_shape: tuple[int, int, int] = (10, 10, 10),\n    grid_spacing: tuple[float, float, float] = (1, 1, 1),\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate a 3D sampling grid with specified shape and spacing.\n\n    The grid generated is centered on the origin, has shape (w, h, d, 3) for\n    grid_shape (w, h, d), and spacing grid_spacing between neighboring points.\n\n    Parameters\n    ----------\n    grid_shape : Tuple[int, int, int]\n        The number of grid points along each axis.\n    grid_spacing : Tuple[float, float, float]\n        Spacing between points in the sampling grid.\n\n    Returns\n    -------\n    np.ndarray\n        Coordinate of points forming the 3D grid.\n    \"\"\"\n    # generate a grid of points at each integer from 0 to grid_shape for each dimension\n    grid = np.indices(grid_shape).astype(float)\n    grid = einops.rearrange(grid, \"xyz w h d -&gt; w h d xyz\")\n    # shift the grid to be centered on the origin\n    grid_offset = (np.array(grid_shape)) // 2\n    grid -= grid_offset\n    # scale the grid to get correct spacing\n    grid *= grid_spacing\n    return grid\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_3d_grid(grid_shape)","title":"<code>grid_shape</code>","text":"(<code>Tuple[int, int, int]</code>, default:                   <code>(10, 10, 10)</code> )           \u2013            <p>The number of grid points along each axis.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.generate_3d_grid(grid_spacing)","title":"<code>grid_spacing</code>","text":"(<code>Tuple[float, float, float]</code>, default:                   <code>(1, 1, 1)</code> )           \u2013            <p>Spacing between points in the sampling grid.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates","title":"sample_volume_at_coordinates","text":"<pre><code>sample_volume_at_coordinates(volume: ndarray, coordinates: ndarray, interpolation_order: int = 3, fill_value: float = nan) -&gt; ndarray\n</code></pre> <p>Sample a volume with spline interpolation at specific coordinates.</p> <p>The output shape is determined by the input coordinate shape such that if coordinates have shape (batch, grid_shape, 3), the output array will have shape (grid_shape, batch).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (*grid_shape)</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def sample_volume_at_coordinates(\n    volume: np.ndarray,\n    coordinates: np.ndarray,\n    interpolation_order: int = 3,\n    fill_value: float = np.nan,\n) -&gt; np.ndarray:\n    \"\"\"\n    Sample a volume with spline interpolation at specific coordinates.\n\n    The output shape is determined by the input coordinate shape such that\n    if coordinates have shape (batch, *grid_shape, 3), the output array will have\n    shape (*grid_shape, batch).\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        Volume to be sampled.\n    coordinates : np.ndarray\n        Array of coordinates at which to sample the volume. The shape of this array\n        should be (batch, *grid_shape, 3) to allow reshaping back correctly\n    interpolation_order : int\n        Spline order for image interpolation.\n    fill_value : float\n        Value to fill in for sample coordinates past the edges of the volume.\n\n    Returns\n    -------\n    np.ndarray\n        Array of shape (*grid_shape)\n    \"\"\"\n    batch, *grid_shape, _ = coordinates.shape\n    # map_coordinates wants transposed coordinate array\n    sampled_volume = map_coordinates(\n        volume,\n        coordinates.reshape(-1, 3).T,\n        order=interpolation_order,\n        cval=fill_value,\n    )\n\n    # reshape back (need to invert due to previous transposition)\n    sampled_volume = sampled_volume.reshape(*grid_shape, batch)\n    # and retranspose to get batch back to the 0th dimension\n    return einops.rearrange(sampled_volume, \"... batch -&gt; batch ...\")\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>Volume to be sampled.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of coordinates at which to sample the volume. The shape of this array should be (batch, *grid_shape, 3) to allow reshaping back correctly</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Spline order for image interpolation.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates(fill_value)","title":"<code>fill_value</code>","text":"(<code>float</code>, default:                   <code>nan</code> )           \u2013            <p>Value to fill in for sample coordinates past the edges of the volume.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates_lazy","title":"sample_volume_at_coordinates_lazy","text":"<pre><code>sample_volume_at_coordinates_lazy(volume: ndarray, coordinates: ndarray, interpolation_order: int = 3, fill_value: float = nan) -&gt; ndarray\n</code></pre> <p>Sample a volume with spline interpolation at specific coordinates.</p> <p>This function is designed to work with large volumes that are too big to fit into memory. It extracts only the necessary chunk of the volume and samples that chunk. The output shape is determined by the input coordinate shape such that if coordinates have shape (batch, grid_shape, 3), the output array will have shape (grid_shape, batch).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of shape (*grid_shape)</p> </li> </ul> Source code in <code>skeleplex/graph/sample.py</code> <pre><code>def sample_volume_at_coordinates_lazy(\n    volume: np.ndarray,\n    coordinates: np.ndarray,\n    interpolation_order: int = 3,\n    fill_value: float = np.nan,\n) -&gt; np.ndarray:\n    \"\"\"\n    Sample a volume with spline interpolation at specific coordinates.\n\n    This function is designed to work with large volumes that are too big to fit\n    into memory. It extracts only the necessary chunk of the volume and samples\n    that chunk.\n    The output shape is determined by the input coordinate shape such that\n    if coordinates have shape (batch, *grid_shape, 3), the output array will have\n    shape (*grid_shape, batch).\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        Volume to be sampled.\n    coordinates : np.ndarray\n        Array of coordinates at which to sample the volume. The shape of this array\n        should be (batch, *grid_shape, 3) to allow reshaping back correctly\n    interpolation_order : int\n        Spline order for image interpolation.\n    fill_value : float\n        Value to fill in for sample coordinates past the edges of the volume.\n\n    Returns\n    -------\n    np.ndarray\n        Array of shape (*grid_shape)\n    \"\"\"\n    batch, *grid_shape, _ = coordinates.shape\n\n    min_coords = np.floor(coordinates.min(axis=(0, 1, 2))).astype(int)\n    max_coords = np.ceil(coordinates.max(axis=(0, 1, 2))).astype(int)\n\n    # Clip to valid range\n    min_coords = np.clip(min_coords, 0, np.array(volume.shape) - 1)\n    max_coords = np.clip(max_coords, 1, np.array(volume.shape))  # avoid empty slices\n\n    if np.any(max_coords &lt;= min_coords):\n        raise ValueError(\"Sliced volume would be empty due to coordinate range.\")\n\n    # Extract only the necessary chunk (use slicing)\n    sliced_volume = volume[\n        min_coords[0] : max_coords[0],\n        min_coords[1] : max_coords[1],\n        min_coords[2] : max_coords[2],\n    ].compute()  # Convert to NumPy only for this chunk\n\n    # Adjust coordinates relative to the extracted chunk\n    coordinates -= min_coords\n\n    # Sample the smaller volume using `map_coordinates`\n    sampled_volume = map_coordinates(\n        sliced_volume,\n        coordinates.reshape(-1, 3).T,\n        order=interpolation_order,\n        cval=fill_value,\n    )\n\n    # Reshape back to (*grid_shape, batch)\n    sampled_volume = sampled_volume.reshape(*grid_shape, batch)\n\n    return einops.rearrange(sampled_volume, \"... batch -&gt; batch ...\")\n</code></pre>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates_lazy(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>Volume to be sampled.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates_lazy(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>Array of coordinates at which to sample the volume. The shape of this array should be (batch, *grid_shape, 3) to allow reshaping back correctly</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates_lazy(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Spline order for image interpolation.</p>"},{"location":"reference/skeleplex/graph/sample/#skeleplex.graph.sample.sample_volume_at_coordinates_lazy(fill_value)","title":"<code>fill_value</code>","text":"(<code>float</code>, default:                   <code>nan</code> )           \u2013            <p>Value to fill in for sample coordinates past the edges of the volume.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/","title":"skeleton_graph","text":""},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph","title":"skeleplex.graph.skeleton_graph","text":"<p>Data class for a skeleton graph.</p> <p>Classes:</p> <ul> <li> <code>SkeletonGraph</code>           \u2013            <p>Data class for a skeleton graph.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_next_node_key</code>             \u2013              <p>Return the next available node key in the graph.</p> </li> <li> <code>make_graph_directed</code>             \u2013              <p>Return a directed graph from an undirected graph.</p> </li> <li> <code>orient_splines</code>             \u2013              <p>Checks if the splines are oriented correctly.</p> </li> <li> <code>sample_slices_for_edge</code>             \u2013              <p>Helper function for parallel execution.</p> </li> <li> <code>skeleton_graph_decoder</code>             \u2013              <p>JSON decoder for the networkx skeleton graph.</p> </li> <li> <code>skeleton_graph_encoder</code>             \u2013              <p>JSON encoder for the networkx skeleton graph.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph","title":"SkeletonGraph","text":"<pre><code>SkeletonGraph(graph: Graph, origin: int | None = None, image_path: str | None = None, image_key: str | None = None, voxel_size_um: float | None = None)\n</code></pre> <p>Data class for a skeleton graph.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>compute_branch_lengths</code>             \u2013              <p>Return a dictionary of edge lengths.</p> </li> <li> <code>from_graph</code>             \u2013              <p>Return a SkeletonGraph from a networkx graph.</p> </li> <li> <code>from_json_file</code>             \u2013              <p>Return a SkeletonGraph from a JSON file.</p> </li> <li> <code>from_skeleton_image</code>             \u2013              <p>Return a SkeletonGraph from a skeleton image.</p> </li> <li> <code>orient_splines</code>             \u2013              <p>Orient the splines in the graph.</p> </li> <li> <code>sample_volume_slices_from_spline</code>             \u2013              <p>Sample volume slices from the splines in the graph.</p> </li> <li> <code>sample_volume_slices_from_spline_parallel</code>             \u2013              <p>Sample volume slices from the splines in the graph in parallel.</p> </li> <li> <code>to_directed</code>             \u2013              <p>Return a directed graph from the skeleton graph.</p> </li> <li> <code>to_json_file</code>             \u2013              <p>Return a JSON representation of the graph.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>backend</code>               (<code>str</code>)           \u2013            <p>Return the backend used to store the graph.</p> </li> <li> <code>edge_splines</code>               (<code>dict</code>)           \u2013            <p>Return a list of edge splines.</p> </li> <li> <code>edges</code>           \u2013            <p>Return a list of edges.</p> </li> <li> <code>node_coordinates</code>               (<code>dict</code>)           \u2013            <p>Return a dictionary of node coordinates.</p> </li> <li> <code>node_coordinates_array</code>               (<code>ndarray</code>)           \u2013            <p>Return a numpy array of node coordinates.</p> </li> <li> <code>nodes</code>           \u2013            <p>Return a list of nodes.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def __init__(\n    self,\n    graph: nx.Graph,\n    origin: int | None = None,\n    image_path: str | None = None,\n    image_key: str | None = None,\n    voxel_size_um: float | None = None,\n):\n    self.graph = graph\n    self.origin = origin\n    self.image_path = image_path\n    self.image_key = image_key\n    self.voxel_size_um = voxel_size_um\n    self.origin = origin\n    self.image_path = image_path\n    self.image_key = image_key\n    self.voxel_size_um = voxel_size_um\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The skeleton graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(origin)","title":"<code>origin</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The origin node of the graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(image_path)","title":"<code>image_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image the graph was extracted from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key of the image in the image file.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the image in the image file. We keep the graph scaled to um for easier handling.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(origin)","title":"<code>origin</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The origin node of the graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(image_path)","title":"<code>image_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The path to the image the graph was extracted from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The key of the image in the image file.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The voxel size of the image in the image file. We keep the graph scaled to um for easier handling.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.backend","title":"backend  <code>property</code>","text":"<pre><code>backend: str\n</code></pre> <p>Return the backend used to store the graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.edge_splines","title":"edge_splines  <code>property</code>","text":"<pre><code>edge_splines: dict\n</code></pre> <p>Return a list of edge splines.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.edges","title":"edges  <code>property</code>","text":"<pre><code>edges\n</code></pre> <p>Return a list of edges.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.node_coordinates","title":"node_coordinates  <code>property</code>","text":"<pre><code>node_coordinates: dict\n</code></pre> <p>Return a dictionary of node coordinates.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.node_coordinates_array","title":"node_coordinates_array  <code>property</code>","text":"<pre><code>node_coordinates_array: ndarray\n</code></pre> <p>Return a numpy array of node coordinates.</p> <p>The array is of shape (n_nodes, n_dimensions). The order of the nodes is the same as the order of the nodes attribute.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.nodes","title":"nodes  <code>property</code>","text":"<pre><code>nodes\n</code></pre> <p>Return a list of nodes.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.compute_branch_lengths","title":"compute_branch_lengths","text":"<pre><code>compute_branch_lengths() -&gt; dict\n</code></pre> <p>Return a dictionary of edge lengths.</p> <p>The keys of the dictionary are the edge tuples, the values are arc lengths of the fitted splines. Units will be the same as voxel scale.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def compute_branch_lengths(self) -&gt; dict:\n    \"\"\"Return a dictionary of edge lengths.\n\n    The keys of the dictionary are the edge tuples, the values are arc lengths\n    of the fitted splines. Units will be the same as voxel scale.\n    \"\"\"\n    edge_lengths = {}\n    for u, v, attr in self.graph.edges(data=True):\n        edge_lengths[(u, v)] = attr[EDGE_SPLINE_KEY].arc_length\n\n    nx.set_edge_attributes(self.graph, edge_lengths, LENGTH_KEY)\n    return edge_lengths\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph","title":"from_graph  <code>classmethod</code>","text":"<pre><code>from_graph(graph, edge_coordinate_key, node_coordinate_key, voxel_size_um: float | None = None, scale_to_um: bool = True) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a networkx graph.</p> <p>The edges and nodes need to have an attribute with the specified keys containing the coordinates of the nodes and edges as an np.ndarray. Requires edge coordinates of length greater than 4 to successfully create a spline.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_graph(\n    cls,\n    graph,\n    edge_coordinate_key,\n    node_coordinate_key,\n    voxel_size_um: float | None = None,\n    scale_to_um: bool = True,\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a networkx graph.\n\n    The edges and nodes need to have an attribute with the specified keys\n    containing the coordinates of the nodes and edges as an np.ndarray.\n    Requires edge coordinates of length greater than 4\n    to successfully create a spline.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The graph to convert to a SkeletonGraph.\n    edge_coordinate_key : str\n        The key to use for the edge coordinates.\n    node_coordinate_key : str\n        The key to use for the node coordinates.\n    voxel_size_um : float | None\n        Spacing of the voxels. Used to transform graph coordinates to um.\n    scale_to_um : bool\n        Whether to scale the coordinates to micrometers using the voxel size.\n    \"\"\"\n    graph_mod = graph.copy()\n    for _, _, attr in graph_mod.edges(data=True):\n        # attr[EDGE_COORDINATES_KEY] = attr.pop(edge_coordinate_key)\n        edge_coords = attr[edge_coordinate_key]\n        # add spline\n        if scale_to_um and voxel_size_um is not None:\n            edge_coords = edge_coords * voxel_size_um\n        attr[EDGE_COORDINATES_KEY] = edge_coords\n        spline = B3Spline.from_points(attr[EDGE_COORDINATES_KEY])\n        attr[EDGE_SPLINE_KEY] = spline\n    for _, node_data in graph_mod.nodes(data=True):\n        node_coords = node_data.pop(node_coordinate_key)\n        if scale_to_um and voxel_size_um is not None:\n            node_coords = node_coords * voxel_size_um\n        node_data[NODE_COORDINATE_KEY] = node_coords\n    return cls(graph=graph_mod, voxel_size_um=voxel_size_um)\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The graph to convert to a SkeletonGraph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(edge_coordinate_key)","title":"<code>edge_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the edge coordinates.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(node_coordinate_key)","title":"<code>node_coordinate_key</code>","text":"(<code>str</code>)           \u2013            <p>The key to use for the node coordinates.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(voxel_size_um)","title":"<code>voxel_size_um</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Spacing of the voxels. Used to transform graph coordinates to um.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_graph(scale_to_um)","title":"<code>scale_to_um</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to scale the coordinates to micrometers using the voxel size.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_json_file","title":"from_json_file  <code>classmethod</code>","text":"<pre><code>from_json_file(file_path: str)\n</code></pre> <p>Return a SkeletonGraph from a JSON file.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_json_file(cls, file_path: str):\n    \"\"\"Return a SkeletonGraph from a JSON file.\"\"\"\n    with open(file_path) as file:\n        object_dict = json.load(file, object_hook=skeleton_graph_decoder)\n    graph = nx.node_link_graph(object_dict[\"graph\"], edges=\"edges\")\n    skeleton_object = cls(graph=graph)\n    # do only if keys exist\n    if \"origin\" in object_dict:\n        skeleton_object.origin = object_dict[\"origin\"]\n    if \"image_path\" in object_dict:\n        skeleton_object.image_path = object_dict[\"image_path\"]\n    if \"image_key\" in object_dict:\n        skeleton_object.image_key = object_dict[\"image_key\"]\n    if \"voxel_size_um\" in object_dict:\n        voxel_size_um = object_dict[\"voxel_size_um\"]\n        if isinstance(voxel_size_um, float | int):\n            voxel_size_um = (voxel_size_um, voxel_size_um, voxel_size_um)\n        skeleton_object.voxel_size_um = voxel_size_um\n\n    return skeleton_object\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image","title":"from_skeleton_image  <code>classmethod</code>","text":"<pre><code>from_skeleton_image(skeleton_image: ndarray, max_spline_knots: int = 10, image_voxel_size_um: float = 1) -&gt; SkeletonGraph\n</code></pre> <p>Return a SkeletonGraph from a skeleton image.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>@classmethod\ndef from_skeleton_image(\n    cls,\n    skeleton_image: np.ndarray,\n    max_spline_knots: int = 10,\n    image_voxel_size_um: float = 1,\n) -&gt; \"SkeletonGraph\":\n    \"\"\"Return a SkeletonGraph from a skeleton image.\n\n    Parameters\n    ----------\n    skeleton_image : np.ndarray\n        The skeleton image to convert to a graph.\n    max_spline_knots : int\n        The maximum number of knots to use for the spline fit to the branch path.\n        If the number of data points in the branch is less than this number,\n        the spline will use n_data_points - 1 knots.\n        See the splinebox Spline class docs for more information.\n    image_voxel_size_um  : float or array of float\n        Spacing of the voxels. Used to transform graph coordinates to um.\n    \"\"\"\n    graph = image_to_graph_skan(\n        skeleton_image=skeleton_image,\n        max_spline_knots=max_spline_knots,\n        image_voxel_size_um=image_voxel_size_um,\n    )\n    return cls(graph=graph)\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The skeleton image to convert to a graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image(max_spline_knots)","title":"<code>max_spline_knots</code>","text":"(<code>int</code>, default:                   <code>10</code> )           \u2013            <p>The maximum number of knots to use for the spline fit to the branch path. If the number of data points in the branch is less than this number, the spline will use n_data_points - 1 knots. See the splinebox Spline class docs for more information.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.from_skeleton_image(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>Spacing of the voxels. Used to transform graph coordinates to um.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.orient_splines","title":"orient_splines","text":"<pre><code>orient_splines(approximate_positions: bool = False) -&gt; DiGraph\n</code></pre> <p>Orient the splines in the graph.</p> <p>This modifies the graph in place.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def orient_splines(self, approximate_positions: bool = False) -&gt; nx.DiGraph:\n    \"\"\"Orient the splines in the graph.\n\n    This modifies the graph in place.\n\n    Parameters\n    ----------\n    approximate_positions : bool\n        Whether to use approximate positions for the spline evaluation.\n        This is faster but less accurate. Default is False.\n    \"\"\"\n    self.graph = orient_splines(\n        self.graph, approximate_positions=approximate_positions\n    )\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.orient_splines(approximate_positions)","title":"<code>approximate_positions</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use approximate positions for the spline evaluation. This is faster but less accurate. Default is False.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline","title":"sample_volume_slices_from_spline","text":"<pre><code>sample_volume_slices_from_spline(volume: ndarray, slice_spacing: float, slice_size_um: float, sample_grid_spacing_um: float, interpolation_order: int = 3, max_generation: int | None = None, segmentation: ndarray | None = None, approx: bool = False)\n</code></pre> <p>Sample volume slices from the splines in the graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of image slices.</p> </li> <li> <code>Optional</code> (              <code>tuple(dict, dict)</code> )          \u2013            <p>A tuple of dictionaries of image and segmentation slices. Only if segmentation is not None.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_volume_slices_from_spline(\n    self,\n    volume: np.ndarray,\n    slice_spacing: float,\n    slice_size_um: float,\n    sample_grid_spacing_um: float,\n    interpolation_order: int = 3,\n    max_generation: int | None = None,\n    segmentation: np.ndarray | None = None,\n    approx: bool = False,\n):\n    \"\"\"Sample volume slices from the splines in the graph.\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        The volume to sample slices from.\n    slice_spacing : float\n        The spacing between slices. Normalized between 0 and 1.\n    slice_size_um : float\n        The edge length of the slices in microns.\n        The slice is square.\n    sample_grid_spacing_um : float\n        The spacing of the sample points in microns.\n        This is the size of the pixels in microns in the resulting slices.\n    interpolation_order : int\n        The order of the interpolation to use for the spline.\n        For labels use 0\n    max_generation : int\n        The maximum generation of the spline to sample.\n        If None, all levels are sampled.\n    segmentation : np.ndarray | None\n        The segmentation to sample slices from.\n        If None, only the image is sampled.\n    approx : bool\n        If True, use a quick conversion from normalized arc length\n        coordinates to spline parameter coordinates.\n        The more evenly spaced the spline knots are, the more accurate this\n        approximation becomes.\n        If False, use a binary search to find the parameterized arc length\n        that corresponds to the normalized arc length coordinates.\n        Default value is False.\n\n    Returns\n    -------\n    dict\n        A dictionary of image slices.\n\n    Optional: tuple(dict, dict)\n        A tuple of dictionaries of image and segmentation slices.\n        Only if segmentation is not None.\n\n    \"\"\"\n    image_voxel_size_um = self.voxel_size_um\n\n    origin = self.origin\n    if not origin and origin != 0:\n        raise ValueError(\"No origin node provided. Please set origin.\")\n\n    if image_voxel_size_um is None:\n        logger.warning(\"No voxel size provided. Assuming pixel size is 1 \u00b5m.\")\n        image_voxel_size_um = (1, 1, 1)\n\n    graph = self.graph.copy()\n    generation_dict = nx.get_edge_attributes(graph, GENERATION_KEY)\n    spline_dict = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n\n    image_slice_dict = {}\n    segmentation_slice_dict = {}\n\n    for u, v in nx.breadth_first_search.bfs_edges(graph, source=origin):\n        logger.info(f\"Sampling slices from edge ({u}, {v})\")\n\n        if max_generation and (generation_dict[(u, v)] &gt;= max_generation):\n            break\n        spline = spline_dict[(u, v)]\n        positions = np.linspace(0.1, 0.9, np.ceil(1 / slice_spacing).astype(int))\n        image_slice = spline.sample_volume_2d(\n            volume,\n            positions,\n            grid_shape_um=(slice_size_um, slice_size_um),\n            grid_spacing_um=(sample_grid_spacing_um, sample_grid_spacing_um),\n            sample_interpolation_order=interpolation_order,\n            image_voxel_size_um=image_voxel_size_um,\n            approx=approx,\n        )\n        image_slice_dict[(u, v)] = image_slice\n\n        if segmentation is not None:\n            segmentation_slice = spline.sample_volume_2d(\n                segmentation,\n                positions,\n                grid_shape_um=(slice_size_um, slice_size_um),\n                grid_spacing_um=(sample_grid_spacing_um, sample_grid_spacing_um),\n                sample_interpolation_order=0,\n                image_voxel_size_um=image_voxel_size_um,\n                approx=approx,\n            )\n            segmentation_slice_dict[(u, v)] = segmentation_slice\n\n    if segmentation is not None:\n        return image_slice_dict, segmentation_slice_dict\n    else:\n        return image_slice_dict\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>The volume to sample slices from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(slice_spacing)","title":"<code>slice_spacing</code>","text":"(<code>float</code>)           \u2013            <p>The spacing between slices. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(slice_size_um)","title":"<code>slice_size_um</code>","text":"(<code>float</code>)           \u2013            <p>The edge length of the slices in microns. The slice is square.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(sample_grid_spacing_um)","title":"<code>sample_grid_spacing_um</code>","text":"(<code>float</code>)           \u2013            <p>The spacing of the sample points in microns. This is the size of the pixels in microns in the resulting slices.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the interpolation to use for the spline. For labels use 0</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(max_generation)","title":"<code>max_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(segmentation)","title":"<code>segmentation</code>","text":"(<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>The segmentation to sample slices from. If None, only the image is sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a quick conversion from normalized arc length coordinates to spline parameter coordinates. The more evenly spaced the spline knots are, the more accurate this approximation becomes. If False, use a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates. Default value is False.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel","title":"sample_volume_slices_from_spline_parallel","text":"<pre><code>sample_volume_slices_from_spline_parallel(volume_path: Array, slice_spacing: float, slice_size_um: float, sample_grid_spacing_um: float, interpolation_order: int = 3, max_generation: int | None = None, min_generation: int | None = None, segmentation_path: Array | None = None, num_workers: int = cpu_count() - 2, approx: bool = False)\n</code></pre> <p>Sample volume slices from the splines in the graph in parallel.</p> <p>Loads volume and segmentation data lazily and processes edges in parallel.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_volume_slices_from_spline_parallel(\n    self,\n    volume_path: da.Array,\n    slice_spacing: float,\n    slice_size_um: float,\n    sample_grid_spacing_um: float,\n    interpolation_order: int = 3,\n    max_generation: int | None = None,\n    min_generation: int | None = None,\n    segmentation_path: da.Array | None = None,\n    num_workers: int = os.cpu_count() - 2,\n    approx: bool = False,\n):\n    \"\"\"Sample volume slices from the splines in the graph in parallel.\n\n    Loads volume and segmentation data lazily and processes edges in parallel.\n\n    Parameters\n    ----------\n    volume_path : str\n        The volume path to sample slices from.\n        Must be path to a zarr file. Otherwise its not pickleable.\n    slice_spacing : float\n        The spacing between slices. Normalized between 0 and 1.\n    slice_size_um : int\n        The edge length slices in microns. The slices are square.\n    sample_grid_spacing_um : float\n        The spacing of the sample points in microns.\n        This is the size of the pixels in microns in the resulting slices.\n    interpolation_order : int\n        The order of the interpolation to use for the spline.\n        For labels use 0\n    max_generation : int\n        The maximum generation of the spline to sample.\n        If None, all levels are sampled.\n    min_generation : int\n        The minimum generation of the spline to sample.\n        If None, all levels are sampled.\n    segmentation_path : str | None\n        The segmentation path to sample slices from.\n        Must be path to a zarr file. Otherwise its not pickleable.\n        If None, only the image is sampled.\n    num_workers : int\n        The number of workers to use for parallel processing.\n        Defaults to the number of CPU cores minus 2.\n    approx : bool\n        If True, use the approximate spline evaluation.\n        If False, use the exact spline evaluation.\n\n    \"\"\"\n    image_voxel_size_um = self.voxel_size_um\n    origin = self.origin\n    if not origin and origin != 0:\n        raise ValueError(\"No origin node provided. Please set origin.\")\n\n    if image_voxel_size_um is None:\n        logger.warning(\"No voxel size provided. Assuming pixel size is 1 \u00b5m.\")\n        image_voxel_size_um = (1, 1, 1)\n\n    generation_dict = nx.get_edge_attributes(self.graph, GENERATION_KEY)\n    spline_dict = nx.get_edge_attributes(self.graph, EDGE_SPLINE_KEY)\n\n    # Prepare a list of edges to process\n    edges_to_process = [\n        (u, v)\n        for u, v in nx.breadth_first_search.bfs_edges(self.graph, source=origin)\n        if (max_generation is None or generation_dict[(u, v)] &lt;= max_generation)\n        and (min_generation is None or generation_dict[(u, v)] &gt; min_generation)\n    ]\n\n    # Define a function to process each edge,\n    # needs to be local to be pickable, required for laziness\n    def process_edge(edge):\n        u, v = edge\n        spline = spline_dict[(u, v)]\n        positions = np.linspace(0.1, 0.9, np.ceil(1 / slice_spacing).astype(int))\n        return sample_slices_for_edge(\n            u,\n            v,\n            spline,\n            volume_path,\n            segmentation_path,\n            positions,\n            slice_size_um,\n            sample_grid_spacing_um,\n            interpolation_order,\n            image_voxel_size_um,\n            approx,\n        )\n\n    # Use Dask delayed to process edges in parallel\n    tasks = [delayed(process_edge)(edge) for edge in edges_to_process]\n\n    # Compute all tasks in parallel\n    logger.info(f\"Processing {len(tasks)} edges in parallel.\")\n    with ProgressBar():\n        results = dask.compute(\n            *tasks, num_workers=num_workers, scheduler=\"processes\"\n        )\n\n    # Combine results into dictionaries\n    image_slice_dict = {}\n    segmentation_slice_dict = {}\n\n    for result in results:\n        (u, v), image_slice, segmentation_slice = result\n        image_slice_dict[(u, v)] = image_slice\n        if segmentation_path is not None:\n            segmentation_slice_dict[(u, v)] = segmentation_slice\n    if segmentation_path is not None:\n        return (\n            image_slice_dict,\n            segmentation_slice_dict,\n        )\n    return image_slice_dict\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(volume_path)","title":"<code>volume_path</code>","text":"(<code>str</code>)           \u2013            <p>The volume path to sample slices from. Must be path to a zarr file. Otherwise its not pickleable.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(slice_spacing)","title":"<code>slice_spacing</code>","text":"(<code>float</code>)           \u2013            <p>The spacing between slices. Normalized between 0 and 1.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(slice_size_um)","title":"<code>slice_size_um</code>","text":"(<code>int</code>)           \u2013            <p>The edge length slices in microns. The slices are square.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(sample_grid_spacing_um)","title":"<code>sample_grid_spacing_um</code>","text":"(<code>float</code>)           \u2013            <p>The spacing of the sample points in microns. This is the size of the pixels in microns in the resulting slices.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the interpolation to use for the spline. For labels use 0</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(max_generation)","title":"<code>max_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The maximum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(min_generation)","title":"<code>min_generation</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>The minimum generation of the spline to sample. If None, all levels are sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(segmentation_path)","title":"<code>segmentation_path</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The segmentation path to sample slices from. Must be path to a zarr file. Otherwise its not pickleable. If None, only the image is sampled.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(num_workers)","title":"<code>num_workers</code>","text":"(<code>int</code>, default:                   <code>cpu_count() - 2</code> )           \u2013            <p>The number of workers to use for parallel processing. Defaults to the number of CPU cores minus 2.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.sample_volume_slices_from_spline_parallel(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use the approximate spline evaluation. If False, use the exact spline evaluation.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.to_directed","title":"to_directed","text":"<pre><code>to_directed(origin: int) -&gt; DiGraph\n</code></pre> <p>Return a directed graph from the skeleton graph.</p> <p>The directed graph has the same nodes and edges as the skeleton graph. Stores the origin node as an attribute.</p> <p>The directed graph is stored in-place.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_directed(self, origin: int) -&gt; nx.DiGraph:\n    \"\"\"Return a directed graph from the skeleton graph.\n\n    The directed graph has the same nodes and edges as the skeleton graph.\n    Stores the origin node as an attribute.\n\n    The directed graph is stored in-place.\n\n    Parameters\n    ----------\n    origin : int\n        The node to use as the origin node for the directed graph.\n        The origin node will have no incoming edges.\n    \"\"\"\n    self.graph = make_graph_directed(self.graph, origin)\n    self.origin = origin\n    return self.graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.to_directed(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The node to use as the origin node for the directed graph. The origin node will have no incoming edges.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.SkeletonGraph.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(file_path: str)\n</code></pre> <p>Return a JSON representation of the graph.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def to_json_file(self, file_path: str):\n    \"\"\"Return a JSON representation of the graph.\"\"\"\n    graph_dict = nx.node_link_data(self.graph, edges=\"edges\")\n    # if one of the attributes is not None, add it to the dict\n    # if not add a placeholder\n\n    object_dict = {\n        \"graph\": graph_dict,\n        \"origin\": self.origin,\n        \"image_path\": self.image_path,\n        \"image_key\": self.image_key,\n        \"voxel_size_um\": self.voxel_size_um,\n    }\n\n    with open(file_path, \"w\") as file:\n        json.dump(object_dict, file, indent=2, default=skeleton_graph_encoder)\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.get_next_node_key","title":"get_next_node_key","text":"<pre><code>get_next_node_key(graph: Graph) -&gt; int\n</code></pre> <p>Return the next available node key in the graph.</p> <p>This function assumes the graph node keys are integers.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The next available node key. If there are no nodes, the function returns 0.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def get_next_node_key(graph: nx.Graph) -&gt; int:\n    \"\"\"Return the next available node key in the graph.\n\n    This function assumes the graph node keys are integers.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The graph to get the next node key from.\n\n    Returns\n    -------\n    int\n        The next available node key.\n        If there are no nodes, the function returns 0.\n    \"\"\"\n    node_numbers = list(graph.nodes)\n    node_numbers.sort()\n\n    if len(node_numbers) == 0:\n        return 0\n\n    free_node = node_numbers[0] + 1\n    while free_node in node_numbers:\n        node_numbers.pop(0)\n        free_node = node_numbers[0] + 1\n    return free_node\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.get_next_node_key(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The graph to get the next node key from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.make_graph_directed","title":"make_graph_directed","text":"<pre><code>make_graph_directed(graph: Graph, origin: int) -&gt; DiGraph\n</code></pre> <p>Return a directed graph from an undirected graph.</p> <p>The directed graph has the same nodes and edges as the undirected graph. If the graph is fragmented, meaning has multiple unconnected subgraphs, the function will choose the node with the highest degree as the origin node for each fragment.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def make_graph_directed(graph: nx.Graph, origin: int) -&gt; nx.DiGraph:\n    \"\"\"Return a directed graph from an undirected graph.\n\n    The directed graph has the same nodes and edges as the undirected graph.\n    If the graph is fragmented, meaning has multiple unconnected subgraphs,\n    the function will choose the node with the highest degree as the origin node\n    for each fragment.\n\n    Parameters\n    ----------\n    graph : nx.Graph\n        The undirected graph to convert to a directed graph.\n    origin : int\n        The node to use as the origin node for the directed graph.\n        The origin node will have no incoming edges.\n    \"\"\"\n    if isinstance(graph, nx.DiGraph):\n        logger.info(\"The input graph is already a directed graph.\")\n        return graph\n    if len(list(nx.connected_components(graph))) &gt; 1:\n        logger.warning(\"\"\"\n        The input graph is not connected.\n        The unconnected components might lose edges\n        \"\"\")\n        origin_part = nx.node_connected_component(graph, origin)\n        fragments = graph.subgraph(set(graph.nodes()) - origin_part)\n        graph = graph.subgraph(origin_part)\n    else:\n        fragments = None\n\n    di_graph = nx.DiGraph(graph)\n    di_graph.remove_edges_from(di_graph.edges - nx.bfs_edges(di_graph, origin))\n\n    if fragments:\n        # choose a node with the highest degree as the origin node\n        # Do this for each fragment\n        for fragment in nx.connected_components(fragments):\n            fragment_subgraph = fragments.subgraph(fragment)\n            \"\"\"Choose a origin of the fragment with the highest degree.\n            This is arbitrary but finding a better node\n            without knowledge were the network broke is hard\"\"\"\n            origin = max(fragment_subgraph.degree, key=lambda x: x[1])[0]\n            di_fragment = nx.DiGraph(fragment_subgraph)\n            di_fragment.remove_edges_from(\n                di_fragment.edges - nx.bfs_edges(di_fragment, origin)\n            )\n            di_graph.add_edges_from(di_fragment.edges(data=True))\n            di_graph.add_nodes_from(di_fragment.nodes(data=True))\n\n    return di_graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.make_graph_directed(graph)","title":"<code>graph</code>","text":"(<code>Graph</code>)           \u2013            <p>The undirected graph to convert to a directed graph.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.make_graph_directed(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The node to use as the origin node for the directed graph. The origin node will have no incoming edges.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.orient_splines","title":"orient_splines","text":"<pre><code>orient_splines(graph: DiGraph, approximate_positions: bool = False) -&gt; DiGraph\n</code></pre> <p>Checks if the splines are oriented correctly.</p> <p>If the beginning of the spline is closer to the end node than the start node, it gets flipped and vice versa.</p> <p>Also checks if the edge coordinates are aligned with the spline. This only checks, if the splines are correctly connected to the nodes, not the order in the Graph. Best used on a directed graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with the splines oriented correctly.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def orient_splines(\n    graph: nx.DiGraph, approximate_positions: bool = False\n) -&gt; nx.DiGraph:\n    \"\"\"Checks if the splines are oriented correctly.\n\n    If the beginning of the spline is closer to the end node than the start node,\n    it gets flipped and vice versa.\n\n    Also checks if the edge coordinates are aligned with the spline.\n    This only checks, if the splines are correctly connected to the nodes,\n    not the order in the Graph. Best used on a directed graph.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph to orient the splines in.\n    approximate_positions : bool\n        Whether to use approximate positions for the spline evaluation.\n        This is faster but less accurate. Default is False.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with the splines oriented correctly.\n\n    \"\"\"\n    edge_spline_dict = {}\n    edge_coordinates_dict = {}\n\n    for u, v, attr in graph.edges(data=True):\n        spline = attr[EDGE_SPLINE_KEY]\n        u_coord = graph.nodes[u][NODE_COORDINATE_KEY]\n        v_coord = graph.nodes[v][NODE_COORDINATE_KEY]\n\n        # Evaluate spline endpoints\n        spline_start, spline_end = spline.eval(\n            np.array([0.01, 0.99]), approx=approximate_positions\n        )\n\n        # Compute distances from spline endpoints to node positions\n        dist_start_to_u = np.linalg.norm(spline_start - u_coord)\n        dist_start_to_v = np.linalg.norm(spline_start - v_coord)\n        dist_end_to_u = np.linalg.norm(spline_end - u_coord)\n        dist_end_to_v = np.linalg.norm(spline_end - v_coord)\n\n        # Orientation is correct if start\u2192u and end\u2192v are both closest\n        start_correct = dist_start_to_u &lt; dist_start_to_v\n        end_correct = dist_end_to_v &lt; dist_end_to_u\n\n        # If either endpoint is closer to the wrong node, flip it\n        if not (start_correct and end_correct):\n            logger.info(f\"Flipped spline of edge ({u},{v}).\")\n\n            edge_coordinates = attr[EDGE_COORDINATES_KEY]\n            flipped_spline, flipped_cords = spline.flip_spline(edge_coordinates)\n            edge_spline_dict[(u, v)] = flipped_spline\n            edge_coordinates_dict[(u, v)] = flipped_cords\n\n    nx.set_edge_attributes(graph, edge_spline_dict, EDGE_SPLINE_KEY)\n    nx.set_edge_attributes(graph, edge_coordinates_dict, EDGE_COORDINATES_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.orient_splines(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph to orient the splines in.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.orient_splines(approximate_positions)","title":"<code>approximate_positions</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use approximate positions for the spline evaluation. This is faster but less accurate. Default is False.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge","title":"sample_slices_for_edge","text":"<pre><code>sample_slices_for_edge(u: int, v: int, spline: B3Spline, volume_path: str, segmentation_path: str | None, positions: ndarray, slice_size_um: float, sample_grid_spacing_um: float, interpolation_order: int, image_voxel_size_um: float, approx: bool)\n</code></pre> <p>Helper function for parallel execution.</p> <p>This function is used to sample slices from a spline in a skeleton graph.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the edge (u, v), image slice, and segmentation slice.</p> </li> </ul> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def sample_slices_for_edge(\n    u: int,\n    v: int,\n    spline: B3Spline,\n    volume_path: str,\n    segmentation_path: str | None,\n    positions: np.ndarray,\n    slice_size_um: float,\n    sample_grid_spacing_um: float,\n    interpolation_order: int,\n    image_voxel_size_um: float,\n    approx: bool,\n):\n    \"\"\"Helper function for parallel execution.\n\n    This function is used to sample slices from a spline in a skeleton graph.\n\n    Parameters\n    ----------\n    u : int\n        The source node of the edge.\n    v : int\n        The target node of the edge.\n    spline : B3Spline\n        The spline to sample from.\n    volume_path : str\n        The path to the volume to sample from.\n    segmentation_path : str\n        The path to the segmentation to sample from.\n    positions : np.ndarray\n        The positions to sample from.\n    slice_size_um : float\n        The edge width of the slice in microns.\n    sample_grid_spacing_um : float\n        The spacing of the sample points in microns.\n    interpolation_order : int\n        The order of the interpolation to use.\n    image_voxel_size_um : float\n        The voxel size of the image in micrometers.\n    approx : bool\n        Whether to use approximate sampling.\n\n    Returns\n    -------\n    tuple\n        A tuple containing the edge (u, v), image slice, and segmentation slice.\n\n    \"\"\"\n    logger.info(f\"Sampling slices from edge ({u}, {v})\")\n\n    volume = da.from_zarr(volume_path, chunks=\"auto\")\n\n    image_slice = spline.sample_volume_2d(\n        volume,\n        positions,\n        grid_shape_um=(slice_size_um, slice_size_um),\n        grid_spacing_um=(sample_grid_spacing_um, sample_grid_spacing_um),\n        sample_interpolation_order=interpolation_order,\n        sample_fill_value=0,\n        image_voxel_size_um=image_voxel_size_um,\n        approx=approx,\n    )\n\n    segmentation_slice = None\n    if segmentation_path is not None:\n        segmentation = da.from_zarr(segmentation_path, chunks=\"auto\")\n        segmentation_slice = spline.sample_volume_2d(\n            segmentation,\n            positions,\n            grid_shape_um=(slice_size_um, slice_size_um),\n            grid_spacing_um=(sample_grid_spacing_um, sample_grid_spacing_um),\n            sample_interpolation_order=0,\n            image_voxel_size_um=image_voxel_size_um,\n            sample_fill_value=0,\n            approx=approx,\n        )\n\n    return (u, v), image_slice, segmentation_slice\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(u)","title":"<code>u</code>","text":"(<code>int</code>)           \u2013            <p>The source node of the edge.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(v)","title":"<code>v</code>","text":"(<code>int</code>)           \u2013            <p>The target node of the edge.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(spline)","title":"<code>spline</code>","text":"(<code>B3Spline</code>)           \u2013            <p>The spline to sample from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(volume_path)","title":"<code>volume_path</code>","text":"(<code>str</code>)           \u2013            <p>The path to the volume to sample from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(segmentation_path)","title":"<code>segmentation_path</code>","text":"(<code>str</code>)           \u2013            <p>The path to the segmentation to sample from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>The positions to sample from.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(slice_size_um)","title":"<code>slice_size_um</code>","text":"(<code>float</code>)           \u2013            <p>The edge width of the slice in microns.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(sample_grid_spacing_um)","title":"<code>sample_grid_spacing_um</code>","text":"(<code>float</code>)           \u2013            <p>The spacing of the sample points in microns.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(interpolation_order)","title":"<code>interpolation_order</code>","text":"(<code>int</code>)           \u2013            <p>The order of the interpolation to use.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>float</code>)           \u2013            <p>The voxel size of the image in micrometers.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.sample_slices_for_edge(approx)","title":"<code>approx</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to use approximate sampling.</p>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.skeleton_graph_decoder","title":"skeleton_graph_decoder","text":"<pre><code>skeleton_graph_decoder(json_object)\n</code></pre> <p>JSON decoder for the networkx skeleton graph.</p> <p>This function is to be used with the Python json.load(s) functions as the <code>object_hook</code> keyword argument.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def skeleton_graph_decoder(json_object):\n    \"\"\"JSON decoder for the networkx skeleton graph.\n\n    This function is to be used with the Python json.load(s) functions\n    as the `object_hook` keyword argument.\n    \"\"\"\n    if \"__class__\" in json_object:\n        # all custom classes are identified by the __class__ key\n        if json_object[\"__class__\"] == \"splinebox.Spline\":\n            json_object.pop(\"__class__\")\n            spline_kwargs = _prepared_dict_for_constructor(json_object)\n            return SplineboxSpline(**spline_kwargs)\n        if json_object[\"__class__\"] == \"skeleplex.B3Spline\":\n            return B3Spline.from_json_dict(json_object)\n\n    # Convert lists back to numpy arrays\n    for key, value in json_object.items():\n        if isinstance(value, list):\n            if key in [NODE_COORDINATE_KEY, EDGE_COORDINATES_KEY]:\n                try:\n                    json_object[key] = np.array(value)\n                except Exception:\n                    pass  # If conversion fails, keep it as a list\n\n            if key in [SISTER_EDGE_KEY, DAUGHTER_EDGES_KEY, PARENT_EDGE_KEY]:\n                if key == DAUGHTER_EDGES_KEY:\n                    json_object[key] = [tuple(edge) for edge in value]\n                else:\n                    json_object[key] = tuple(value)\n\n    # Convert lists back to numpy arrays\n    for key, value in json_object.items():\n        if isinstance(value, list):\n            if key in [NODE_COORDINATE_KEY, EDGE_COORDINATES_KEY]:\n                try:\n                    json_object[key] = np.array(value)\n                except Exception:\n                    pass  # If conversion fails, keep it as a list\n\n            if key in [SISTER_EDGE_KEY, DAUGHTER_EDGES_KEY, PARENT_EDGE_KEY]:\n                if key == DAUGHTER_EDGES_KEY:\n                    json_object[key] = [tuple(edge) for edge in value]\n                else:\n                    json_object[key] = tuple(value)\n\n    return json_object\n</code></pre>"},{"location":"reference/skeleplex/graph/skeleton_graph/#skeleplex.graph.skeleton_graph.skeleton_graph_encoder","title":"skeleton_graph_encoder","text":"<pre><code>skeleton_graph_encoder(object_to_encode)\n</code></pre> <p>JSON encoder for the networkx skeleton graph.</p> <p>This function is to be used with the Python json.dump(s) functions as the <code>default</code> keyword argument.</p> Source code in <code>skeleplex/graph/skeleton_graph.py</code> <pre><code>def skeleton_graph_encoder(object_to_encode):\n    \"\"\"JSON encoder for the networkx skeleton graph.\n\n    This function is to be used with the Python json.dump(s) functions\n    as the `default` keyword argument.\n    \"\"\"\n    if isinstance(object_to_encode, np.ndarray):\n        return object_to_encode.tolist()\n    elif isinstance(object_to_encode, SplineboxSpline):\n        spline_dict = object_to_encode._to_dict(version=2)\n        if \"__class__\" in spline_dict:\n            raise ValueError(\n                \"The Spline object to encode already has a '__class__' key.\"\n            )\n        spline_dict.update({\"__class__\": \"splinebox.Spline\"})\n        return spline_dict\n    elif isinstance(object_to_encode, B3Spline):\n        return object_to_encode.to_json_dict()\n    raise TypeError(f\"Object of type {type(object_to_encode)} is not JSON serializable\")\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/","title":"spline","text":""},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline","title":"skeleplex.graph.spline","text":"<p>Utilities for fitting and working with splines.</p> <p>Classes:</p> <ul> <li> <code>B3Spline</code>           \u2013            <p>Model for a B3 spline.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline","title":"B3Spline","text":"<pre><code>B3Spline(model: Spline)\n</code></pre> <p>Model for a B3 spline.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>curvature</code>             \u2013              <p>Evaluate the curvature of the spline at a set of positions.</p> </li> <li> <code>eval</code>             \u2013              <p>Evaluate the spline at a set of positions.</p> </li> <li> <code>flip_spline</code>             \u2013              <p>Recomputes the spline inverse to the path.</p> </li> <li> <code>from_json_dict</code>             \u2013              <p>Return a B3Spline from a JSON serializable dictionary.</p> </li> <li> <code>from_json_file</code>             \u2013              <p>Construct a B3Spline from a JSON file.</p> </li> <li> <code>from_points</code>             \u2013              <p>Construct a B3 spline fit to a list of points.</p> </li> <li> <code>moving_frame</code>             \u2013              <p>Generate a moving frame long the spline at specified positions.</p> </li> <li> <code>sample_volume_2d</code>             \u2013              <p>Sample a 3D image with 2D planes normal to the spline at specified positions.</p> </li> <li> <code>to_json_dict</code>             \u2013              <p>Return a JSON serializable dictionary.</p> </li> <li> <code>to_json_file</code>             \u2013              <p>Save the spline to a JSON file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>arc_length</code>               (<code>float</code>)           \u2013            <p>Return the arc length of the spline.</p> </li> <li> <code>model</code>               (<code>Spline</code>)           \u2013            <p>Return the underlying spline model.</p> </li> </ul> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def __init__(self, model: splinebox.Spline):\n    self._model = model\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline(model)","title":"<code>model</code>","text":"(<code>Spline</code>)           \u2013            <p>The spline model.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.arc_length","title":"arc_length  <code>property</code>","text":"<pre><code>arc_length: float\n</code></pre> <p>Return the arc length of the spline.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.model","title":"model  <code>property</code>","text":"<pre><code>model: Spline\n</code></pre> <p>Return the underlying spline model.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.curvature","title":"curvature","text":"<pre><code>curvature(positions: ndarray, approx: bool = False, atol: float = 1e-06) -&gt; ndarray\n</code></pre> <p>Evaluate the curvature of the spline at a set of positions.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def curvature(\n    self,\n    positions: np.ndarray,\n    approx: bool = False,\n    atol: float = 1e-6,\n) -&gt; np.ndarray:\n    \"\"\"Evaluate the curvature of the spline at a set of positions.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    approx : bool\n        If True, use a quick conversion from normalized arc length\n        coordinates to spline parameter coordinates.\n        The more evenly spaced the spline knots are, the more accurate this\n        approximation becomes.\n        If False, use a binary search to find the parameterized arc length\n        that corresponds to the normalized arc length coordinates.\n        Default value is False.\n    atol : float\n        The absolute tolerance for converting the normalized\n        evaluation positions to positions along the spline.\n        Default value is 1e-6.\n    \"\"\"\n    if approx:\n        positions_t = positions * (self.model.M - 1)\n        # error computation is expensive, comment out for now\n        # error = self.model.arc_length(positions_t) - (positions * self.arc_length)\n        positions_t = np.asarray(positions_t)\n    else:\n        positions_t = self.model.arc_length_to_parameter(\n            positions * self.arc_length, atol=atol\n        )\n    # For single values, splinebox's eval expects a float\n    # This recasts the value to a float if positions_t is a single value\n    if positions_t.ndim == 0:\n        positions_t = positions_t.tolist()\n\n    return self.model.curvature(positions_t)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.curvature(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.curvature(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a quick conversion from normalized arc length coordinates to spline parameter coordinates. The more evenly spaced the spline knots are, the more accurate this approximation becomes. If False, use a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates. Default value is False.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.curvature(atol)","title":"<code>atol</code>","text":"(<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The absolute tolerance for converting the normalized evaluation positions to positions along the spline. Default value is 1e-6.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval","title":"eval","text":"<pre><code>eval(positions: ndarray, derivative: int = 0, approx: bool = False, atol: float = 1e-06) -&gt; ndarray\n</code></pre> <p>Evaluate the spline at a set of positions.</p> <p>Uses a quick conversion from normalized arc length coordinates to spline parameter coordinates. If approx is set to False, then arc_length_to_parameter is called instead. This uses a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates, but is slower.</p> <p>Uses a quick conversion from normalized arc length coordinates to spline parameter coordinates. If approx is set to False, then arc_length_to_parameter is called instead. This uses a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates, but is slower.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def eval(\n    self,\n    positions: np.ndarray,\n    derivative: int = 0,\n    approx: bool = False,\n    atol: float = 1e-6,\n) -&gt; np.ndarray:\n    \"\"\"Evaluate the spline at a set of positions.\n\n    Uses a quick conversion from normalized arc length coordinates to\n    spline parameter coordinates. If approx is set to False, then\n    arc_length_to_parameter is called instead. This uses a binary search\n    to find the parameterized arc length that corresponds to the normalized\n    arc length coordinates, but is slower.\n\n    Uses a quick conversion from normalized arc length coordinates to\n    spline parameter coordinates. If approx is set to False, then\n    arc_length_to_parameter is called instead. This uses a binary search\n    to find the parameterized arc length that corresponds to the normalized\n    arc length coordinates, but is slower.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    derivative : int\n        The order of the derivative to evaluate.\n        Default value is 0.\n    approx : bool\n        If True, use a quick conversion from normalized arc length\n        coordinates to spline parameter coordinates.\n        The more evenly spaced the spline knots are, the more accurate this\n        approximation becomes.\n        If False, use a binary search to find the parameterized arc length\n        that corresponds to the normalized arc length coordinates.\n        Default value is False.\n    approx : bool\n        If True, use a quick conversion from normalized arc length\n        coordinates to spline parameter coordinates.\n        The more evenly spaced the spline knots are, the more accurate this\n        approximation becomes.\n        If False, use a binary search to find the parameterized arc length\n        that corresponds to the normalized arc length coordinates.\n        Default value is False.\n    atol : float\n        The absolute tolerance for converting the normalized\n        evaluation positions to positions along the spline.\n        Default value is 1e-6.\n\n\n    \"\"\"\n    if approx:\n        positions_t = positions * (self.model.M - 1)\n        # error computation is expensive, comment out for now\n        # error = self.model.arc_length(positions_t) - (positions * self.arc_length)\n        positions_t = np.asarray(positions_t)\n    else:\n        positions_t = self.model.arc_length_to_parameter(\n            positions * self.arc_length, atol=atol\n        )\n    # For single values, splinebox's eval expects a float\n    # This recasts the value to a float if positions_t is a single value\n    if positions_t.ndim == 0:\n        positions_t = positions_t.tolist()\n\n    return self.model.eval(positions_t, derivative=derivative)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(derivative)","title":"<code>derivative</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The order of the derivative to evaluate. Default value is 0.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a quick conversion from normalized arc length coordinates to spline parameter coordinates. The more evenly spaced the spline knots are, the more accurate this approximation becomes. If False, use a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates. Default value is False.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use a quick conversion from normalized arc length coordinates to spline parameter coordinates. The more evenly spaced the spline knots are, the more accurate this approximation becomes. If False, use a binary search to find the parameterized arc length that corresponds to the normalized arc length coordinates. Default value is False.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.eval(atol)","title":"<code>atol</code>","text":"(<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The absolute tolerance for converting the normalized evaluation positions to positions along the spline. Default value is 1e-6.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.flip_spline","title":"flip_spline","text":"<pre><code>flip_spline(path: ndarray) -&gt; B3Spline\n</code></pre> <p>Recomputes the spline inverse to the path.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>B3Spline</code>           \u2013            <p>The flipped spline.</p> </li> <li> <code>ndarray</code>           \u2013            <p>The flipped path coordinates.</p> </li> </ul> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def flip_spline(self, path: np.ndarray) -&gt; \"B3Spline\":\n    \"\"\"Recomputes the spline inverse to the path.\n\n    Parameters\n    ----------\n    path : np.ndarray\n        The coordinates to fit the spline to.\n\n    Returns\n    -------\n    B3Spline\n        The flipped spline.\n    np.ndarray\n        The flipped path coordinates.\n    \"\"\"\n    return self.from_points(path[::-1]), path[::-1]\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.flip_spline(path)","title":"<code>path</code>","text":"(<code>ndarray</code>)           \u2013            <p>The coordinates to fit the spline to.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_json_dict","title":"from_json_dict  <code>classmethod</code>","text":"<pre><code>from_json_dict(json_dict: dict) -&gt; B3Spline\n</code></pre> <p>Return a B3Spline from a JSON serializable dictionary.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>@classmethod\ndef from_json_dict(cls, json_dict: dict) -&gt; \"B3Spline\":\n    \"\"\"Return a B3Spline from a JSON serializable dictionary.\"\"\"\n    if json_dict[\"backend\"] != cls._backend:\n        raise ValueError(\n            f\"Expected backend {cls._backend}, got {json_dict['backend']}.\"\n        )\n\n    # load the spline model\n    spline_model_dict = json_dict[\"model\"]\n\n    if isinstance(spline_model_dict, splinebox.Spline):\n        # model has already been deserialized\n        # this can happen if a this is being called\n        # within another JSON decoder.\n        return cls(model=spline_model_dict)\n\n    spline_model_dict.pop(\"__class__\")\n    spline_kwargs = _prepared_dict_for_constructor(spline_model_dict)\n    spline_model = splinebox.Spline(**spline_kwargs)\n\n    # make the class\n    return cls(model=spline_model)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_json_file","title":"from_json_file  <code>classmethod</code>","text":"<pre><code>from_json_file(file_path: str) -&gt; B3Spline\n</code></pre> <p>Construct a B3Spline from a JSON file.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>@classmethod\ndef from_json_file(cls, file_path: str) -&gt; \"B3Spline\":\n    \"\"\"Construct a B3Spline from a JSON file.\"\"\"\n    with open(file_path) as file:\n        json_dict = json.load(file)\n    return cls.from_json_dict(json_dict)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_points","title":"from_points  <code>classmethod</code>","text":"<pre><code>from_points(points: ndarray, n_knots: int = 4)\n</code></pre> <p>Construct a B3 spline fit to a list of points.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>@classmethod\ndef from_points(cls, points: np.ndarray, n_knots: int = 4):\n    \"\"\"Construct a B3 spline fit to a list of points.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n, d) array of points to fit the spline to.\n        These must be ordered in the positive t direction\n        of the spline.\n    n_knots : int\n        The number of knots to use in the spline.\n    \"\"\"\n    basis_function = splinebox.B3()\n    spline = splinebox.Spline(\n        M=n_knots, basis_function=basis_function, closed=False\n    )\n    spline.fit(points)\n    return cls(model=spline)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_points(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n, d) array of points to fit the spline to. These must be ordered in the positive t direction of the spline.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.from_points(n_knots)","title":"<code>n_knots</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>The number of knots to use in the spline.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame","title":"moving_frame","text":"<pre><code>moving_frame(positions: ndarray, method: str = 'bishop', atol: float = 1e-06)\n</code></pre> <p>Generate a moving frame long the spline at specified positions.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def moving_frame(\n    self, positions: np.ndarray, method: str = \"bishop\", atol: float = 1e-6\n):\n    \"\"\"Generate a moving frame long the spline at specified positions.\n\n    Parameters\n    ----------\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    method : str\n        The method to use for generating the moving frame.\n        Default value is \"bishop\".\n    atol : float\n        The absolute tolerance for converting the normalized\n        evaluation positions to positions along the spline.\n        Default value is 1e-6.\n    \"\"\"\n    # convert the normalized arc length coordinates to t\n    positions_t = self.model.arc_length_to_parameter(\n        positions * self.arc_length, atol=atol\n    )\n    return self.model.moving_frame(positions_t, method=method)\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame(method)","title":"<code>method</code>","text":"(<code>str</code>, default:                   <code>'bishop'</code> )           \u2013            <p>The method to use for generating the moving frame. Default value is \"bishop\".</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.moving_frame(atol)","title":"<code>atol</code>","text":"(<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The absolute tolerance for converting the normalized evaluation positions to positions along the spline. Default value is 1e-6.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d","title":"sample_volume_2d","text":"<pre><code>sample_volume_2d(volume: ndarray, positions: ndarray, grid_shape_um: tuple[int, int] = (10, 10), grid_spacing_um: tuple[float, float] = (1, 1), moving_frame_method: str = 'bishop', sample_interpolation_order: int = 3, sample_fill_value: float = nan, image_voxel_size_um: tuple[float, float, float] = (1, 1, 1), approx: bool = False)\n</code></pre> <p>Sample a 3D image with 2D planes normal to the spline at specified positions.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def sample_volume_2d(\n    self,\n    volume: np.ndarray,\n    positions: np.ndarray,\n    grid_shape_um: tuple[int, int] = (10, 10),\n    grid_spacing_um: tuple[float, float] = (1, 1),\n    moving_frame_method: str = \"bishop\",\n    sample_interpolation_order: int = 3,\n    sample_fill_value: float = np.nan,\n    image_voxel_size_um: tuple[float, float, float] = (1, 1, 1),\n    approx: bool = False,\n):\n    \"\"\"Sample a 3D image with 2D planes normal to the spline at specified positions.\n\n    Parameters\n    ----------\n    volume : np.ndarray\n        3D image to sample.\n    positions : np.ndarray\n        (n,) array of positions to evaluate the spline at.\n        The positions are normalized to the range [0, 1].\n    grid_shape_um : tuple[int, int]\n        The length along each axis of the resulting 2D image in microns.\n        Default value is (10, 10).\n    grid_spacing_um : tuple[float, float]\n        Spacing between points in the sampling grid in microns.\n        Default value is (1, 1).\n    moving_frame_method : str\n        The method to use for generating the moving frame.\n        Default value is \"bishop\".\n    sample_interpolation_order : int\n        The order of the spline interpolation to use when sampling the image.\n        Default value is 3.\n    sample_fill_value : float\n        The fill value to use when sampling the image outside\n        the bounds of the array. Default value is np.nan.\n    image_voxel_size_um : tuple[float, float, float]\n        The voxel size of the image.\n        Default value is (1, 1, 1).\n    approx : bool\n        If True, use the approximate method for evaluating the spline.\n        If False, use the exact method.\n        Default is False.\n    \"\"\"\n    moving_frame = self.moving_frame(\n        positions=positions, method=moving_frame_method\n    )\n\n    # generate the grid of points for sampling the image\n    # (shape (w, h, 3))\n    sampling_grid_um = generate_2d_grid(\n        grid_shape=grid_shape_um, grid_spacing=grid_spacing_um\n    )\n\n    # reshape the sampling grid to be a list of coordinates\n    grid_coords_um = sampling_grid_um.reshape(-1, 3)\n\n    # apply each orientation to the grid for each position and store the result\n    rotated = []\n    for frame in moving_frame:\n        rotation_matrix = np.column_stack([frame[0], frame[1], frame[2]])\n        orientation = Rotation.from_matrix(rotation_matrix)\n        rotated.append(orientation.apply(grid_coords_um))\n\n    rotated_um = np.stack(rotated, axis=1)\n    rotated_vx = rotated_um / np.array(image_voxel_size_um)\n\n    # get the coordinates of the points on the spline to center\n    # the sampling grid for the 2D image.\n    sample_centroid_coordinates = self.eval(\n        positions=positions,\n        approx=approx,\n    )\n    sample_centroid_coordinates_vx = sample_centroid_coordinates / np.array(\n        image_voxel_size_um\n    )\n\n    # shift the rotated points to be centered on the spline\n    rotated_shifted_vx = rotated_vx + sample_centroid_coordinates_vx\n    placed_sample_grids_vx = rotated_shifted_vx.reshape(-1, *sampling_grid_um.shape)\n\n    if type(volume) is da.Array:\n        return sample_volume_at_coordinates_lazy(\n            volume=volume,\n            coordinates=placed_sample_grids_vx,\n            interpolation_order=sample_interpolation_order,\n            fill_value=sample_fill_value,\n        )\n    else:\n        return sample_volume_at_coordinates(\n            volume=volume,\n            coordinates=placed_sample_grids_vx,\n            interpolation_order=sample_interpolation_order,\n            fill_value=sample_fill_value,\n        )\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(volume)","title":"<code>volume</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D image to sample.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(positions)","title":"<code>positions</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n,) array of positions to evaluate the spline at. The positions are normalized to the range [0, 1].</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(grid_shape_um)","title":"<code>grid_shape_um</code>","text":"(<code>tuple[int, int]</code>, default:                   <code>(10, 10)</code> )           \u2013            <p>The length along each axis of the resulting 2D image in microns. Default value is (10, 10).</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(grid_spacing_um)","title":"<code>grid_spacing_um</code>","text":"(<code>tuple[float, float]</code>, default:                   <code>(1, 1)</code> )           \u2013            <p>Spacing between points in the sampling grid in microns. Default value is (1, 1).</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(moving_frame_method)","title":"<code>moving_frame_method</code>","text":"(<code>str</code>, default:                   <code>'bishop'</code> )           \u2013            <p>The method to use for generating the moving frame. Default value is \"bishop\".</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(sample_interpolation_order)","title":"<code>sample_interpolation_order</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The order of the spline interpolation to use when sampling the image. Default value is 3.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(sample_fill_value)","title":"<code>sample_fill_value</code>","text":"(<code>float</code>, default:                   <code>nan</code> )           \u2013            <p>The fill value to use when sampling the image outside the bounds of the array. Default value is np.nan.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(image_voxel_size_um)","title":"<code>image_voxel_size_um</code>","text":"(<code>tuple[float, float, float]</code>, default:                   <code>(1, 1, 1)</code> )           \u2013            <p>The voxel size of the image. Default value is (1, 1, 1).</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.sample_volume_2d(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, use the approximate method for evaluating the spline. If False, use the exact method. Default is False.</p>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.to_json_dict","title":"to_json_dict","text":"<pre><code>to_json_dict() -&gt; dict\n</code></pre> <p>Return a JSON serializable dictionary.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def to_json_dict(self) -&gt; dict:\n    \"\"\"Return a JSON serializable dictionary.\"\"\"\n    spline_model_dict = self.model._to_dict(version=2)\n    if \"__class__\" in spline_model_dict:\n        raise ValueError(\n            \"The Spline object to encode already has a '__class__' key.\"\n        )\n    spline_model_dict.update({\"__class__\": \"splinebox.Spline\"})\n    return {\n        \"__class__\": \"skeleplex.B3Spline\",\n        \"model\": spline_model_dict,\n        \"backend\": self._backend,\n    }\n</code></pre>"},{"location":"reference/skeleplex/graph/spline/#skeleplex.graph.spline.B3Spline.to_json_file","title":"to_json_file","text":"<pre><code>to_json_file(file_path: str) -&gt; None\n</code></pre> <p>Save the spline to a JSON file.</p> Source code in <code>skeleplex/graph/spline.py</code> <pre><code>def to_json_file(self, file_path: str) -&gt; None:\n    \"\"\"Save the spline to a JSON file.\"\"\"\n    with open(file_path, \"w\") as file:\n        json.dump(self.to_json_dict(), file)\n</code></pre>"},{"location":"reference/skeleplex/graph/utils/","title":"utils","text":""},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils","title":"skeleplex.graph.utils","text":"<p>Functions:</p> <ul> <li> <code>draw_line_segment</code>             \u2013              <p>Draw a line segment in-place.</p> </li> <li> <code>select_points_in_bounding_box</code>             \u2013              <p>From an array of points, select all points inside a specified bounding box.</p> </li> <li> <code>write_slices_to_h5</code>             \u2013              <p>Write image and segmentation slices to an h5 file.</p> </li> </ul>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.draw_line_segment","title":"draw_line_segment","text":"<pre><code>draw_line_segment(start_point: ndarray, end_point: ndarray, skeleton_image: ndarray, fill_value: int = 1, return_line: bool = False)\n</code></pre> <p>Draw a line segment in-place.</p> <p>Note: line will be clipped if it extends beyond the bounding box of the skeleton_image.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/utils.py</code> <pre><code>def draw_line_segment(\n    start_point: np.ndarray,\n    end_point: np.ndarray,\n    skeleton_image: np.ndarray,\n    fill_value: int = 1,\n    return_line: bool = False,\n):\n    \"\"\"Draw a line segment in-place.\n\n    Note: line will be clipped if it extends beyond the\n    bounding box of the skeleton_image.\n\n    Parameters\n    ----------\n    start_point : np.ndarray\n        (d,) array containing the starting point of the line segment.\n        Must be an integer index.\n    end_point : np.ndarray\n        (d,) array containing the end point of the line segment.\n        Most be an integer index\n    skeleton_image : np.ndarray\n        The image in which to draw the line segment.\n        Must be the same dimensionality as start_point and end_point.\n    fill_value : int\n        The value to use for the line segment.\n        Default value is 1.\n    return_line : bool\n        If True, return the coordinates of the line segment. Default is False.\n    \"\"\"\n    branch_length = np.linalg.norm(end_point - start_point)\n    n_skeleton_points = int(2 * branch_length)\n    skeleton_points = np.linspace(start_point, end_point, n_skeleton_points)\n\n    # filter for points within the image\n    image_bounds = np.asarray(skeleton_image.shape) - 1\n    skeleton_points = select_points_in_bounding_box(\n        points=skeleton_points,\n        lower_left_corner=np.array([0, 0, 0]),\n        upper_right_corner=image_bounds,\n    ).astype(int)\n    skeleton_image[\n        skeleton_points[:, 0], skeleton_points[:, 1], skeleton_points[:, 2]\n    ] = fill_value\n\n    if return_line:\n        return skeleton_points\n</code></pre>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.draw_line_segment(start_point)","title":"<code>start_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(d,) array containing the starting point of the line segment. Must be an integer index.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.draw_line_segment(end_point)","title":"<code>end_point</code>","text":"(<code>ndarray</code>)           \u2013            <p>(d,) array containing the end point of the line segment. Most be an integer index</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.draw_line_segment(skeleton_image)","title":"<code>skeleton_image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The image in which to draw the line segment. Must be the same dimensionality as start_point and end_point.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.draw_line_segment(fill_value)","title":"<code>fill_value</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The value to use for the line segment. Default value is 1.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.draw_line_segment(return_line)","title":"<code>return_line</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the coordinates of the line segment. Default is False.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.select_points_in_bounding_box","title":"select_points_in_bounding_box","text":"<pre><code>select_points_in_bounding_box(points: ndarray, lower_left_corner: ndarray, upper_right_corner: ndarray) -&gt; ndarray\n</code></pre> <p>From an array of points, select all points inside a specified bounding box.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>points_in_box</code> (              <code>ndarray</code> )          \u2013            <p>The n x d array containing the n points inside of the specified bounding box.</p> </li> </ul> Source code in <code>skeleplex/graph/utils.py</code> <pre><code>def select_points_in_bounding_box(\n    points: np.ndarray,\n    lower_left_corner: np.ndarray,\n    upper_right_corner: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"From an array of points, select all points inside a specified bounding box.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        The n x d array containing the n, d-dimensional points to check.\n    lower_left_corner : np.ndarray\n        The point corresponding to the corner of the bounding box\n        with lowest coordinate values.\n    upper_right_corner : np.ndarray\n        The point corresponding to the corner of the bounding box\n        with the highest coordinate values.\n\n    Returns\n    -------\n    points_in_box : np.ndarray\n        The n x d array containing the n points inside of the\n        specified bounding box.\n    \"\"\"\n    in_box_mask = np.all(\n        np.logical_and(lower_left_corner &lt;= points, upper_right_corner &gt;= points),\n        axis=1,\n    )\n    return points[in_box_mask]\n</code></pre>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.select_points_in_bounding_box(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>The n x d array containing the n, d-dimensional points to check.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.select_points_in_bounding_box(lower_left_corner)","title":"<code>lower_left_corner</code>","text":"(<code>ndarray</code>)           \u2013            <p>The point corresponding to the corner of the bounding box with lowest coordinate values.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.select_points_in_bounding_box(upper_right_corner)","title":"<code>upper_right_corner</code>","text":"(<code>ndarray</code>)           \u2013            <p>The point corresponding to the corner of the bounding box with the highest coordinate values.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5","title":"write_slices_to_h5","text":"<pre><code>write_slices_to_h5(file_path: str, file_base: str, image_slices: dict, segmentation_slices: dict | None = None, image_key: str = 'image', segmentation_key: str = 'segmentation')\n</code></pre> <p>Write image and segmentation slices to an h5 file.</p> <p>Parameters:</p> Source code in <code>skeleplex/graph/utils.py</code> <pre><code>def write_slices_to_h5(\n    file_path: str,\n    file_base: str,\n    image_slices: dict,\n    segmentation_slices: dict | None = None,\n    image_key: str = \"image\",\n    segmentation_key: str = \"segmentation\",\n):\n    \"\"\"\n    Write image and segmentation slices to an h5 file.\n\n    Parameters\n    ----------\n    file_path : str\n        The path to save to.\n    file_base : str\n        The base name of the file.\n    image_slices : dict\n        A dictionary of image slices. Keys are the edge IDs\n        of the edge the image slice belongs to.\n    segmentation_slices : dict, optional\n        A dictionary of segmentation slices. Keys are the edge IDs\n        of the edge the segmentation slice belongs to.\n    image_key : str\n        The key to use for the image slices.\n    segmentation_key : str\n        The key to use for the segmentation slices.\n    \"\"\"\n    if not os.path.exists(file_path):\n        os.makedirs(file_path)\n\n    for edge in image_slices.keys():\n        file_name = os.path.join(file_path, f\"{file_base}_sn_{edge[0]}_en_{edge[1]}.h5\")\n        logger.info(f\"Writing edge {edge} to {file_name}\")\n\n        with h5py.File(file_name, \"w\") as f:\n            f.create_dataset(image_key, data=image_slices[edge])\n            if segmentation_slices is not None:\n                f.create_dataset(segmentation_key, data=segmentation_slices[edge])\n</code></pre>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>)           \u2013            <p>The path to save to.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(file_base)","title":"<code>file_base</code>","text":"(<code>str</code>)           \u2013            <p>The base name of the file.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(image_slices)","title":"<code>image_slices</code>","text":"(<code>dict</code>)           \u2013            <p>A dictionary of image slices. Keys are the edge IDs of the edge the image slice belongs to.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(segmentation_slices)","title":"<code>segmentation_slices</code>","text":"(<code>dict</code>, default:                   <code>None</code> )           \u2013            <p>A dictionary of segmentation slices. Keys are the edge IDs of the edge the segmentation slice belongs to.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(image_key)","title":"<code>image_key</code>","text":"(<code>str</code>, default:                   <code>'image'</code> )           \u2013            <p>The key to use for the image slices.</p>"},{"location":"reference/skeleplex/graph/utils/#skeleplex.graph.utils.write_slices_to_h5(segmentation_key)","title":"<code>segmentation_key</code>","text":"(<code>str</code>, default:                   <code>'segmentation'</code> )           \u2013            <p>The key to use for the segmentation slices.</p>"},{"location":"reference/skeleplex/measurements/","title":"measurements","text":""},{"location":"reference/skeleplex/measurements/#skeleplex.measurements","title":"skeleplex.measurements","text":"<p>Tools to compute properties of a skeleton.</p> <p>Modules:</p> <ul> <li> <code>angles</code>           \u2013            </li> <li> <code>branches</code>           \u2013            </li> <li> <code>fit_surface</code>           \u2013            </li> <li> <code>graph_properties</code>           \u2013            </li> <li> <code>lumen_classifier</code>           \u2013            </li> <li> <code>utils</code>           \u2013            </li> </ul>"},{"location":"reference/skeleplex/measurements/angles/","title":"angles","text":""},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles","title":"skeleplex.measurements.angles","text":"<p>Functions:</p> <ul> <li> <code>angle_metric</code>             \u2013              <p>Decorator to register a function as an angle metric.</p> </li> <li> <code>compute_midline_branch_angle_branch_nodes</code>             \u2013              <p>Calculates the midline branch angle for each branch in the graph.</p> </li> <li> <code>compute_midline_branch_angle_spline</code>             \u2013              <p>Calculates the midline branch angle for each branch in the graph.</p> </li> <li> <code>compute_rotation_angle</code>             \u2013              <p>Calculates the rotation angle for each edge in the graph.</p> </li> <li> <code>compute_rotation_angle_parent_vector_daughter_plane</code>             \u2013              <p>Calculates the rotation angle between the parent vector and the daughter plane.</p> </li> <li> <code>compute_sibling_angle</code>             \u2013              <p>Calculates the sibling angle for each edge in the graph.</p> </li> <li> <code>compute_surface_normals_and_angles</code>             \u2013              <p>Computes surface normals and angles between surface normals and branch vectors.</p> </li> <li> <code>run_all_angle_metrics</code>             \u2013              <p>Runs all registered angle metrics in order.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.angle_metric","title":"angle_metric","text":"<pre><code>angle_metric(func)\n</code></pre> <p>Decorator to register a function as an angle metric.</p> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def angle_metric(func):\n    \"\"\"Decorator to register a function as an angle metric.\"\"\"\n    _ANGLE_FUNCTIONS.append(func)\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_branch_nodes","title":"compute_midline_branch_angle_branch_nodes","text":"<pre><code>compute_midline_branch_angle_branch_nodes(graph: DiGraph)\n</code></pre> <p>Calculates the midline branch angle for each branch in the graph.</p> <p>Computes the midline anlges for each branch in the graph and returns the midline branch angle as an edge attribute.</p> <p>To compute the vectors, only the branch nodes are taken in consideration. Branches are simplified to a straight line between branch nodes.</p> <p>Graph requirements: - The graph must be directed - The graph must be ordered with the desired hierarchy - The graph must have a 'node_coordinate' attribute for each node</p> <p>Returns:</p> <ul> <li> <code>graph</code> (              <code>DiGraph</code> )          \u2013            <p>The input graph with the angles added as edge attributes</p> </li> <li> <code>midline_vector</code> (              <code>ndarray</code> )          \u2013            <p>Array of shape (n_edges, 2, 3) containing the start and end points of the midline vectors for visualization.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the end point of the parent branch and the start point of the daughter branch are not the same</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the midline vector is != 1</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the branch vector is != 1</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>@angle_metric\ndef compute_midline_branch_angle_branch_nodes(graph: nx.DiGraph):\n    \"\"\"Calculates the midline branch angle for each branch in the graph.\n\n    Computes the midline anlges for each branch in the graph and returns\n    the midline branch angle as an edge attribute.\n\n    To compute the vectors, only the branch nodes are taken in consideration.\n    Branches are simplified to a straight line between branch nodes.\n\n    Graph requirements:\n    - The graph must be directed\n    - The graph must be ordered with the desired hierarchy\n    - The graph must have a 'node_coordinate' attribute for each node\n\n    Returns\n    -------\n    graph : nx.DiGraph\n        The input graph with the angles added as edge attributes\n\n    midline_vector : np.ndarray\n        Array of shape (n_edges, 2, 3) containing the start and end points\n        of the midline vectors for visualization.\n\n    Raises\n    ------\n    ValueError\n        Raises and error if the end point of the parent branch and the\n        start point of the daughter branch are not the same\n    ValueError\n        Raises and error if the length of the midline vector is != 1\n    ValueError\n        Raises and error if the length of the branch vector is != 1\n\n    \"\"\"\n    graph = graph.copy()\n\n    angle_dict = {}\n    center_points = []\n    midline_points = []\n\n    node_coordinates = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n\n    for u, v, _ in graph.edges(data=True):\n        edge = (u, v)\n        if not list(graph.in_edges(u)):\n            continue\n        parent_edge = next(iter(graph.in_edges(u)))\n\n        parent_start_node_coordinates = node_coordinates[parent_edge[0]]\n        parent_end_node_coordinates = node_coordinates[parent_edge[1]]\n\n        parent_vector = unit_vector(\n            parent_start_node_coordinates - parent_end_node_coordinates\n        )\n        midline_vector = -parent_vector\n\n        start_node_coordinates = node_coordinates[edge[0]]\n\n        if np.all(parent_end_node_coordinates != start_node_coordinates):\n            raise ValueError(\"Branch point ill defined.\")\n\n        end_node_coordinates = node_coordinates[edge[1]]\n        branch_vector = unit_vector(end_node_coordinates - start_node_coordinates)\n\n        if round(np.linalg.norm(midline_vector)) != 1:\n            raise ValueError(f\"\"\"Midline vector is not normalized.\n                             Its length is {np.linalg.norm(midline_vector)}\"\"\")\n        if round(np.linalg.norm(branch_vector)) != 1:\n            raise ValueError(f\"\"\"Branch vector is not normalized.\n                             Its length is {np.linalg.norm(branch_vector)}\"\"\")\n\n        dot = np.dot(midline_vector, branch_vector)\n        angle = np.degrees(np.arccos(dot))\n        angle_dict[edge] = angle\n\n        # store for visualization\n        center_points.append(parent_end_node_coordinates)\n        midline_points.append(parent_end_node_coordinates + (50 * midline_vector))\n\n    nx.set_edge_attributes(graph, angle_dict, BRANCH_ANGLE_EDGE_KEY)\n    midline_vector = np.array(np.stack([center_points, midline_points], axis=1))\n\n    return graph, midline_vector\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline","title":"compute_midline_branch_angle_spline","text":"<pre><code>compute_midline_branch_angle_spline(graph: DiGraph, sample_positions: ndarray, approx=False)\n</code></pre> <p>Calculates the midline branch angle for each branch in the graph.</p> <p>Computes the midline angles for each branch in the graph and returns the midline branch angle as an edge attribute.</p> <p>To compute the vectors, the spline is used to sample points along the branch. Angles are computed between the tangent of the spline of the branch and the tangent of the spline of the parent branch. Sampling distance starts at the common node and moves towards the end of both branches.</p> <p>Graph requirements: - The graph must be directed - The graph must be ordered with the desired hierarchy - The graph must have a 'node_coordinate' attribute for each node</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>graph</code> (              <code>DiGraph</code> )          \u2013            <p>The input graph with the angles added as edge attributes</p> </li> <li> <code>sample_position_list</code> (              <code>list</code> )          \u2013            <p>Returns the position on which the tangents of the spline were taken. For debugging purposes.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the end point of the parent branch and the start point of the daughter branch are not the same</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the midline vector is != 1</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raises and error if the length of the branch vector is != 1</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>@angle_metric\ndef compute_midline_branch_angle_spline(\n    graph: nx.DiGraph, sample_positions: np.ndarray, approx=False\n):\n    \"\"\"Calculates the midline branch angle for each branch in the graph.\n\n    Computes the midline angles for each branch in the graph and returns\n    the midline branch angle as an edge attribute.\n\n    To compute the vectors, the spline is used to sample points along the\n    branch. Angles are computed between the tangent of the spline of the branch\n    and the tangent of the spline of the parent branch. Sampling distance starts\n    at the common node and moves towards the end of both branches.\n\n    Graph requirements:\n    - The graph must be directed\n    - The graph must be ordered with the desired hierarchy\n    - The graph must have a 'node_coordinate' attribute for each node\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n    sample_positions : np.array\n        List of positions along the spline to sample the tangents\n    approx : bool\n        If True, evaluate the spline using an approximation\n\n    Returns\n    -------\n    graph : nx.DiGraph\n        The input graph with the angles added as edge attributes\n    sample_position_list: list\n        Returns the position on which the tangents of the spline were taken.\n        For debugging purposes.\n\n    Raises\n    ------\n    ValueError\n        Raises and error if the end point of the parent branch and the\n        start point of the daughter branch are not the same\n    ValueError\n        Raises and error if the length of the midline vector is != 1\n    ValueError\n        Raises and error if the length of the branch vector is != 1\n\n    \"\"\"\n    graph = graph.copy()\n    angle_dict = {}\n    sample_positions_list = []\n    # loop over each edge\n    for u, v in graph.edges():\n        edge = (u, v)\n        parent_edge = list(graph.in_edges(u))\n        if not parent_edge:\n            continue\n        parent_edge = parent_edge[0]\n        parent_spline = graph.edges[parent_edge][EDGE_SPLINE_KEY]\n        spline = graph.edges[edge][EDGE_SPLINE_KEY]\n        # sample_positions = np.linspace(0, 1, n_samples)\n        parent_tangents = parent_spline.eval(\n            1 - sample_positions, derivative=1, approx=approx\n        )\n        sample_positions_list.append(\n            parent_spline.eval(1 - sample_positions, approx=approx)\n        )\n        tangents = spline.eval(sample_positions, derivative=1, approx=approx)\n        sample_positions_list.append(spline.eval(sample_positions, approx=approx))\n        # normalize the tangents\n        tangents = [unit_vector(t) for t in tangents]\n        parent_tangents = [unit_vector(t) for t in parent_tangents]\n\n        angle_list = []\n\n        for i in range(len(tangents)):\n            t = tangents[i]\n            j = len(parent_tangents) - i - 1\n            pt = parent_tangents[j]\n            dot = np.dot(t, pt)\n            angle = np.degrees(np.arccos(dot))\n\n            angle_list.append(angle)\n        # angle_std = np.std(angle_list)\n        mean_angle = np.mean(angle_list)\n        angle_dict[edge] = mean_angle\n\n    nx.set_edge_attributes(graph, angle_dict, BRANCH_ANGLE_JUNCTION_EDGE_KEY)\n    return graph, sample_positions_list\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline(sample_positions)","title":"<code>sample_positions</code>","text":"(<code>array</code>)           \u2013            <p>List of positions along the spline to sample the tangents</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_midline_branch_angle_spline(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, evaluate the spline using an approximation</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_rotation_angle","title":"compute_rotation_angle","text":"<pre><code>compute_rotation_angle(graph: DiGraph)\n</code></pre> <p>Calculates the rotation angle for each edge in the graph.</p> <p>Compute the rotation angle between the plane defined by the parent node and the plane defined by the edge and its sister.</p> <p>The edge attribute is defined in the ROTATION_ANGLE_EDGE_KEY constant.</p> <p>The input graph should have the following attributes:</p> <ul> <li>NODE_COORDINATE_KEY: The node coordinates</li> <li>SISTER_EDGE_KEY: The sister edge</li> <li>Directed graph with the correct orientation</li> <li>Strictly dichotomous tree</li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>@angle_metric\ndef compute_rotation_angle(graph: nx.DiGraph):\n    \"\"\"Calculates the rotation angle for each edge in the graph.\n\n    Compute the rotation angle between the plane defined by the parent node\n    and the plane defined by the edge and its sister.\n\n    The edge attribute is defined in the\n    ROTATION_ANGLE_EDGE_KEY constant.\n\n    The input graph should have the following attributes:\n\n    - NODE_COORDINATE_KEY: The node coordinates\n    - SISTER_EDGE_KEY: The sister edge\n    - Directed graph with the correct orientation\n    - Strictly dichotomous tree\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n    \"\"\"\n    rotation_angle_dict = {}\n    graph = graph.copy()\n    node_coord = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for edge in graph.edges():\n        parent = list(graph.in_edges(edge[0]))\n\n        sister = None\n        if SISTER_EDGE_KEY in graph.edges[edge]:\n            sister = graph.edges[edge][SISTER_EDGE_KEY]\n\n        if not parent or not sister:\n            continue\n        parent = parent[0]\n        parent_sister = None\n        if SISTER_EDGE_KEY in graph.edges[parent]:\n            parent_sister = graph.edges[parent][SISTER_EDGE_KEY]\n\n        if not parent_sister:\n            continue\n\n        if isinstance(parent_sister[0], list):\n            parent_sister = tuple(parent_sister[0])\n        if isinstance(sister[0], list):\n            sister = tuple(sister[0])\n\n        parent_plane = [\n            node_coord[parent[0]],\n            node_coord[parent[1]],\n            node_coord[parent_sister[1]],\n        ]\n\n        edge_plane = [node_coord[edge[0]], node_coord[edge[1]], node_coord[sister[1]]]\n        if parent_plane and edge_plane:\n            normal_parent = get_normal_of_plane(\n                parent_plane[0], parent_plane[1], parent_plane[2]\n            )\n            normal_edge = get_normal_of_plane(\n                edge_plane[0], edge_plane[1], edge_plane[2]\n            )\n            normal_parent_unit = unit_vector(normal_parent)\n            normal_edge_unit = unit_vector(normal_edge)\n            rotation_angle = np.arccos(np.dot(normal_parent_unit, normal_edge_unit))\n            if rotation_angle &gt; np.pi / 2:\n                rotation_angle = np.pi - rotation_angle\n            rotation_angle_dict[edge] = rad2deg(rotation_angle)\n\n    nx.set_edge_attributes(graph, rotation_angle_dict, ROTATION_ANGLE_EDGE_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_rotation_angle(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_rotation_angle_parent_vector_daughter_plane","title":"compute_rotation_angle_parent_vector_daughter_plane","text":"<pre><code>compute_rotation_angle_parent_vector_daughter_plane(graph: DiGraph)\n</code></pre> <p>Calculates the rotation angle between the parent vector and the daughter plane.</p> <p>Compute the rotation angle between the parent vector and the plane defined by the edge and its sister. The edge attribute is defined in the ROTATION_ANGLE_EDGE_KEY constant. The input graph should have the following attributes: - NODE_COORDINATE_KEY: The node coordinates - SISTER_EDGE_KEY: The sister edge - Directed graph with the correct orientation - Strictly dichotomous tree</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>@angle_metric\ndef compute_rotation_angle_parent_vector_daughter_plane(graph: nx.DiGraph):\n    \"\"\"Calculates the rotation angle between the parent vector and the daughter plane.\n\n    Compute the rotation angle between the parent vector\n    and the plane defined by the edge and its sister.\n    The edge attribute is defined in the\n    ROTATION_ANGLE_EDGE_KEY constant.\n    The input graph should have the following attributes:\n    - NODE_COORDINATE_KEY: The node coordinates\n    - SISTER_EDGE_KEY: The sister edge\n    - Directed graph with the correct orientation\n    - Strictly dichotomous tree\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n    \"\"\"\n    rotation_angle_dict = {}\n    graph = graph.copy()\n    node_coord = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for edge in graph.edges():\n        parent = list(graph.in_edges(edge[0]))\n\n        sister = None\n        if SISTER_EDGE_KEY in graph.edges[edge]:\n            sister = graph.edges[edge][SISTER_EDGE_KEY]\n\n        if not parent or not sister:\n            continue\n        parent = parent[0]\n\n\n\n        if isinstance(sister[0], list):\n            sister = tuple(sister[0])\n\n        parent_vector = node_coord[parent[1]] - node_coord[parent[0]]\n        parent_vector_unit = unit_vector(parent_vector)\n\n        edge_plane = [node_coord[edge[0]], node_coord[edge[1]], node_coord[sister[1]]]\n        if  edge_plane:\n\n            normal_edge = get_normal_of_plane(\n                edge_plane[0], edge_plane[1], edge_plane[2]\n            )\n            rotation_angle = np.arccos(np.dot(parent_vector_unit,\n                                              unit_vector(normal_edge)))\n            # if rotation_angle &gt; np.pi / 2:\n            #     rotation_angle = np.pi - rotation_angle\n            rotation_angle_dict[edge] = rad2deg(rotation_angle)\n\n    nx.set_edge_attributes(graph, rotation_angle_dict, ROTATION_ANGLE_VECTOR_EDGE_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_rotation_angle_parent_vector_daughter_plane(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_sibling_angle","title":"compute_sibling_angle","text":"<pre><code>compute_sibling_angle(graph: DiGraph)\n</code></pre> <p>Calculates the sibling angle for each edge in the graph.</p> <p>Computes the sibling angles for each edge in the graph and returns the sibling angle as an edge attribute.</p> <p>The sibling angle is the angle between the edge and its sister edge.</p> <p>Graph requirements: - The graph must be directed - The graph must be ordered with the desired hierarchy - The graph must have a 'node_coordinate' attribute for each node</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>graph</code> (              <code>DiGraph</code> )          \u2013            <p>The input graph with the sibling angle added as edge attributes</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>@angle_metric\ndef compute_sibling_angle(graph: nx.DiGraph):\n    \"\"\"Calculates the sibling angle for each edge in the graph.\n\n    Computes the sibling angles for each edge in the graph\n    and returns the sibling angle as an edge attribute.\n\n    The sibling angle is the angle between the edge and its sister edge.\n\n    Graph requirements:\n    - The graph must be directed\n    - The graph must be ordered with the desired hierarchy\n    - The graph must have a 'node_coordinate' attribute for each node\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph\n\n    Returns\n    -------\n    graph : nx.DiGraph\n        The input graph with the sibling angle added as edge attributes\n    \"\"\"\n    graph = graph.copy()\n    angle_dict = {}\n    sister_pairs = nx.get_edge_attributes(graph, SISTER_EDGE_KEY)\n    sister_pairs = [(edge, sister_pairs[edge]) for edge in sister_pairs]\n    # keep only one sister pair as they both have the same angle\n    unique_pairs = set()\n    for pair in sister_pairs:\n        if any(\n            isinstance(x, list)\n            for x in (pair[0][0], pair[1][0], pair[1], pair[0])\n        ):\n            continue\n        pair = tuple(sorted(pair))\n        unique_pairs.add(pair)\n    unique_pairs = list(unique_pairs)\n\n    node_coordinates = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for sister_pair in unique_pairs:\n        edge = sister_pair[0]\n        sister = sister_pair[1]\n        shared_node_coord = node_coordinates[edge[0]]\n        edge_vector = unit_vector(node_coordinates[edge[1]] - shared_node_coord)\n        sister_vector = unit_vector(node_coordinates[sister[1]] - shared_node_coord)\n\n        dot = np.dot(edge_vector, sister_vector)\n        angle = np.degrees(np.arccos(dot))\n        angle_dict[edge] = angle\n        angle_dict[sister] = angle\n\n    nx.set_edge_attributes(graph, angle_dict, SIBLING_ANGLE_EDGE_KEY)\n\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_sibling_angle(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles","title":"compute_surface_normals_and_angles","text":"<pre><code>compute_surface_normals_and_angles(skeletons: list, stage_list: list, lobes: tuple = ('LeftLobe', 'InferiorLobe', 'MiddleLobe', 'SuperiorLobe', 'PostCavalLobe'), smooth=1000)\n</code></pre> <p>Computes surface normals and angles between surface normals and branch vectors.</p> <p>Fits surfaces, computes surface normals, and calculates the angle between surface normals and branch vectors for a list of skeletons.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>- list_dict_normal_dicts: List of dictionaries</code>           \u2013            <p>containing normal vectors for each lobe</p> </li> </ul> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def compute_surface_normals_and_angles(\n    skeletons: list,\n    stage_list: list,\n    lobes: tuple = (\n        \"LeftLobe\",\n        \"InferiorLobe\",\n        \"MiddleLobe\",\n        \"SuperiorLobe\",\n        \"PostCavalLobe\",\n    ),\n    smooth=1000,\n):\n    \"\"\"Computes surface normals and angles between surface normals and branch vectors.\n\n    Fits surfaces, computes surface normals, and calculates the angle between\n    surface normals and branch vectors for a list of skeletons.\n\n    Parameters\n    ----------\n    skeletons : list\n        List of SkeletonGraph objects\n    stage_list : list\n        List of stage names\n    lobes : tuple\n        Tuple of lobe names\n    smooth : int\n        Smoothing parameter for the surface fitting\n\n    Returns\n    -------\n    - list_dict_normal_dicts: List of dictionaries\n        containing normal vectors for each lobe\n    \"\"\"\n    list_dict_normal_dicts = []\n\n    surface_stage_dict = {}\n\n    for i, skeleton in enumerate(skeletons):\n        logger.info(f\"Processing stage {stage_list[i]}\")\n\n        dict_normal_dicts = {}\n        graph = skeleton.graph\n\n        # Fit surface and get normals\n        logger.info(\"Fitting surfaces and getting normals...\")\n        surface_dict = {}\n        for lobe in lobes:\n            logger.info(f\"Processing lobe {lobe}\")\n            normal_dict, _, surface = fit_surface_and_get_surface_normal_of_branches(\n                graph, lobe, smooth=smooth\n            )\n            dict_normal_dicts[lobe] = normal_dict\n            surface_dict[lobe] = surface\n\n        surface_stage_dict[stage_list[i]] = surface_dict\n\n        list_dict_normal_dicts.append(dict_normal_dicts)\n\n        # Compute angle between surface normal and branch\n        lobe_edge_dict = nx.get_edge_attributes(graph, LOBE_NAME_KEY)\n        splines = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n        node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n\n        logger.info(\"Computing angles...\")\n        for u, v in graph.edges():\n            edge = (u, v)\n            spline = splines[edge]\n            lobe_of_edge = lobe_edge_dict[edge]\n\n            if lobe_of_edge in [\"&lt;class 'str'&gt;\", \"nan\"]:\n                continue\n\n            u_coord = node_coords[u]\n            v_coord = spline.eval(0.01, approx=True)\n            edge_vector = unit_vector(v_coord - u_coord)\n\n            try:\n                surface_vector = dict_normal_dicts[lobe_of_edge][edge]\n            except KeyError:\n                continue\n\n            angle = np.arccos(np.dot(edge_vector, surface_vector))\n            angle = rad2deg(angle) - 90\n            graph.edges[edge][SURFACE_ANGLE_EDGE_KEY] = angle\n\n        skeleton.graph = graph\n\n    return list_dict_normal_dicts, surface_stage_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(skeletons)","title":"<code>skeletons</code>","text":"(<code>list</code>)           \u2013            <p>List of SkeletonGraph objects</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(stage_list)","title":"<code>stage_list</code>","text":"(<code>list</code>)           \u2013            <p>List of stage names</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(lobes)","title":"<code>lobes</code>","text":"(<code>tuple</code>, default:                   <code>('LeftLobe', 'InferiorLobe', 'MiddleLobe', 'SuperiorLobe', 'PostCavalLobe')</code> )           \u2013            <p>Tuple of lobe names</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.compute_surface_normals_and_angles(smooth)","title":"<code>smooth</code>","text":"(<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Smoothing parameter for the surface fitting</p>"},{"location":"reference/skeleplex/measurements/angles/#skeleplex.measurements.angles.run_all_angle_metrics","title":"run_all_angle_metrics","text":"<pre><code>run_all_angle_metrics(graph, **kwargs)\n</code></pre> <p>Runs all registered angle metrics in order.</p> <p>Each metric must accept a graph, and may accept additional keyword arguments. Returns a list of (name, graph_out, extra_return_values).</p> Source code in <code>skeleplex/measurements/angles.py</code> <pre><code>def run_all_angle_metrics(graph, **kwargs):\n    \"\"\"Runs all registered angle metrics in order.\n\n    Each metric must accept a graph, and may accept additional keyword arguments.\n    Returns a list of (name, graph_out, extra_return_values).\n    \"\"\"\n    results = []\n    g = graph\n    for func in _ANGLE_FUNCTIONS:\n        name = func.__name__\n        logger.info(f\"Running angle metric: {name}\")\n        out = func(g, **{k: v for k, v in kwargs.items() if k in func.__code__.co_varnames})\n        # out can be (graph) or (graph, extra)\n        if isinstance(out, tuple):\n            g = out[0]\n            extra = out[1:]\n        else:\n            g = out\n            extra = ()\n        results.append((name, g, *extra))\n    return g, results\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/","title":"branches","text":""},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches","title":"skeleplex.measurements.branches","text":"<p>Functions:</p> <ul> <li> <code>add_file_to_graph</code>             \u2013              <p>Process a single HDF5 file.</p> </li> <li> <code>add_measurements_from_h5_to_graph</code>             \u2013              <p>Add measurements from HDF5 files to the skeleton graph.</p> </li> <li> <code>filter_and_segment_lumen</code>             \u2013              <p>Filter and segment the lumen in the image slices.</p> </li> <li> <code>filter_file_for_iterative_lumens</code>             \u2013              <p>Filter a single HDF5 file for iterative lumens.</p> </li> <li> <code>filter_for_iterative_lumens</code>             \u2013              <p>Filter for iterative lumens across multiple files in parallel.</p> </li> <li> <code>find_lumen_in_slice</code>             \u2013              <p>Find lumen and branch labels in a single 2D image slice.</p> </li> <li> <code>fix_only_lumen</code>             \u2013              <p>Fix segmentation slices containing only lumen.</p> </li> <li> <code>lumen_touches_background</code>             \u2013              <p>Check if lumen touches background in a label slice.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.add_file_to_graph","title":"add_file_to_graph","text":"<pre><code>add_file_to_graph(file)\n</code></pre> <p>Process a single HDF5 file.</p> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def add_file_to_graph(file):\n    \"\"\"Process a single HDF5 file.\"\"\"\n    try:\n        with h5py.File(file, \"r\") as f:\n            image_slices = f[\"image\"][:]\n            segmentation_slices = f[\"segmentation\"][:]\n    except Exception as e:\n        logger.warning(f\"Error loading {file}: {e}\")\n        return None\n\n    file_name = os.path.basename(file)\n    start_node = int(file_name.split(\"_\")[3])\n    end_node = int(file_name.split(\"_\")[5].split(\".\")[0])\n\n    tissue_radius_branch = []\n    lumen_radius_branch = []\n    minor_axis_branch = []\n    major_axis_branch = []\n    total_area_branch = []\n\n    for slice_index, (_, segmentation_slice) in enumerate(\n        zip(image_slices, segmentation_slices, strict=False)\n    ):\n        if np.sum(segmentation_slice == 2) &gt; 0:\n            if np.sum(segmentation_slice == 1) == 0 and fix_only_lumen(\n                segmentation_slice\n            ):\n                logger.info(f\"Fixing {file}, slice {slice_index}\")\n                segmentation_slice[segmentation_slice == 2] = 1\n                segmentation_slices[slice_index] = segmentation_slice\n\n            label_slice = ski.measure.label((segmentation_slice != 0).astype(np.uint8))\n            props = ski.measure.regionprops(label_slice)\n\n            if props:\n                minor_axis = props[0].minor_axis_length\n                major_axis = props[0].major_axis_length\n                total_area = props[0].area\n                minor_axis_branch.append(minor_axis)\n                major_axis_branch.append(major_axis)\n                total_area_branch.append(total_area)\n\n            if np.sum(segmentation_slice == 1) &gt; 0:\n                lumen_label = (segmentation_slice == 2).astype(np.uint8)\n                tissue_label = (segmentation_slice == 1).astype(np.uint8)\n\n                lumen_props = ski.measure.regionprops(ski.measure.label(lumen_label))\n                tissue_props = ski.measure.regionprops(ski.measure.label(tissue_label))\n\n                if lumen_props and tissue_props:\n                    lumen_area = lumen_props[0].area\n                    tissue_area = tissue_props[0].area\n                    total_area = lumen_area + tissue_area\n                    total_radius = radius_from_area(total_area)\n                    lumen_radius = radius_from_area(lumen_area)\n                    tissue_radius = total_radius - lumen_radius\n                    tissue_radius_branch.append(tissue_radius)\n                    lumen_radius_branch.append(lumen_radius)\n            else:\n                # no tissue label, full region is tissue\n                tissue_radius_branch.append(minor_axis / 2)\n                lumen_radius_branch.append(0)\n        else:\n            # completely closed (no lumen)\n            label_slice = ski.measure.label((segmentation_slice != 0).astype(np.uint8))\n            props = ski.measure.regionprops(label_slice)\n            if props:\n                minor_axis = props[0].minor_axis_length\n                major_axis = props[0].major_axis_length\n                total_area = props[0].area\n                minor_axis_branch.append(minor_axis)\n                major_axis_branch.append(major_axis)\n                total_area_branch.append(total_area)\n                tissue_radius_branch.append(minor_axis / 2)\n                lumen_radius_branch.append(0)\n\n    return (\n        start_node,\n        end_node,\n        np.mean(np.array(lumen_radius_branch) * 2),\n        np.std(np.array(lumen_radius_branch) * 2),\n        np.mean(tissue_radius_branch),\n        np.std(tissue_radius_branch),\n        np.mean(total_area_branch),\n        np.std(total_area_branch),\n        np.mean(minor_axis_branch),\n        np.std(minor_axis_branch),\n        np.mean(major_axis_branch),\n        np.std(major_axis_branch),\n    )\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.add_measurements_from_h5_to_graph","title":"add_measurements_from_h5_to_graph","text":"<pre><code>add_measurements_from_h5_to_graph(graph_path, input_path)\n</code></pre> <p>Add measurements from HDF5 files to the skeleton graph.</p> <p>The slice names need to be in the format:</p> <p>{base}{name}{start_node}_{end_node}.h5</p> <p>Valid files are usually generated using the sample_slices_from_graph function from the SkeletonGraph class. Its highly advised to use the filtering functions first.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>SkeletonGraph</code>           \u2013            <p>The updated skeleton graph with measurements added.</p> </li> </ul> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def add_measurements_from_h5_to_graph(graph_path, input_path):\n    \"\"\"\n    Add measurements from HDF5 files to the skeleton graph.\n\n    The slice names need to be in the format:\n\n    {base}_{name}_{start_node}_{end_node}.h5\n\n    Valid files are usually generated using the sample_slices_from_graph function from\n    the SkeletonGraph class. Its highly advised to use the filtering\n    functions first.\n\n    Parameters\n    ----------\n    graph_path : str\n        Path to the skeleton graph JSON file.\n    input_path : str\n        Path to the directory containing HDF5 files with the segmented slices.\n\n    Returns\n    -------\n    SkeletonGraph\n        The updated skeleton graph with measurements added.\n    \"\"\"\n    # Load skeleton graph\n    skeleton_graph = SkeletonGraph.from_json_file(graph_path)\n\n    # Prepare attributes\n    attribute_names = [\n        \"lumen_diameter\",\n        \"tissue_thickness\",\n        \"total_area\",\n        \"minor_axis\",\n        \"major_axis\",\n    ]\n    for attr in attribute_names + [f\"{a}_sd\" for a in attribute_names]:\n        nx.set_edge_attributes(skeleton_graph.graph, {}, name=attr)\n\n    measurement_dicts = {\n        key: {}\n        for key in (\n            \"lumen_diameter\",\n            \"tissue_thickness\",\n            \"total_area\",\n            \"minor_axis\",\n            \"major_axis\",\n            \"lumen_diameter_sd\",\n            \"tissue_thickness_sd\",\n            \"total_area_sd\",\n            \"minor_axis_sd\",\n            \"major_axis_sd\",\n        )\n    }\n\n    # Get list of HDF5 files\n    files = [f for f in os.listdir(input_path) if f.endswith(\".h5\")]\n    # add input path to files\n    files = [os.path.join(input_path, f) for f in files]\n\n    # Process files in parallel\n    results = []\n    with concurrent.futures.ProcessPoolExecutor(max_workers=12) as executor:\n        for result in tqdm(executor.map(add_file_to_graph, files), total=len(files)):\n            if result:\n                results.append(result)\n\n    # Fill measurement dicts\n    for (\n        start_node,\n        end_node,\n        lumen_diameter_mean,\n        lumen_diameter_sd,\n        tissue_thickness_mean,\n        tissue_thickness_sd,\n        total_area_mean,\n        total_area_sd,\n        minor_axis_mean,\n        minor_axis_sd,\n        major_axis_mean,\n        major_axis_sd,\n    ) in results:\n        edge = (start_node, end_node)\n        measurement_dicts[\"lumen_diameter\"][edge] = lumen_diameter_mean\n        measurement_dicts[\"lumen_diameter_sd\"][edge] = lumen_diameter_sd\n        measurement_dicts[\"tissue_thickness\"][edge] = tissue_thickness_mean\n        measurement_dicts[\"tissue_thickness_sd\"][edge] = tissue_thickness_sd\n        measurement_dicts[\"total_area\"][edge] = total_area_mean\n        measurement_dicts[\"total_area_sd\"][edge] = total_area_sd\n        measurement_dicts[\"minor_axis\"][edge] = minor_axis_mean\n        measurement_dicts[\"minor_axis_sd\"][edge] = minor_axis_sd\n        measurement_dicts[\"major_axis\"][edge] = major_axis_mean\n        measurement_dicts[\"major_axis_sd\"][edge] = major_axis_sd\n\n    # Set graph attributes\n    for attr, attr_dict in measurement_dicts.items():\n        nx.set_edge_attributes(skeleton_graph.graph, attr_dict, name=attr)\n    logger.info(\"save\")\n    # Save\n    skeleton_graph.to_json_file(graph_path)\n\n    return skeleton_graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.add_measurements_from_h5_to_graph(graph_path)","title":"<code>graph_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the skeleton graph JSON file.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.add_measurements_from_h5_to_graph(input_path)","title":"<code>input_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the directory containing HDF5 files with the segmented slices.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen","title":"filter_and_segment_lumen","text":"<pre><code>filter_and_segment_lumen(data_path, save_path, sam_checkpoint_path: str | None = None, resnet_predictor: ResNet3ClassClassifier | None = None, eccentricity_thresh=0.7, circularity_thresh=0.5, find_lumen=True, sam_quality_threshold=0.1, segmentation_key: str = 'segmentation')\n</code></pre> <p>Filter and segment the lumen in the image slices.</p> <p>Uses the spline to seed an prompt for SAM2 https://github.com/facebookresearch/sam2/tree/main</p> <p>And a resnet classifier to classify the slices into lumen, branches and bad.</p> <p>By convention, the lumen is labeled as 2, the tissue as 1 and the background as 0.</p> <p>Only the central label of the slice is considered, which is the label at the center of the slice. If there is no central label, the slice is dropped. If the central label is touching the border of the slice, the slice is dropped.</p> <p>The lumen is the central \"open\" part of the slice, which is not touching the border, has a low eccentricity and high circularity and is usually characterized by a low intensity in the image. If the segmentation only covers the lumen, find_lumen should be set to False, which will only filter the slices based on eccentricity and circularity.</p> <p>Eccentricity is defined as the ratio of the distance between the foci of the ellipse and the length of the major axis. A value close to 0 indicates a circle and a value close to 1 indicates a line. Circularity is defined as the ratio of the area of the shape to the area of a circle with the same perimeter. A value close to 1 indicates a circle and a value close to 0 indicates a very irregular/bumpy shape.</p> <p>https://en.wikipedia.org/wiki/Eccentricity_(mathematics)</p> <p>If the segmentation covers the total diameter of the branch, thus segmenting the lumen and the tissue, find_lumen can be set to True, which will use the spline to seed a prompt for SAM2</p> <p>https://github.com/facebookresearch/sam2/tree/main .</p> <p>This will segment the branch and returns different masks, ideally one for the one for the lumen and one for the whole branch. To classify the different masks, a ResNet classifier is used, which is trained on the lumen, branches and bad slices. The classifier is used to classify the lumen and branches, and the bad slices are filtered out. The classifier needs to be trained on the lumen, branches and bad slices.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def filter_and_segment_lumen(\n    data_path,\n    save_path,\n    sam_checkpoint_path: str | None = None,\n    resnet_predictor: \"ResNet3ClassClassifier | None\" = None,\n    eccentricity_thresh=0.7,\n    circularity_thresh=0.5,\n    find_lumen=True,\n    sam_quality_threshold=0.1,\n    segmentation_key: str = \"segmentation\",\n):\n    \"\"\"\n    Filter and segment the lumen in the image slices.\n\n    Uses the spline to seed an prompt for SAM2\n    https://github.com/facebookresearch/sam2/tree/main\n\n    And a resnet classifier to classify the slices into lumen, branches and bad.\n\n    By convention, the lumen is labeled as 2, the tissue as 1 and the background as 0.\n\n    Only the central label of the slice is considered, which is the label at the\n    center of the slice. If there is no central label, the slice is dropped.\n    If the central label is touching the border of the slice, the slice is dropped.\n\n    The lumen is the central \"open\" part of the slice, which is not\n    touching the border, has a low eccentricity and high circularity and is usually\n    characterized by a low intensity in the image. If the segmentation only covers the\n    lumen, find_lumen should be set to False, which will only filter the slices\n    based on eccentricity and circularity.\n\n    Eccentricity is defined as the ratio of the distance between the foci of the\n    ellipse and the length of the major axis. A value close to 0 indicates a circle\n    and a value close to 1 indicates a line. Circularity is defined as the ratio\n    of the area of the shape to the area of a circle with the same perimeter. A\n    value close to 1 indicates a circle and a value close to 0 indicates a\n    very irregular/bumpy shape.\n\n    https://en.wikipedia.org/wiki/Eccentricity_(mathematics)\n\n\n    If the segmentation covers the total diameter of the branch, thus segmenting the\n    lumen and the tissue, find_lumen can be set to True, which will use the spline to\n    seed a prompt for SAM2\n\n    https://github.com/facebookresearch/sam2/tree/main .\n\n    This will segment the branch and returns different masks, ideally one for the one\n    for the lumen and one for the whole branch. To classify the different masks, a\n    ResNet classifier is used, which is trained on the lumen, branches and bad slices.\n    The classifier is used to classify the lumen and branches, and the bad slices are\n    filtered out. The classifier needs to be trained on the lumen, branches and\n    bad slices.\n\n    Parameters\n    ----------\n    data_path : str\n        Path to the input data directory containing .h5 files.\n    save_path : str\n        Path to the output directory where filtered .h5 files will be saved.\n    sam_checkpoint_path : str, optional\n        Path to the SAM2 checkpoint file.\n        only required if find_lumen is True.\n    resnet_predictor : ResNet3ClassClassifier, optional\n        ResNet classifier for predicting classes.\n        Only required if find_lumen is True.\n    eccentricity_thresh : float\n        Eccentricity threshold for filtering slices.\n    circularity_thresh : float\n        Circularity threshold for filtering slices.\n    find_lumen : bool\n        Whether to find the lumen using SAM2 or just to filter for\n        eccentricity and circularity.\n    sam_quality_threshold : float\n        Minimum SAM quality score to consider a mask for classification.\n    segmentation_key : str\n        The h5 dataset key to use for the segmentation slices.\n    \"\"\"\n    if not os.path.exists(save_path):\n        os.makedirs(save_path)\n        logger.info(f\"Created directory: {save_path}\")\n\n    files = [f for f in os.listdir(data_path) if f.endswith(\".h5\")]\n    # only do those that are npot in the save_path\n    files = [f for f in files if not os.path.exists(os.path.join(save_path, f))]\n    logger.info(f\"Found {len(files)} files to process.\")\n    files = tqdm(files, desc=\"Processing files\")\n    for file in files:\n        logger.info(f\"Processing {file}\")\n\n        with h5py.File(os.path.join(data_path, file), \"r\") as f:\n            image_slices = f[\"image\"][:]\n            segmentation_slices = f[segmentation_key][:] != 0\n\n        label_slices_filt = np.zeros_like(segmentation_slices, dtype=np.uint8)\n        index_to_remove = []\n\n        for i in range(len(image_slices)):\n            image_slice = image_slices[i]\n            segmentation_slice = segmentation_slices[i]\n            label_slice = ski.measure.label(segmentation_slice)\n            h, w = image_slice.shape\n            central_label = label_slice[h // 2, w // 2]\n\n            # Skip if no central label\n            if central_label == 0:\n                index_to_remove.append(i)\n                continue\n\n            # Remove if touching the border\n            if (\n                np.any(label_slice[0, :] == central_label)\n                or np.any(label_slice[-1, :] == central_label)\n                or np.any(label_slice[:, 0] == central_label)\n                or np.any(label_slice[:, -1] == central_label)\n            ):\n                index_to_remove.append(i)\n                continue\n\n            label_slice[label_slice != central_label] = 0\n            label_slice[label_slice == central_label] = 1\n\n            # Check eccentricity\n            props = ski.measure.regionprops(label_slice)\n            if props[0].eccentricity &gt; eccentricity_thresh:\n                index_to_remove.append(i)\n                continue\n\n            # Check circularity\n            circularity = 4 * np.pi * props[0].area / (props[0].perimeter ** 2)\n            if circularity &lt; circularity_thresh:\n                index_to_remove.append(i)\n                continue\n\n            if find_lumen:\n                # delay imports so that the function can be used without SAM2\n                from sam2.build_sam import build_sam2\n                from sam2.sam2_image_predictor import SAM2ImagePredictor\n\n                device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n                sam2_checkpoint = sam_checkpoint_path\n                model_cfg = \"configs/sam2.1/sam2.1_hiera_l.yaml\"\n                sam2_model = build_sam2(model_cfg, sam2_checkpoint, device=device)\n                predictor = SAM2ImagePredictor(sam2_model)\n\n                label_slice = find_lumen_in_slice(\n                    image_slice,\n                    label_slice,\n                    predictor,\n                    resnet_predictor,\n                    sam_quality_threshold,\n                )\n            label_slices_filt[i] = label_slice\n\n        # Remove invalid slices\n        image_slice_filt = np.delete(image_slices, index_to_remove, axis=0)\n        label_slices_filt = np.delete(label_slices_filt, index_to_remove, axis=0)\n\n        with h5py.File(os.path.join(save_path, file), \"w\") as f:\n            f.create_dataset(\"image\", data=image_slice_filt)\n            f.create_dataset(\"segmentation\", data=label_slices_filt)\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(data_path)","title":"<code>data_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the input data directory containing .h5 files.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(save_path)","title":"<code>save_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the output directory where filtered .h5 files will be saved.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(sam_checkpoint_path)","title":"<code>sam_checkpoint_path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>Path to the SAM2 checkpoint file. only required if find_lumen is True.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(resnet_predictor)","title":"<code>resnet_predictor</code>","text":"(<code>ResNet3ClassClassifier</code>, default:                   <code>None</code> )           \u2013            <p>ResNet classifier for predicting classes. Only required if find_lumen is True.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(eccentricity_thresh)","title":"<code>eccentricity_thresh</code>","text":"(<code>float</code>, default:                   <code>0.7</code> )           \u2013            <p>Eccentricity threshold for filtering slices.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(circularity_thresh)","title":"<code>circularity_thresh</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Circularity threshold for filtering slices.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(find_lumen)","title":"<code>find_lumen</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to find the lumen using SAM2 or just to filter for eccentricity and circularity.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(sam_quality_threshold)","title":"<code>sam_quality_threshold</code>","text":"(<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>Minimum SAM quality score to consider a mask for classification.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_and_segment_lumen(segmentation_key)","title":"<code>segmentation_key</code>","text":"(<code>str</code>, default:                   <code>'segmentation'</code> )           \u2013            <p>The h5 dataset key to use for the segmentation slices.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_file_for_iterative_lumens","title":"filter_file_for_iterative_lumens","text":"<pre><code>filter_file_for_iterative_lumens(args)\n</code></pre> <p>Filter a single HDF5 file for iterative lumens.</p> <p>This function processes a single HDF5 file, filtering out slices that do not contain the iterative lumen label (2). It checks each slice in the segmentation data and removes slices that do not contain label 2, or are not surrounded by label 2 slices. The filtered slices are saved to the specified output path.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def filter_file_for_iterative_lumens(args):\n    \"\"\"Filter a single HDF5 file for iterative lumens.\n\n    This function processes a single HDF5 file, filtering out slices that do not\n    contain the iterative lumen label (2). It checks each slice in the segmentation\n    data and removes slices that do not contain label 2, or are not surrounded by\n    label 2 slices. The filtered slices are saved to the specified output path.\n\n\n    Parameters\n    ----------\n    args : tuple\n        A tuple containing the file name, data path, and save path.\n        The tuple should be in the format (file_name, data_path, save_path).\n\n    \"\"\"\n    file, data_path, save_path = args\n    logger.info(f\"Processing {file}\")\n\n    input_file_path = os.path.join(data_path, file)\n    output_file_path = os.path.join(save_path, file)\n    try:\n        with h5py.File(input_file_path, \"r\") as f:\n            image_slices = f[\"image\"][:]\n            segmentation_slices = f[\"segmentation\"][:]\n    except Exception as e:\n        logger.warning(f\"Error loading {file}: {e}\")\n        return\n\n    if np.sum(segmentation_slices == 2) == 0:\n        logger.info(f\"No label 2 in file {file}, skipping.\")\n        return\n\n    index_to_remove = []\n    for i, label_slice in enumerate(segmentation_slices):\n        if i == 0 or i == len(segmentation_slices) - 1:\n            continue\n\n        if np.sum(label_slice == 2) == 0:\n            if (\n                np.sum(segmentation_slices[i - 1] == 2) &gt; 0\n                and np.sum(segmentation_slices[i + 1] == 2) &gt; 0\n            ):\n                index_to_remove.append(i)\n\n    if not index_to_remove:\n        logger.info(f\"No slices to remove in file {file}\")\n        return\n\n    image_slice_filt = np.delete(image_slices, index_to_remove, axis=0)\n    label_slices_filt = np.delete(segmentation_slices, index_to_remove, axis=0)\n\n    with h5py.File(output_file_path, \"w\") as f:\n        f.create_dataset(\"image\", data=image_slice_filt)\n        f.create_dataset(\"segmentation\", data=label_slices_filt)\n    logger.info(f\"Filtered and saved {file}\")\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_file_for_iterative_lumens(args)","title":"<code>args</code>","text":"(<code>tuple</code>)           \u2013            <p>A tuple containing the file name, data path, and save path. The tuple should be in the format (file_name, data_path, save_path).</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_for_iterative_lumens","title":"filter_for_iterative_lumens","text":"<pre><code>filter_for_iterative_lumens(data_path, save_path)\n</code></pre> <p>Filter for iterative lumens across multiple files in parallel.</p> <p>This function processes HDF5 files in the specified data path, filtering out slices that do not contain the iterative lumen label (2). It removes slices that are not part of the iterative lumen by checking if the label 2 is present in the segmentation slices. If a slice does not contain label 2, it checks the neighboring slices to determine if it should be removed. The filtered slices are saved to the specified save path.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def filter_for_iterative_lumens(data_path, save_path):\n    \"\"\"Filter for iterative lumens across multiple files in parallel.\n\n    This function processes HDF5 files in the specified data path, filtering out slices\n    that do not contain the iterative lumen label (2). It removes slices that are not\n    part of the iterative lumen by checking if the label 2 is present in the\n    segmentation slices. If a slice does not contain label 2, it checks the neighboring\n    slices to determine if it should be removed.\n    The filtered slices are saved to the specified save path.\n\n    Parameters\n    ----------\n    data_path : str\n        Path to the input data directory containing .h5 files.\n    save_path : str\n        Path to the output directory where filtered .h5 files will be saved.\n    \"\"\"\n    if not os.path.exists(save_path):\n        os.makedirs(save_path)\n        logger.info(f\"Created directory: {save_path}\")\n\n    files = [f for f in os.listdir(data_path) if f.endswith(\".h5\")]\n    logger.info(f\"Found {len(files)} files to process.\")\n    files = tqdm(files, desc=\"Processing files\")\n\n    # Pack arguments for parallel processing\n    file_args = [(f, data_path, save_path) for f in files]\n\n    with concurrent.futures.ProcessPoolExecutor(max_workers=12) as executor:\n        list(executor.map(filter_file_for_iterative_lumens, file_args))\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_for_iterative_lumens(data_path)","title":"<code>data_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the input data directory containing .h5 files.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.filter_for_iterative_lumens(save_path)","title":"<code>save_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the output directory where filtered .h5 files will be saved.</p>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.find_lumen_in_slice","title":"find_lumen_in_slice","text":"<pre><code>find_lumen_in_slice(image_slice: ndarray, label_slice: ndarray, predictor: SAM2ImagePredictor, resnet_predictor: ResNet3ClassClassifier, sam_quality_threshold=0.1) -&gt; ndarray\n</code></pre> <p>Find lumen and branch labels in a single 2D image slice.</p> <p>Uses a SAM-based segmentation followed by a ResNet-based mask classifier. This function performs the following high-level steps: 1. Converts the grayscale image slice to RGB and runs the provided SAM predictor     with a single central point to obtain up to three candidate masks and     associated quality scores. 2. For each SAM mask, creates a masked image (image * mask), crops it to the     mask's bounding box, and sends the cropped mask image to the provided     resnet_predictor to obtain a predicted class and confidence. 3. Builds a new label image where:     - label value 0 denotes background,     - label value 1 denotes branch tissue,     - label value 2 denotes lumen.     Classification decisions follow these rules:     - Only masks with SAM quality &gt; 0.1 are passed to the ResNet classifier.     - If no masks pass the quality threshold, the original label_slice is         returned unchanged.     - If one or more masks are predicted as lumen (class 0), the highest-quality         lumen mask is used to mark lumen (value 2). If that lumen mask touches the         background (according to lumen_touches_background) and another lumen mask         exists, the second-best lumen mask will be tried.     - Branch masks (class 1) are chosen by quality. If the best class-1 mask has         quality &lt; 0.5, branch pixels are copied from the original segmentation;         otherwise the SAM class-1 mask is used for branch labeling.     - If all candidate predictions are class 2 (non-lumen, non-branch), or if         the final lumen segmentation touches the background, the original         segmentation is returned. 4. Returns the label slice updated with lumen and branch annotations.</p> Parameters. <p>image_slice : numpy.ndarray         2D grayscale image array for the current slice (H x W). label_slice : numpy.ndarray         2D integer label array for the current slice (H x W). Non-zero values are         considered tissue/structures that can be re-assigned to branch (1) or         lumen (2). predictor : object         SAM predictor instance providing:         - set_image(image_rgb) to set the image,         - predict(point_coords, point_labels, multimask_output=True) to return             (masks, scores, ...) where masks is an array-like of binary masks and             scores (sam_quality) is an array-like of quality values. resnet_predictor : object         Classifier for cropped mask images. Must implement:         - predict(cropped_mask_image) -&gt; (pred_class, confidence)         Where pred_class is an integer code (0 for lumen, 1 for branch, 2 for other)         and confidence is a float confidence score. sam_quality_threshold : float         Minimum SAM quality score to consider a mask for classification.</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>A 2D label array (same shape as label_slice) where lumen pixels are set to 2, branch pixels to 1, and background to 0. In cases where SAM/resnet-based postprocessing is deemed unreliable, the original label_slice is returned unchanged.</p> </li> </ul> Notes <ul> <li>The behavior and thresholds (SAM quality &gt; 0.1 to classify, class-1 quality     threshold 0.5) are tuned heuristics that can be adjusted if needed.</li> </ul> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def find_lumen_in_slice(\n    image_slice: np.ndarray,\n    label_slice: np.ndarray,\n    predictor: \"SAM2ImagePredictor\",\n    resnet_predictor: \"ResNet3ClassClassifier\",\n    sam_quality_threshold=0.1,\n) -&gt; np.ndarray:\n    \"\"\"\n    Find lumen and branch labels in a single 2D image slice.\n\n    Uses a SAM-based segmentation followed by a ResNet-based mask classifier.\n    This function performs the following high-level steps:\n    1. Converts the grayscale image slice to RGB and runs the provided SAM predictor\n        with a single central point to obtain up to three candidate masks and\n        associated quality scores.\n    2. For each SAM mask, creates a masked image (image * mask), crops it to the\n        mask's bounding box, and sends the cropped mask image to the provided\n        resnet_predictor to obtain a predicted class and confidence.\n    3. Builds a new label image where:\n        - label value 0 denotes background,\n        - label value 1 denotes branch tissue,\n        - label value 2 denotes lumen.\n        Classification decisions follow these rules:\n        - Only masks with SAM quality &gt; 0.1 are passed to the ResNet classifier.\n        - If no masks pass the quality threshold, the original label_slice is\n            returned unchanged.\n        - If one or more masks are predicted as lumen (class 0), the highest-quality\n            lumen mask is used to mark lumen (value 2). If that lumen mask touches the\n            background (according to lumen_touches_background) and another lumen mask\n            exists, the second-best lumen mask will be tried.\n        - Branch masks (class 1) are chosen by quality. If the best class-1 mask has\n            quality &lt; 0.5, branch pixels are copied from the original segmentation;\n            otherwise the SAM class-1 mask is used for branch labeling.\n        - If all candidate predictions are class 2 (non-lumen, non-branch), or if\n            the final lumen segmentation touches the background, the original\n            segmentation is returned.\n    4. Returns the label slice updated with lumen and branch annotations.\n    Parameters.\n    ----------\n    image_slice : numpy.ndarray\n            2D grayscale image array for the current slice (H x W).\n    label_slice : numpy.ndarray\n            2D integer label array for the current slice (H x W). Non-zero values are\n            considered tissue/structures that can be re-assigned to branch (1) or\n            lumen (2).\n    predictor : object\n            SAM predictor instance providing:\n            - set_image(image_rgb) to set the image,\n            - predict(point_coords, point_labels, multimask_output=True) to return\n                (masks, scores, ...) where masks is an array-like of binary masks and\n                scores (sam_quality) is an array-like of quality values.\n    resnet_predictor : object\n            Classifier for cropped mask images. Must implement:\n            - predict(cropped_mask_image) -&gt; (pred_class, confidence)\n            Where pred_class is an integer code (0 for lumen, 1 for branch, 2 for other)\n            and confidence is a float confidence score.\n    sam_quality_threshold : float\n            Minimum SAM quality score to consider a mask for classification.\n\n    Returns\n    -------\n    numpy.ndarray\n            A 2D label array (same shape as label_slice) where lumen pixels are set to\n            2, branch pixels to 1, and background to 0. In cases where SAM/resnet-based\n            postprocessing is deemed unreliable, the original label_slice is returned\n            unchanged.\n\n    Notes\n    -----\n    - The behavior and thresholds (SAM quality &gt; 0.1 to classify, class-1 quality\n        threshold 0.5) are tuned heuristics that can be adjusted if needed.\n\n\n    \"\"\"\n    # Segment using SAM2\n    h, w = image_slice.shape\n    image_slice_rgb = grey2rgb(image_slice)\n    predictor.set_image(image_slice_rgb)\n    sam_point = np.array([[h // 2, w // 2]])\n    sam_label = np.array([1])\n    sam_mask, sam_quality, _ = predictor.predict(\n        point_coords=sam_point,\n        point_labels=sam_label,\n        multimask_output=True,\n    )\n\n    mask_img1 = image_slice * sam_mask[0]\n    mask_img2 = image_slice * sam_mask[1]\n    mask_img3 = image_slice * sam_mask[2]\n\n    # crop to bounding box\n    min_x, min_y, max_x, max_y = ski.measure.regionprops(sam_mask[0].astype(int))[\n        0\n    ].bbox\n    mask_img1 = mask_img1[min_x:max_x, min_y:max_y]\n\n    min_x, min_y, max_x, max_y = ski.measure.regionprops(sam_mask[1].astype(int))[\n        0\n    ].bbox\n    mask_img2 = mask_img2[min_x:max_x, min_y:max_y]\n\n    min_x, min_y, max_x, max_y = ski.measure.regionprops(sam_mask[2].astype(int))[\n        0\n    ].bbox\n    mask_img3 = mask_img3[min_x:max_x, min_y:max_y]\n\n    label_with_lumen = np.zeros_like(label_slice, dtype=np.uint8)\n    preds = []\n    mask_imgs = [mask_img1, mask_img2, mask_img3]\n\n    for j, mask_img in enumerate(mask_imgs):\n        # Only classify if SAM mask quality is above threshold\n        if sam_quality[j] &gt; sam_quality_threshold:\n            pred_class, conf = resnet_predictor.predict(mask_img)\n            preds.append(\n                {\n                    \"index\": j,\n                    \"class\": pred_class,\n                    \"conf\": conf,\n                    \"quality\": sam_quality[j],\n                }\n            )\n        else:\n            logger.info(\n                f\"Skipping SAM mask {j},\\n\" f\"due to low quality ({sam_quality[j]:.2f})\"\n            )\n\n    # If no good-quality masks, fall back to original segmentation\n    if len(preds) == 0:\n        logger.info(\"No SAM masks with quality &gt; 0.5,\" \"using original segmentation.\")\n        label_with_lumen = label_slice.copy()\n    else:\n        logger.info([p[\"class\"] for p in preds])\n\n        # Handle lumen (class 0)\n        lumen_preds = [p for p in preds if p[\"class\"] == 0]\n        if lumen_preds:\n            logger.info(\"Found lumen\")\n            best_lumen = max(lumen_preds, key=lambda x: x[\"quality\"])\n            label_with_lumen[sam_mask[best_lumen[\"index\"]] == 1] = 2\n\n        # Handle branches (class 1)\n        class1_preds = [p for p in preds if p[\"class\"] == 1]\n        if class1_preds:\n            best_class1 = max(class1_preds, key=lambda x: x[\"quality\"])\n            if best_class1[\"quality\"] &lt; 0.5:\n                logger.info(\n                    \"Low quality for class 1 mask,\"\n                    \"assigning class 1 to original segmentation\"\n                )\n                mask = (label_slice != 0) &amp; (label_with_lumen == 0)\n                label_with_lumen[mask] = 1\n            else:\n                mask = (sam_mask[best_class1[\"index\"]] == 1) &amp; (label_with_lumen == 0)\n                label_with_lumen[mask] = 1\n        else:\n            # If no class 1 was found, use original segmentation\n            label_with_lumen[(label_slice != 0) &amp; (label_with_lumen == 0)] = 1\n\n        # Handle case where all are bad (class 2)\n        if all(p[\"class\"] == 2 for p in preds):\n            label_with_lumen = label_slice.copy()\n        if lumen_touches_background(label_with_lumen):\n            logger.info(\n                \"Lumen touches background,\" \"reverting to original segmentation.\"\n            )\n            label_with_lumen = label_slice.copy()\n\n    label_slice = label_with_lumen\n    return label_slice\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.fix_only_lumen","title":"fix_only_lumen","text":"<pre><code>fix_only_lumen(segmentation_slice)\n</code></pre> <p>Fix segmentation slices containing only lumen.</p> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def fix_only_lumen(segmentation_slice):\n    \"\"\"Fix segmentation slices containing only lumen.\"\"\"\n    boundary_lumen = set(\n        map(\n            tuple,\n            np.round(\n                np.concatenate(ski.measure.find_contours(segmentation_slice == 2, 0.5))\n            ).astype(np.int32),\n        )\n    )\n    boundary_background = set(\n        map(\n            tuple,\n            np.round(\n                np.concatenate(ski.measure.find_contours(segmentation_slice == 0, 0.5))\n            ).astype(np.int32),\n        )\n    )\n    return bool(boundary_lumen &amp; boundary_background)\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.lumen_touches_background","title":"lumen_touches_background","text":"<pre><code>lumen_touches_background(label_slice)\n</code></pre> <p>Check if lumen touches background in a label slice.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if lumen touches background, False otherwise.</p> </li> </ul> Source code in <code>skeleplex/measurements/branches.py</code> <pre><code>def lumen_touches_background(label_slice):\n    \"\"\"Check if lumen touches background in a label slice.\n\n    Parameters\n    ----------\n    label_slice : numpy.ndarray\n        2D array representing the label slice.\n\n    Returns\n    -------\n    bool\n        True if lumen touches background, False otherwise.\n\n    \"\"\"\n    lumen_label = 2\n    background_label = 0\n    lumen_mask = label_slice == lumen_label\n    background_mask = label_slice == background_label\n    # Dilate lumen mask to ensure touching\n    dilated_lumen = binary_dilation(lumen_mask, footprint=disk(1))\n    touching = np.any(dilated_lumen &amp; background_mask)\n    return touching\n</code></pre>"},{"location":"reference/skeleplex/measurements/branches/#skeleplex.measurements.branches.lumen_touches_background(label_slice)","title":"<code>label_slice</code>","text":"(<code>ndarray</code>)           \u2013            <p>2D array representing the label slice.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/","title":"fit_surface","text":""},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface","title":"skeleplex.measurements.fit_surface","text":"<p>Functions:</p> <ul> <li> <code>distance_to_surface</code>             \u2013              <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> </li> <li> <code>extract_central_region</code>             \u2013              <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_branches</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_nodes</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_to_pointcloud_rbf_pca</code>             \u2013              <p>Fits an radial basis function surface to a pointcloud using PCA.</p> </li> <li> <code>get_normal_of_closest_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> <li> <code>get_normal_of_closest_surface_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface","title":"distance_to_surface","text":"<pre><code>distance_to_surface(vertices, faces, points)\n</code></pre> <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>distances</code> (              <code>ndarray</code> )          \u2013            <p>An array of shape (n_points,) containing the distances of each point to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def distance_to_surface(vertices, faces, points):\n    \"\"\"\n    Computes the distance of a set of points to a surface defined by vertices and faces.\n\n    Parameters\n    ----------\n    vertices : np.ndarray\n        An array of shape (n_vertices, 3) containing the vertices of the surface.\n    faces : np.ndarray\n        An array of shape (n_faces, 3) containing the faces of the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    distances : np.ndarray\n        An array of shape (n_points,) containing the distances of each point\n        to the surface.\n    \"\"\"\n    mesh = tri.Trimesh(vertices, faces)\n    closest_point, distance, triangles = mesh.nearest.on_surface(points)\n    return closest_point, distance, triangles\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface(vertices)","title":"<code>vertices</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_vertices, 3) containing the vertices of the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface(faces)","title":"<code>faces</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_faces, 3) containing the faces of the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.distance_to_surface(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.extract_central_region","title":"extract_central_region","text":"<pre><code>extract_central_region(points, percentile=50)\n</code></pre> <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>central_points</code> (              <code>ndarray</code> )          \u2013            <p>The extracted central points.</p> </li> <li> <code>pca</code> (              <code>PCA</code> )          \u2013            <p>The PCA transformation object.</p> </li> <li> <code>mean</code> (              <code>ndarray</code> )          \u2013            <p>Mean of the original point cloud.</p> </li> <li> <code>components</code> (              <code>ndarray</code> )          \u2013            <p>The principal component axes.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def extract_central_region(points, percentile=50):\n    \"\"\"\n    Extracts the central region of the point cloud using PCA and a distance threshold.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array containing the 3D point cloud.\n    percentile : float\n        The percentage of points to keep (default 50% around the mean).\n\n    Returns\n    -------\n    central_points : np.ndarray\n        The extracted central points.\n    pca : PCA\n        The PCA transformation object.\n    mean : np.ndarray\n        Mean of the original point cloud.\n    components : np.ndarray\n        The principal component axes.\n    \"\"\"\n    # Center the points\n    mean = np.mean(points, axis=0)\n    centered_points = points - mean\n\n    # Apply PCA\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    components = pca.components_  # Principal axes\n\n    # Transform points into PCA space\n    aligned_points = centered_points @ components.T  # Manual projection\n\n    # Compute distances in PCA space (only in the XY plane)\n    distances = np.linalg.norm(aligned_points[:, :2], axis=1)\n    threshold = np.percentile(distances, percentile)\n\n    # Select only the central points\n    central_points = points[distances &lt; threshold]\n    return central_points, mean, components\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.extract_central_region(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array containing the 3D point cloud.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.extract_central_region(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>50</code> )           \u2013            <p>The percentage of points to keep (default 50% around the mean).</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches","title":"fit_surface_and_get_surface_normal_of_branches","text":"<pre><code>fit_surface_and_get_surface_normal_of_branches(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the branch midpoint.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_branches(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the\n    surface to the branch midpoint.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n         The graph containing the nodes.\n    lobe_name : str\n         The lobe to process.\n    smooth : float\n         RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n         A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n         A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n         The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    lobe_edge_ID_dict = {}\n\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n            lobe_edge_ID_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n        lobe_edge_ID_dict[lobe].append((u, v))\n\n    lobe_coordinates = np.array(lobe_node_dict[lobe_name])\n    lobe_edges = lobe_edge_ID_dict[lobe_name]\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_coordinates, smooth=smooth, percentile=100\n    )\n\n    mesh = tri.Trimesh(vertices, faces)\n\n    if not all(\"branch_midpoint\" in graph.edges[u, v] for u, v in graph.edges):\n        splines = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n        spline_midpoint_dict = {}\n        # get the midpoint of each spline\n        for edge, spline in splines.items():\n            spline_midpoint_dict[edge] = spline.eval(0.1, approx=True)\n    else:\n        spline_midpoint_dict = nx.get_edge_attributes(graph, \"branch_midpoint\")\n\n    lobe_midpoints = np.array([spline_midpoint_dict[key] for key in lobe_edges])\n\n    normal_dict, distance_dict = get_normal_of_closest_point(mesh, lobe_midpoints)\n\n    edge_normal_dict = {}\n    edge_distance_dict = {}\n\n    # Assign the normals and distances to the edges\n    for edge in lobe_edges:\n        edge_normal_dict[edge] = normal_dict[tuple(spline_midpoint_dict[edge])]\n        edge_distance_dict[edge] = distance_dict[tuple(spline_midpoint_dict[edge])]\n\n    return edge_normal_dict, edge_distance_dict, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_branches(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes","title":"fit_surface_and_get_surface_normal_of_nodes","text":"<pre><code>fit_surface_and_get_surface_normal_of_nodes(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_nodes(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the surface to the node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph containing the nodes.\n    lobe_name : str\n        The lobe to process.\n    smooth : float\n        RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n        A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n        A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n        The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n\n    lobe_points = np.array(lobe_node_dict[lobe_name])\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_points, smooth=smooth, percentile=100\n    )\n    mesh = tri.Trimesh(vertices, faces)\n    normals, distances = get_normal_of_closest_point(mesh, lobe_points)\n    return normals, distances, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_and_get_surface_normal_of_nodes(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca","title":"fit_surface_to_pointcloud_rbf_pca","text":"<pre><code>fit_surface_to_pointcloud_rbf_pca(points: ndarray, smooth=0.2, percentile=100)\n</code></pre> <p>Fits an radial basis function surface to a pointcloud using PCA.</p> <p>Can be fitted to a central region of the pointcloud. PCA is used to find the principle axis of the point cloud at which axis the surface is fitted.</p> See Also <p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>vertices, faces : np.ndarray</code>           \u2013            <p>Mesh vertices and faces.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def fit_surface_to_pointcloud_rbf_pca(points: np.ndarray, smooth=0.2, percentile=100):\n    \"\"\"Fits an radial basis function surface to a pointcloud using PCA.\n\n    Can be fitted to a central region of the pointcloud.\n    PCA is used to find the principle axis of the point cloud at which axis the\n    surface is fitted.\n\n    See Also\n    --------\n    https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.Rbf.html\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array of 3D points.\n    smooth : float\n        RBF smoothing factor. 0 would fit the surface exactly to the points.\n        Thus to fit a surface through a pointcloud, a high value is recommended.\n    percentile : float\n        How much of the central region to retain (default 100%).\n\n    Returns\n    -------\n    vertices, faces : np.ndarray\n        Mesh vertices and faces.\n    \"\"\"\n    # Extract central region\n    central_points, mean, components = extract_central_region(points, percentile)\n\n    # Transform central points into PCA space\n    pca_space_points = (central_points - mean) @ components.T  # Manual projection\n\n    # Fit RBF surface on the central points in PCA space\n    x, y, z = pca_space_points[:, 0], pca_space_points[:, 1], pca_space_points[:, 2]\n    rbf = Rbf(x, y, z, function=\"multiquadric\", smooth=smooth)\n\n    # Generate a grid in PCA space\n    x_grid, y_grid = np.meshgrid(\n        np.linspace(np.min(x) - 50, np.max(x) + 50, 50),\n        np.linspace(np.min(y) - 50, np.max(y) + 50, 50),\n    )\n    z_grid = rbf(x_grid, y_grid)\n\n    # Reconstruct the surface back into original space\n    grid_points_pca = np.vstack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel())).T\n    original_grid_points = (\n        grid_points_pca @ components\n    ) + mean  # Correct transformation\n\n    # Build mesh\n    vertices = original_grid_points\n    tri = Delaunay(vertices[:, :2])\n    faces = tri.simplices\n\n    return vertices, faces\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array of 3D points.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>RBF smoothing factor. 0 would fit the surface exactly to the points. Thus to fit a surface through a pointcloud, a high value is recommended.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.fit_surface_to_pointcloud_rbf_pca(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>100</code> )           \u2013            <p>How much of the central region to retain (default 100%).</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_point","title":"get_normal_of_closest_point","text":"<pre><code>get_normal_of_closest_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def get_normal_of_closest_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    if len(points.shape) == 1:\n        points = np.expand_dims(points, axis=0)\n\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = tri.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_surface_point","title":"get_normal_of_closest_surface_point","text":"<pre><code>get_normal_of_closest_surface_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/fit_surface.py</code> <pre><code>def get_normal_of_closest_surface_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    # Find the closest point on the surface\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = trimesh.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_surface_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/fit_surface/#skeleplex.measurements.fit_surface.get_normal_of_closest_surface_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/","title":"graph_properties","text":""},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties","title":"skeleplex.measurements.graph_properties","text":"<p>Functions:</p> <ul> <li> <code>assign_edge_ids</code>             \u2013              <p>Assign unique IDs to each edge in the graph.</p> </li> <li> <code>compute_branch_curvature</code>             \u2013              <p>Compute the curvature of each branch in the graph.</p> </li> <li> <code>compute_branch_length</code>             \u2013              <p>Compute the length of each branch in the graph.</p> </li> <li> <code>compute_level</code>             \u2013              <p>Compute the level of each node and edge in the graph.</p> </li> <li> <code>compute_number_of_tips_connected_to_edges</code>             \u2013              <p>Compute the number of tips connected to each edge in the graph.</p> </li> <li> <code>count_number_of_tips_connected_to_edge</code>             \u2013              <p>Count the number of tips connected to an edge in the graph.</p> </li> <li> <code>get_all_graph_properties</code>             \u2013              <p>Runs all registered graph properties in order.</p> </li> <li> <code>get_daughter_edges</code>             \u2013              <p>Return a graph with daughter edges annotated.</p> </li> <li> <code>get_parent_edges</code>             \u2013              <p>Return a graph with parent edges annotated.</p> </li> <li> <code>get_sister_edges</code>             \u2013              <p>Return a graph with sister edges annotated.</p> </li> <li> <code>graph_property</code>             \u2013              <p>Decorator to register a function as an angle metric.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.assign_edge_ids","title":"assign_edge_ids","text":"<pre><code>assign_edge_ids(graph, prefix)\n</code></pre> <p>Assign unique IDs to each edge in the graph.</p> <p>Allows to trace edges across different graphs by using a common prefix and store different graphs in the same database.</p> <p>Adds two edge attributes: - EDGE_ID_KEY: Unique ID for each edge. - PARENT_EDGE_ID_KEY: Unique ID of the parent edge.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef assign_edge_ids(graph, prefix):\n    \"\"\"Assign unique IDs to each edge in the graph.\n\n    Allows to trace edges across different graphs by using a common prefix and\n    store different graphs in the same database.\n\n    Adds two edge attributes:\n    - EDGE_ID_KEY: Unique ID for each edge.\n    - PARENT_EDGE_ID_KEY: Unique ID of the parent edge.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n    prefix : str\n        The prefix to use for the edge IDs.\n    \"\"\"\n\n    id_dict = {}\n    parent_id_dict = {}\n    parent_edge_dict = nx.get_edge_attributes(graph, 'parent_edge')\n    for u,v in graph.edges():\n        id = prefix + '_' + str(u) + '_' + str(v)\n        id_dict[(u,v)] = id\n        parent_edge = parent_edge_dict[(u,v)]\n        if parent_edge:\n            parent_edge=  parent_edge[0]\n            parent_id_dict[(u,v)]= prefix + '_' + str(parent_edge[0]) + '_' + str(parent_edge[1])\n    nx.set_edge_attributes(graph, id_dict, EDGE_ID_KEY)\n    nx.set_edge_attributes(graph, parent_id_dict, PARENT_EDGE_ID_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.assign_edge_ids(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.assign_edge_ids(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>)           \u2013            <p>The prefix to use for the edge IDs.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_curvature","title":"compute_branch_curvature","text":"<pre><code>compute_branch_curvature(graph, sample_positions=linspace(0, 1, 10), approx=True)\n</code></pre> <p>Compute the curvature of each branch in the graph.</p> <p>We use the mean curvature normalized by the arch length as a measure for branch curvature.</p> <p>The curvature of a branch is computed from its spline representation.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with branch curvatures annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef compute_branch_curvature(graph,\n                             sample_positions=np.linspace(0, 1, 10),\n                             approx=True):\n    \"\"\"Compute the curvature of each branch in the graph.\n\n    We use the mean curvature normalized by the arch length\n    as a measure for branch curvature.\n\n    The curvature of a branch is computed from its spline representation.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n    sample_positions : np.ndarray, optional\n        The positions along the spline to sample for curvature computation.\n        The default is np.linspace(0, 1, 10).\n    approx : bool, optional\n        Whether to use approximate curvature computation. The default is True.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with branch curvatures annotated.\n    \"\"\"\n    graph = graph.copy()\n    curvature_dir = {}\n    for u, v in graph.edges():\n        spline = graph[u][v][EDGE_SPLINE_KEY]\n        curvature = spline.curvature(sample_positions, approx=approx)\n        mean_norm_curvature = np.mean(curvature) / spline.arc_length\n        curvature_dir[(u, v)] = mean_norm_curvature\n    nx.set_edge_attributes(graph, curvature_dir, BRANCH_CURVATURE_EDGE_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_curvature(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_curvature(sample_positions)","title":"<code>sample_positions</code>","text":"(<code>ndarray</code>, default:                   <code>linspace(0, 1, 10)</code> )           \u2013            <p>The positions along the spline to sample for curvature computation. The default is np.linspace(0, 1, 10).</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_curvature(approx)","title":"<code>approx</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to use approximate curvature computation. The default is True.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_length","title":"compute_branch_length","text":"<pre><code>compute_branch_length(graph)\n</code></pre> <p>Compute the length of each branch in the graph.</p> <p>The length of a branch is the path length between its start and end nodes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with branch lengths annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef compute_branch_length(graph):\n    \"\"\"Compute the length of each branch in the graph.\n\n    The length of a branch is the path length between its start and end nodes.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with branch lengths annotated.\n    \"\"\"\n    graph = graph.copy()\n    length_dir = {}\n    for u, v in graph.edges():\n        spline = graph[u][v][EDGE_SPLINE_KEY]\n        length = spline.arc_length\n        length_dir[(u, v)] = length\n    nx.set_edge_attributes(graph, length_dir, LENGTH_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_branch_length(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_level","title":"compute_level","text":"<pre><code>compute_level(graph: DiGraph, origin: int)\n</code></pre> <p>Compute the level of each node and edge in the graph.</p> <p>The level of a node is the shortest path length from the origin node. The level of an edge is the level of its start node.</p> <p>The level is stored at the key specified by skeleplex.graph.constants.GENERATION_KEY.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with node and edge levels annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef compute_level(graph: nx.DiGraph, origin: int):\n    \"\"\"Compute the level of each node and edge in the graph.\n\n    The level of a node is the shortest path length from the origin node.\n    The level of an edge is the level of its start node.\n\n    The level is stored at the key specified by\n    skeleplex.graph.constants.GENERATION_KEY.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n    origin : int\n        The origin node.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with node and edge levels annotated.\n    \"\"\"\n    level_dir = {}\n    graph = graph.copy()\n    for node in graph.nodes():\n        if nx.has_path(graph, origin, node):\n            level = nx.shortest_path_length(graph, origin, node)\n        else:\n            level = -1\n        level_dir[node] = level\n    nx.set_node_attributes(graph, level_dir, GENERATION_KEY)\n\n    # Set edge level to level of start node\n    level_dir = {}\n    for u, v in graph.edges():\n        node_level = graph.nodes[u][GENERATION_KEY]\n        level_dir[(u, v)] = node_level\n    nx.set_edge_attributes(graph, level_dir, GENERATION_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_level(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_level(origin)","title":"<code>origin</code>","text":"(<code>int</code>)           \u2013            <p>The origin node.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_number_of_tips_connected_to_edges","title":"compute_number_of_tips_connected_to_edges","text":"<pre><code>compute_number_of_tips_connected_to_edges(graph)\n</code></pre> <p>Compute the number of tips connected to each edge in the graph.</p> <p>The number of tips connected to an edge is the number of leaf nodes in the subtree rooted at the edge's end node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with the number of tips connected to each edge annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef compute_number_of_tips_connected_to_edges(graph):\n    \"\"\"Compute the number of tips connected to each edge in the graph.\n\n    The number of tips connected to an edge is the number of leaf nodes in the subtree\n    rooted at the edge's end node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with the number of tips connected to each edge annotated.\n    \"\"\"\n    graph = graph.copy()\n    num_tips_dir = {}\n    for u, v in graph.edges():\n        num_tips = count_number_of_tips_connected_to_edge(graph, u, v)\n        num_tips_dir[(u, v)] = num_tips\n    nx.set_edge_attributes(graph, num_tips_dir, NUMBER_OF_TIPS_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.compute_number_of_tips_connected_to_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge","title":"count_number_of_tips_connected_to_edge","text":"<pre><code>count_number_of_tips_connected_to_edge(graph, start_node, end_node)\n</code></pre> <p>Count the number of tips connected to an edge in the graph.</p> <p>The number of tips connected to an edge is the number of leaf nodes in the subtree rooted at the edge's end node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of tips connected to the edge.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def count_number_of_tips_connected_to_edge(graph, start_node, end_node):\n    \"\"\"Count the number of tips connected to an edge in the graph.\n\n    The number of tips connected to an edge is the number of leaf nodes in the subtree\n    rooted at the edge's end node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n    start_node : int\n        The start node of the edge.\n    end_node : int\n        The end node of the edge.\n\n    Returns\n    -------\n    int\n        The number of tips connected to the edge.\n    \"\"\"\n    # Perform a breadth-first search starting from the end_node\n    subtree = nx.bfs_tree(graph, end_node)\n\n    # Initialize count of endpoints\n    num_endpoints = 0\n\n    # Iterate through nodes in the subtree\n    for node in subtree.nodes:\n        # Check if the node is a leaf node (degree 1) and is not the start_node\n        if subtree.degree(node) == 1 and node != start_node:\n            num_endpoints += 1\n\n    return num_endpoints\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge(start_node)","title":"<code>start_node</code>","text":"(<code>int</code>)           \u2013            <p>The start node of the edge.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.count_number_of_tips_connected_to_edge(end_node)","title":"<code>end_node</code>","text":"(<code>int</code>)           \u2013            <p>The end node of the edge.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_all_graph_properties","title":"get_all_graph_properties","text":"<pre><code>get_all_graph_properties(graph, **kwargs)\n</code></pre> <p>Runs all registered graph properties in order.</p> <p>Each property must accept a graph, and may accept additional keyword arguments. Returns a list of (name, graph_out, extra_return_values).</p> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def get_all_graph_properties(graph, **kwargs):\n    \"\"\"Runs all registered graph properties in order.\n\n    Each property must accept a graph, and may accept additional keyword arguments.\n    Returns a list of (name, graph_out, extra_return_values).\n    \"\"\"\n    results = []\n    g = graph\n    for func in _GRAPH_PROPERTY_FUNCTIONS:\n        name = func.__name__\n        logger.info(f\"Running graph property: {name}\")\n        out = func(g, **{k: v for k, v in kwargs.items() if k in func.__code__.co_varnames})\n        # out can be (graph) or (graph, extra)\n        if isinstance(out, tuple):\n            g = out[0]\n            extra = out[1:]\n        else:\n            g = out\n            extra = ()\n        results.append((name, g, *extra))\n\n    return g, results\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_daughter_edges","title":"get_daughter_edges","text":"<pre><code>get_daughter_edges(graph)\n</code></pre> <p>Return a graph with daughter edges annotated.</p> <p>This function identifies daughter edges for each edge in the graph. Daughter edges are edges that share the same end node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with daughter edges annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef get_daughter_edges(graph):\n    \"\"\"Return a graph with daughter edges annotated.\n\n    This function identifies daughter edges for each edge in the graph.\n    Daughter edges are edges that share the same end node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with daughter edges annotated.\n    \"\"\"\n    graph = graph.copy()\n    daughter_dict = {}\n    for edge in graph.edges():\n        daughters = list(graph.out_edges(edge[1]))\n        daughter_dict[edge] = daughters\n    nx.set_edge_attributes(graph, daughter_dict, DAUGHTER_EDGES_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_daughter_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_parent_edges","title":"get_parent_edges","text":"<pre><code>get_parent_edges(graph: DiGraph)\n</code></pre> <p>Return a graph with parent edges annotated.</p> <p>This function identifies parent edges for each edge in the graph. Parent edges are edges that share the same start node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with parent edges annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef get_parent_edges(graph: nx.DiGraph):\n    \"\"\"Return a graph with parent edges annotated.\n\n    This function identifies parent edges for each edge in the graph.\n    Parent edges are edges that share the same start node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with parent edges annotated.\n    \"\"\"\n    graph = graph.copy()\n    parent_dict = {}\n    for edge in graph.edges():\n        parents = list(graph.in_edges(edge[0]))\n        parent_dict[edge] = parents\n    nx.set_edge_attributes(graph, parent_dict, PARENT_EDGE_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_parent_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_sister_edges","title":"get_sister_edges","text":"<pre><code>get_sister_edges(graph: DiGraph)\n</code></pre> <p>Return a graph with sister edges annotated.</p> <p>This function identifies sister edges for each edge in the graph. Sister edges are edges that share the same start node but are not the same edge.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>DiGraph</code>           \u2013            <p>The graph with sister edges annotated.</p> </li> </ul> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>@graph_property\ndef get_sister_edges(graph: nx.DiGraph):\n    \"\"\"Return a graph with sister edges annotated.\n\n    This function identifies sister edges for each edge in the graph.\n    Sister edges are edges that share the same start node but are not the same edge.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The input graph.\n\n    Returns\n    -------\n    nx.DiGraph\n        The graph with sister edges annotated.\n    \"\"\"\n    graph = graph.copy()\n    sister_dict = {}\n    for edge in graph.edges():\n        sisters = list(graph.out_edges(edge[0]))\n        sister = [s for s in sisters if s != edge]\n        if len(sister) == 1:\n            sister_dict[edge] = sister[0]\n        elif len(sister) &gt; 1:\n            print(\"Multiple sisters found for edge:\", edge)\n            sister_dict[edge] = sister[0]\n\n            # sister_dict[edge] = sister\n    nx.set_edge_attributes(graph, sister_dict, SISTER_EDGE_KEY)\n    return graph\n</code></pre>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.get_sister_edges(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The input graph.</p>"},{"location":"reference/skeleplex/measurements/graph_properties/#skeleplex.measurements.graph_properties.graph_property","title":"graph_property","text":"<pre><code>graph_property(func)\n</code></pre> <p>Decorator to register a function as an angle metric.</p> Source code in <code>skeleplex/measurements/graph_properties.py</code> <pre><code>def graph_property(func):\n    \"\"\"Decorator to register a function as an angle metric.\"\"\"\n    _GRAPH_PROPERTY_FUNCTIONS.append(func)\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/","title":"lumen_classifier","text":""},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier","title":"skeleplex.measurements.lumen_classifier","text":"<p>Classes:</p> <ul> <li> <code>H5DataModule</code>           \u2013            <p>Data module for loading HDF5 files for training and validation.</p> </li> <li> <code>H5FileDataset</code>           \u2013            <p>Dataset reader for HDF5 files.</p> </li> <li> <code>ResNet3ClassClassifier</code>           \u2013            <p>A pl model for classifying images into 3 classes using ResNet50 model.</p> </li> <li> <code>ResNet3ClassPredictor</code>           \u2013            <p>A class for predicting the class of an image using a pre-trained ResNet50 model.</p> </li> <li> <code>SaveClassifiedSlices</code>           \u2013            <p>Widget to save classified slices in different folders.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>add_class_based_on_folder_struct</code>             \u2013              <p>Add class labels to the h5 files based on their folder structure.</p> </li> <li> <code>split_and_copy_files</code>             \u2013              <p>Creates training and validation files from a file list.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.H5DataModule","title":"H5DataModule","text":"<pre><code>H5DataModule(data_dir='dataset', batch_size=16)\n</code></pre> <p>               Bases: <code>LightningDataModule</code></p> <pre><code>\n              flowchart TD\n              skeleplex.measurements.lumen_classifier.H5DataModule[H5DataModule]\n\n              \n\n              click skeleplex.measurements.lumen_classifier.H5DataModule href \"\" \"skeleplex.measurements.lumen_classifier.H5DataModule\"\n            </code></pre> <p>Data module for loading HDF5 files for training and validation.</p> <p>Methods:</p> <ul> <li> <code>train_dataloader</code>             \u2013              <p>Returns the training data loader.</p> </li> <li> <code>val_dataloader</code>             \u2013              <p>Returns the validation data loader.</p> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def __init__(self, data_dir=\"dataset\", batch_size=16):\n    super().__init__()\n    self.data_dir = data_dir\n    self.batch_size = batch_size\n\n    # def setup(self, stage=None):\n    # Load all .h5 files from train and val directories\n    train_dir = os.path.join(self.data_dir, \"train\")\n    val_dir = os.path.join(self.data_dir, \"val\")\n\n    train_files = [\n        os.path.join(train_dir, f)\n        for f in os.listdir(train_dir)\n        if f.endswith(\".h5\")\n    ]\n    val_files = [\n        os.path.join(val_dir, f) for f in os.listdir(val_dir) if f.endswith(\".h5\")\n    ]\n\n    self.train_dataset = H5FileDataset(train_files)\n    self.val_dataset = H5FileDataset(val_files)\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.H5DataModule.train_dataloader","title":"train_dataloader","text":"<pre><code>train_dataloader()\n</code></pre> <p>Returns the training data loader.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def train_dataloader(self):\n    \"\"\"Returns the training data loader.\"\"\"\n    return DataLoader(\n        self.train_dataset, batch_size=self.batch_size, shuffle=True, num_workers=4\n    )\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.H5DataModule.val_dataloader","title":"val_dataloader","text":"<pre><code>val_dataloader()\n</code></pre> <p>Returns the validation data loader.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def val_dataloader(self):\n    \"\"\"Returns the validation data loader.\"\"\"\n    return DataLoader(\n        self.val_dataset, batch_size=self.batch_size, shuffle=False, num_workers=4\n    )\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.H5FileDataset","title":"H5FileDataset","text":"<pre><code>H5FileDataset(file_paths)\n</code></pre> <p>               Bases: <code>Dataset</code></p> <pre><code>\n              flowchart TD\n              skeleplex.measurements.lumen_classifier.H5FileDataset[H5FileDataset]\n\n              \n\n              click skeleplex.measurements.lumen_classifier.H5FileDataset href \"\" \"skeleplex.measurements.lumen_classifier.H5FileDataset\"\n            </code></pre> <p>Dataset reader for HDF5 files.</p> <p>Reads images and class labels from HDF5 files. Image needs to be stored as \"image\" and class label as \"class_id\". A bunch of augmentations are applied.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def __init__(self, file_paths):\n    self.model_size = (256, 256)\n    self.file_paths = file_paths\n\n    self.transform = Compose(\n        [\n            Resize(self.model_size),  # Resize to (96, 96)\n            ToTensor(),  # Convert to PyTorch tensor (scales [0,255] -&gt; [0,1])\n            Normalize(\n                mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]\n            ),  # ResNet normalization\n            # Data Augmentations\n            RandomApply(\n                [\n                    ColorJitter(\n                        brightness=0.2, contrast=0.2, saturation=0.2, hue=0.1\n                    )\n                ],\n                p=0.1,\n            ),\n            RandomApply([RandomRotation(degrees=10)], p=0.1),\n            RandomApply([RandomAffine(degrees=0, scale=(0.9, 1.1))], p=0.1),\n            RandomHorizontalFlip(p=0.5),\n            RandomVerticalFlip(p=0.5),\n            RandomResizedCrop(\n                size=self.model_size, scale=(0.8, 1.0), ratio=(0.75, 1.333)\n            ),\n        ]\n    )\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier","title":"ResNet3ClassClassifier","text":"<pre><code>ResNet3ClassClassifier(num_classes=3, pretrained=False)\n</code></pre> <p>               Bases: <code>LightningModule</code></p> <pre><code>\n              flowchart TD\n              skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier[ResNet3ClassClassifier]\n\n              \n\n              click skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier href \"\" \"skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier\"\n            </code></pre> <p>A pl model for classifying images into 3 classes using ResNet50 model.</p> <p>Methods:</p> <ul> <li> <code>configure_optimizers</code>             \u2013              <p>Configures the optimizers and learning rate schedulers for the model.</p> </li> <li> <code>forward</code>             \u2013              <p>Forward pass through the model.</p> </li> <li> <code>training_step</code>             \u2013              <p>Performs a single training step.</p> </li> <li> <code>validation_step</code>             \u2013              <p>Performs a single validation step during model evaluation.</p> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def __init__(self, num_classes=3, pretrained=False):\n    super().__init__()\n    # Load pre-trained ResNet\n\n    self.resnet = models.resnet50(weights=None)\n    if pretrained:\n        weights = ResNet50_Weights.DEFAULT\n        self.resnet = models.resnet50(weights=weights)\n\n    # Replace the final fully connected layer to output `num_classes` classes\n    self.resnet.fc = nn.Linear(self.resnet.fc.in_features, num_classes)\n\n    # Define accuracy metric\n    self.train_acc = Accuracy(task=\"multiclass\", num_classes=num_classes)\n    self.val_acc = Accuracy(task=\"multiclass\", num_classes=num_classes)\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier.configure_optimizers","title":"configure_optimizers","text":"<pre><code>configure_optimizers()\n</code></pre> <p>Configures the optimizers and learning rate schedulers for the model.</p> <p>This method sets up the Adam optimizer with a learning rate of 1e-4 and a StepLR learning rate scheduler that reduces the learning rate by a factor of 0.1 every 7 steps.</p> <p>Returns:</p> <ul> <li> <code>    tuple: A tuple containing two lists:</code>           \u2013            <ul> <li>The first list contains the optimizer(s) to be used.</li> <li>The second list contains the learning rate scheduler(s) to be used.</li> </ul> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def configure_optimizers(self):\n    \"\"\"\n    Configures the optimizers and learning rate schedulers for the model.\n\n    This method sets up the Adam optimizer with a learning rate of 1e-4 and\n    a StepLR learning rate scheduler that reduces the learning rate by a\n    factor of 0.1 every 7 steps.\n\n    Returns\n    -------\n        tuple: A tuple containing two lists:\n            - The first list contains the optimizer(s) to be used.\n            - The second list contains the learning rate scheduler(s) to be used.\n    \"\"\"\n    # Use Adam optimizer and a learning rate scheduler\n    optimizer = torch.optim.Adam(self.parameters(), lr=1e-4)\n    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)\n    return [optimizer], [scheduler]\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier.forward","title":"forward","text":"<pre><code>forward(x)\n</code></pre> <p>Forward pass through the model.</p> <p>Args:     x (torch.Tensor): Input tensor.</p> <p>Returns:</p> <ul> <li> <code>    torch.Tensor: Output tensor after passing through the ResNet model.</code>           \u2013            </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def forward(self, x):\n    \"\"\"\n    Forward pass through the model.\n\n    Args:\n        x (torch.Tensor): Input tensor.\n\n    Returns\n    -------\n        torch.Tensor: Output tensor after passing through the ResNet model.\n    \"\"\"\n    return self.resnet(x)\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier.training_step","title":"training_step","text":"<pre><code>training_step(batch, batch_idx)\n</code></pre> <p>Performs a single training step.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def training_step(self, batch, batch_idx):\n    \"\"\"Performs a single training step.\"\"\"\n    images, labels = batch\n    logits = self(images)\n    # here we can add weights to the loss function to counteract class imbalance\n    weights = torch.tensor([1, 1, 1], dtype=torch.float32)\n    # weights = weights / class_counts\n    weights = weights / torch.sum(weights)\n    weights = weights.to(self.device)\n    loss = nn.CrossEntropyLoss(weight=weights)(logits, labels)\n    acc = self.train_acc(logits, labels)\n    self.log(\"train_loss\", loss, prog_bar=True)\n    self.log(\"train_acc\", acc, prog_bar=True)\n    return loss\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassClassifier.validation_step","title":"validation_step","text":"<pre><code>validation_step(batch, batch_idx)\n</code></pre> <p>Performs a single validation step during model evaluation.</p> <p>Args:     batch (tuple): A tuple containing the input data (images) and the     corresponding labels.     batch_idx (int): The index of the current batch.</p> <p>Returns:</p> <ul> <li> <code>    torch.Tensor: The computed loss for the current validation batch.</code>           \u2013            </li> <li> <code>Logs</code>          \u2013            <p>val_loss (float): The cross-entropy loss for the validation batch. val_acc (float): The accuracy of the model on the validation batch.</p> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def validation_step(self, batch, batch_idx):\n    \"\"\"\n    Performs a single validation step during model evaluation.\n\n    Args:\n        batch (tuple): A tuple containing the input data (images) and the\n        corresponding labels.\n        batch_idx (int): The index of the current batch.\n\n    Returns\n    -------\n        torch.Tensor: The computed loss for the current validation batch.\n    Logs:\n        val_loss (float): The cross-entropy loss for the validation batch.\n        val_acc (float): The accuracy of the model on the validation batch.\n    \"\"\"\n    images, labels = batch\n    logits = self(images)\n    loss = nn.CrossEntropyLoss()(logits, labels)\n    acc = self.val_acc(logits, labels)\n    self.log(\"val_loss\", loss, prog_bar=True)\n    self.log(\"val_acc\", acc, prog_bar=True)\n    return loss\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassPredictor","title":"ResNet3ClassPredictor","text":"<pre><code>ResNet3ClassPredictor(model_path, num_classes=3, device=None, model_size=(256, 256))\n</code></pre> <p>A class for predicting the class of an image using a pre-trained ResNet50 model.</p> <p>The model is loaded from a checkpoint file.</p> <p>Methods:</p> <ul> <li> <code>predict</code>             \u2013              <p>Predict the class of an image.</p> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def __init__(self, model_path, num_classes=3, device=None, model_size=(256, 256)):\n    # Automatically detect device if not provided\n    self.device = (\n        device if device else (\"cuda\" if torch.cuda.is_available() else \"cpu\")\n    )\n\n    # Load the model\n    self.model = ResNet3ClassClassifier(num_classes=num_classes, pretrained=False)\n    # self.model.load_state_dict(torch.load(model_path, map_location=self.device))\n    self.model = ResNet3ClassClassifier.load_from_checkpoint(model_path)\n    self.model.to(self.device)\n    self.model.eval()\n\n    # Define the image transformation\n    self.transform = Compose(\n        [\n            Resize(model_size),  # Resize to (224, 224)\n            ToTensor(),  # Convert to PyTorch tensor\n            EnsureType(),\n            # ResNet normalization\n            Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n        ]\n    )\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassPredictor.predict","title":"predict","text":"<pre><code>predict(img)\n</code></pre> <p>Predict the class of an image.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The predicted class index.</p> </li> <li> <code>float</code>           \u2013            <p>The confidence of the prediction.</p> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def predict(self, img):\n    \"\"\"\n    Predict the class of an image.\n\n    Parameters\n    ----------\n    img : numpy.ndarray\n        The input image to classify.\n\n    Returns\n    -------\n    int\n        The predicted class index.\n    float\n        The confidence of the prediction.\n    \"\"\"\n    img = np.nan_to_num(img, 0)\n    img = grey2rgb(img)\n    # Ensure the input is a PIL Image\n    img = Image.fromarray(img)\n\n    # Apply the transformations\n    img = self.transform(img)\n\n    # Add batch dimension\n    img = img.unsqueeze(0).to(self.device)\n\n    # Forward pass\n    with torch.no_grad():\n        output = self.model(img)\n        probabilities = F.softmax(output, dim=1)\n        predicted_class = torch.argmax(probabilities, dim=1).item()\n        confidence = probabilities[0][predicted_class].item()\n\n    return predicted_class, confidence\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.ResNet3ClassPredictor.predict(img)","title":"<code>img</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to classify.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices","title":"SaveClassifiedSlices","text":"<pre><code>SaveClassifiedSlices(viewer)\n</code></pre> <p>               Bases: <code>QWidget</code></p> <pre><code>\n              flowchart TD\n              skeleplex.measurements.lumen_classifier.SaveClassifiedSlices[SaveClassifiedSlices]\n\n              \n\n              click skeleplex.measurements.lumen_classifier.SaveClassifiedSlices href \"\" \"skeleplex.measurements.lumen_classifier.SaveClassifiedSlices\"\n            </code></pre> <p>Widget to save classified slices in different folders.</p> <p>Specifically designed to classify sam segmentations from orthogonal branch sections into:  -Lumen  -Branch  -Bad The bad category is for all other labels that are not the lumen or branch.</p> <p>Load the images that you want to classify and the relevant segmentation in a napari viewer. The image layer should end with .h5_img and the segmentation layer with .h5_sam. The image and segmentation should be in the same folder.</p> <p>The Lumen should be labelled as 2, the Branch as 1.</p> <p>The save button bad_lumen will crop the image to the bounding box of the lumen, while the save button bad will crop the image to the bounding box of the all de- tected labels.</p> <p>Methods:</p> <ul> <li> <code>return_layer</code>             \u2013              <p>Return the image and label layer based on the active layer name.</p> </li> <li> <code>save_bad_lumen</code>             \u2013              <p>Save the bad lumen segmentation.</p> </li> <li> <code>save_bad_segmentation</code>             \u2013              <p>Save as bad segmentation.</p> </li> <li> <code>save_branch_segmentation</code>             \u2013              <p>Save as branch segmentation.</p> </li> <li> <code>save_lumen_segmentation</code>             \u2013              <p>Save as lumen segmentation.</p> </li> <li> <code>set_bad_path</code>             \u2013              <p>Set the path for bad save directory.</p> </li> <li> <code>set_branch_path</code>             \u2013              <p>Set the path for branch save directory.</p> </li> <li> <code>set_lumen_path</code>             \u2013              <p>Set the path for lumen save directory.</p> </li> </ul> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def __init__(self, viewer):\n    super().__init__()\n    self.viewer = viewer\n    self.setWindowTitle(\"Save Segmentation\")\n    self.layout = QVBoxLayout()\n    self.setLayout(self.layout)\n\n    # Initialize save paths\n    self.lumen_path = \"\"\n    self.branch_path = \"\"\n    self.bad_path = \"\"\n\n    # Path selectors + display\n    self._add_path_selector(\"Lumen\", self.set_lumen_path)\n    self._add_path_selector(\"Branch\", self.set_branch_path)\n    self._add_path_selector(\"Bad\", self.set_bad_path)\n\n    # Category save buttons\n    self._add_save_button(\"Save as Lumen\", self.save_lumen_segmentation)\n    self._add_save_button(\"Save as Branch\", self.save_branch_segmentation)\n    self._add_save_button(\"Save as Bad\", self.save_bad_segmentation)\n    self._add_save_button(\"Save as Bad Lumen\", self.save_bad_lumen)\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.return_layer","title":"return_layer","text":"<pre><code>return_layer(path)\n</code></pre> <p>Return the image and label layer based on the active layer name.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def return_layer(self, path):\n    \"\"\"Return the image and label layer based on the active layer name.\"\"\"\n    current_layer_name = self.viewer.layers.selection.active.name\n    name = current_layer_name[:-4]\n\n    if current_layer_name.endswith(\"img\"):\n        image_name = current_layer_name\n        label_name = name + \"_sam\"\n    elif current_layer_name.endswith(\"sam\"):\n        label_name = current_layer_name\n        image_name = name + \"_img\"\n    else:\n        raise ValueError(\"Active layer must end with 'img' or 'sam'\")\n\n    image = self.viewer.layers[image_name].data\n    label = self.viewer.layers[label_name].data\n    current_step = self.viewer.dims.current_step[0]\n\n    return (\n        image[current_step],\n        label[current_step],\n        name[:-3] + f\"_{current_step}.h5\",\n    )\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.save_bad_lumen","title":"save_bad_lumen","text":"<pre><code>save_bad_lumen()\n</code></pre> <p>Save the bad lumen segmentation.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def save_bad_lumen(self):\n    \"\"\"Save the bad lumen segmentation.\"\"\"\n    if not self.bad_path:\n        logger.info(\"Bad path not set!\")\n        return\n    logger.info(\"Saving as bad lumen...\")\n    image, label, name = self.return_layer(self.bad_path)\n    bad_label = label.copy()\n    bad_label[bad_label != 2] = 0\n    image_masked = image.copy()\n    image_masked[bad_label != 2] = 0\n\n    props = ski.measure.regionprops(ski.measure.label(bad_label))\n    if props:\n        minr, minc, maxr, maxc = props[0].bbox\n        image_masked = image_masked[minr:maxr, minc:maxc]\n        bad_label = bad_label[minr:maxr, minc:maxc]\n\n    with h5py.File(self.bad_path + name, \"w\") as f:\n        f.create_dataset(\"image\", data=image_masked)\n        f.create_dataset(\"label\", data=bad_label)\n\n    self._next_slice()\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.save_bad_segmentation","title":"save_bad_segmentation","text":"<pre><code>save_bad_segmentation()\n</code></pre> <p>Save as bad segmentation.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def save_bad_segmentation(self):\n    \"\"\"Save as bad segmentation.\"\"\"\n    if not self.bad_path:\n        logger.info(\"Bad path not set!\")\n        return\n    logger.info(\"Saving as bad segmentation...\")\n    image, label, name = self.return_layer(self.bad_path)\n    bad_label = (label != 0).astype(int)\n    image_masked = image * bad_label\n\n    props = ski.measure.regionprops(ski.measure.label(bad_label))\n    if props:\n        minr, minc, maxr, maxc = props[0].bbox\n        image_masked = image_masked[minr:maxr, minc:maxc]\n        bad_label = bad_label[minr:maxr, minc:maxc]\n\n    with h5py.File(self.bad_path + name, \"w\") as f:\n        f.create_dataset(\"image\", data=image_masked)\n        f.create_dataset(\"label\", data=bad_label)\n\n    self._next_slice()\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.save_branch_segmentation","title":"save_branch_segmentation","text":"<pre><code>save_branch_segmentation()\n</code></pre> <p>Save as branch segmentation.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def save_branch_segmentation(self):\n    \"\"\"Save as branch segmentation.\"\"\"\n    if not self.branch_path:\n        logger.info(\"Branch path not set!\")\n        return\n    logger.info(\"Saving as branch segmentation...\")\n    image, label, name = self.return_layer(self.branch_path)\n    branch_label = label.copy()\n    branch_label[branch_label != 1] = 0\n    image_masked = image.copy()\n    image_masked[branch_label == 0] = 0\n\n    props = ski.measure.regionprops(ski.measure.label(branch_label))\n    if props:\n        minr, minc, maxr, maxc = props[0].bbox\n        image_masked = image_masked[minr:maxr, minc:maxc]\n        branch_label = branch_label[minr:maxr, minc:maxc]\n\n    with h5py.File(self.branch_path + name, \"w\") as f:\n        f.create_dataset(\"image\", data=image_masked)\n        f.create_dataset(\"label\", data=branch_label)\n\n    self._next_slice()\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.save_lumen_segmentation","title":"save_lumen_segmentation","text":"<pre><code>save_lumen_segmentation()\n</code></pre> <p>Save as lumen segmentation.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def save_lumen_segmentation(self):\n    \"\"\"Save as lumen segmentation.\"\"\"\n    if not self.lumen_path:\n        logger.info(\"Lumen path not set!\")\n        return\n    logger.info(\"Saving as lumen segmentation...\")\n    image, label, name = self.return_layer(self.lumen_path)\n    lumen_label = label.copy()\n    lumen_label[lumen_label != 2] = 0\n    image_masked = image.copy()\n    image_masked[lumen_label != 2] = 0\n\n    props = ski.measure.regionprops(ski.measure.label(lumen_label))\n    if props:\n        minr, minc, maxr, maxc = props[0].bbox\n        image_masked = image_masked[minr:maxr, minc:maxc]\n        lumen_label = lumen_label[minr:maxr, minc:maxc]\n\n    with h5py.File(self.lumen_path + name, \"w\") as f:\n        f.create_dataset(\"image\", data=image_masked)\n        f.create_dataset(\"label\", data=lumen_label)\n\n    self._next_slice()\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.set_bad_path","title":"set_bad_path","text":"<pre><code>set_bad_path()\n</code></pre> <p>Set the path for bad save directory.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def set_bad_path(self):\n    \"\"\"Set the path for bad save directory.\"\"\"\n    path = QFileDialog.getExistingDirectory(self, \"Select Bad Save Directory\")\n    if path:\n        self.bad_path = path + \"/\"\n        self.bad_label.setText(f\"Bad/Bad Lumen Path: {path}\")\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.set_branch_path","title":"set_branch_path","text":"<pre><code>set_branch_path()\n</code></pre> <p>Set the path for branch save directory.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def set_branch_path(self):\n    \"\"\"Set the path for branch save directory.\"\"\"\n    path = QFileDialog.getExistingDirectory(self, \"Select Branch Save Directory\")\n    if path:\n        self.branch_path = path + \"/\"\n        self.branch_label.setText(f\"Branch Path: {path}\")\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.SaveClassifiedSlices.set_lumen_path","title":"set_lumen_path","text":"<pre><code>set_lumen_path()\n</code></pre> <p>Set the path for lumen save directory.</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def set_lumen_path(self):\n    \"\"\"Set the path for lumen save directory.\"\"\"\n    path = QFileDialog.getExistingDirectory(self, \"Select Lumen Save Directory\")\n    if path:\n        self.lumen_path = path + \"/\"\n        self.lumen_label.setText(f\"Lumen Path: {path}\")\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.add_class_based_on_folder_struct","title":"add_class_based_on_folder_struct","text":"<pre><code>add_class_based_on_folder_struct(lumen_path, branch_path, bad_path)\n</code></pre> <p>Add class labels to the h5 files based on their folder structure.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def add_class_based_on_folder_struct(lumen_path, branch_path, bad_path):\n    \"\"\"\n    Add class labels to the h5 files based on their folder structure.\n\n    Parameters\n    ----------\n    lumen_path : str\n        Path to the folder containing lumen files.\n    branch_path : str\n        Path to the folder containing branch files.\n    bad_path : str\n        Path to the folder containing bad files.\n\n    \"\"\"\n    # count number of files per class\n    class_count = np.array([0, 0, 0], dtype=\"int32\")\n    lumen_files = os.listdir(lumen_path)\n    for file in lumen_files:\n        with h5py.File(lumen_path + file, \"a\") as f:\n            if \"class_id\" in f:\n                del f[\"class_id\"]\n            f[\"class_id\"] = np.array([0], dtype=\"int8\")\n            class_count[0] += 1\n\n    branch_files = os.listdir(branch_path)\n    for file in branch_files:\n        with h5py.File(branch_path + file, \"a\") as f:\n            if \"class_id\" in f:\n                del f[\"class_id\"]\n            f[\"class_id\"] = np.array([1], dtype=\"int8\")\n            class_count[1] += 1\n    bad_files = os.listdir(bad_path)\n    for file in bad_files:\n        with h5py.File(bad_path + file, \"a\") as f:\n            if \"class_id\" in f:\n                del f[\"class_id\"]\n            f[\"class_id\"] = np.array([2], dtype=\"int8\")\n            class_count[2] += 1\n    logger.info(\"Number of files per class:\")\n    logger.info(class_count)\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.add_class_based_on_folder_struct(lumen_path)","title":"<code>lumen_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the folder containing lumen files.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.add_class_based_on_folder_struct(branch_path)","title":"<code>branch_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the folder containing branch files.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.add_class_based_on_folder_struct(bad_path)","title":"<code>bad_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to the folder containing bad files.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.split_and_copy_files","title":"split_and_copy_files","text":"<pre><code>split_and_copy_files(file_list, source_dir, train_dir, val_dir, val_split_ratio=0.2)\n</code></pre> <p>Creates training and validation files from a file list.</p> <p>The files are copied to the respective directories.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/lumen_classifier.py</code> <pre><code>def split_and_copy_files(\n    file_list, source_dir, train_dir, val_dir, val_split_ratio=0.2\n):\n    \"\"\"\n    Creates training and validation files from a file list.\n\n    The files are copied to the respective directories.\n\n    Parameters\n    ----------\n    file_list : list\n        List of files to be split.\n    source_dir : str\n        Directory containing the source files.\n    train_dir : str\n        Directory to copy training files to.\n    val_dir : str\n        Directory to copy validation files to.\n    val_split_ratio : float\n        Ratio of files to be used for validation.\n        Default is 0.2 (20% for validation).\n    \"\"\"\n    random.shuffle(file_list)\n    split_idx = int(len(file_list) * val_split_ratio)\n    val_files = file_list[:split_idx]\n    train_files = file_list[split_idx:]\n\n    # Copy validation files\n    for file in val_files:\n        shutil.copy(os.path.join(source_dir, file), os.path.join(val_dir, file))\n\n    # Copy training files\n    for file in train_files:\n        shutil.copy(os.path.join(source_dir, file), os.path.join(train_dir, file))\n</code></pre>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.split_and_copy_files(file_list)","title":"<code>file_list</code>","text":"(<code>list</code>)           \u2013            <p>List of files to be split.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.split_and_copy_files(source_dir)","title":"<code>source_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory containing the source files.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.split_and_copy_files(train_dir)","title":"<code>train_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory to copy training files to.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.split_and_copy_files(val_dir)","title":"<code>val_dir</code>","text":"(<code>str</code>)           \u2013            <p>Directory to copy validation files to.</p>"},{"location":"reference/skeleplex/measurements/lumen_classifier/#skeleplex.measurements.lumen_classifier.split_and_copy_files(val_split_ratio)","title":"<code>val_split_ratio</code>","text":"(<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>Ratio of files to be used for validation. Default is 0.2 (20% for validation).</p>"},{"location":"reference/skeleplex/measurements/utils/","title":"utils","text":""},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils","title":"skeleplex.measurements.utils","text":"<p>Functions:</p> <ul> <li> <code>deg2rad</code>             \u2013              <p>Convert degrees to radians.</p> </li> <li> <code>distance_to_surface</code>             \u2013              <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> </li> <li> <code>ensure_same_normal_direction</code>             \u2013              <p>Ensure that all normals have the same direction.</p> </li> <li> <code>extract_central_region</code>             \u2013              <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_branches</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_and_get_surface_normal_of_nodes</code>             \u2013              <p>Fits a surface to the central region of a point cloud and calculate normals.</p> </li> <li> <code>fit_surface_to_pointcloud_rbf_pca</code>             \u2013              <p>Fits an RBF surface to a pointcloud using PCA for rotation invariance.</p> </li> <li> <code>get_normal_of_closest_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> <li> <code>get_normal_of_closest_surface_point</code>             \u2013              <p>Computes the normal of the surface at the closest point to a set of points.</p> </li> <li> <code>get_normal_of_plane</code>             \u2013              <p>Get the normal vector of a plane defined by three points.</p> </li> <li> <code>graph_attributes_to_df</code>             \u2013              <p>Converts all edge attributes of a graph to a pandas dataframe.</p> </li> <li> <code>grey2rgb</code>             \u2013              <p>Convert a grayscale image to RGB by stacking the channels.</p> </li> <li> <code>rad2deg</code>             \u2013              <p>Convert radians to degrees.</p> </li> <li> <code>radius_from_area</code>             \u2013              <p>Calculate the radius from the area of a circle.</p> </li> <li> <code>rotation_matrix_from_vectors</code>             \u2013              <p>Compute the rotation matrix that rotates unit vector a onto unit vector b.</p> </li> <li> <code>unit_vector</code>             \u2013              <p>Returns the unit vector of the vector.</p> </li> </ul>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.deg2rad","title":"deg2rad","text":"<pre><code>deg2rad(deg)\n</code></pre> <p>Convert degrees to radians.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def deg2rad(deg):\n    \"\"\"Convert degrees to radians.\"\"\"\n    return deg * np.pi / 180\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface","title":"distance_to_surface","text":"<pre><code>distance_to_surface(vertices, faces, points)\n</code></pre> <p>Computes the distance of a set of points to a surface defined by vertices and faces.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>distances</code> (              <code>ndarray</code> )          \u2013            <p>An array of shape (n_points,) containing the distances of each point to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def distance_to_surface(vertices, faces, points):\n    \"\"\"\n    Computes the distance of a set of points to a surface defined by vertices and faces.\n\n    Parameters\n    ----------\n    vertices : np.ndarray\n        An array of shape (n_vertices, 3) containing the vertices of the surface.\n    faces : np.ndarray\n        An array of shape (n_faces, 3) containing the faces of the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    distances : np.ndarray\n        An array of shape (n_points,) containing the distances of each point\n        to the surface.\n    \"\"\"\n    mesh = tri.Trimesh(vertices, faces)\n    closest_point, distance, triangles = mesh.nearest.on_surface(points)\n    return closest_point, distance, triangles\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface(vertices)","title":"<code>vertices</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_vertices, 3) containing the vertices of the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface(faces)","title":"<code>faces</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_faces, 3) containing the faces of the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.distance_to_surface(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.ensure_same_normal_direction","title":"ensure_same_normal_direction","text":"<pre><code>ensure_same_normal_direction(normals: dict, reference_direction)\n</code></pre> <p>Ensure that all normals have the same direction.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def ensure_same_normal_direction(normals: dict, reference_direction):\n    \"\"\"Ensure that all normals have the same direction.\"\"\"\n    for key, normal in normals.items():\n        if np.sign(normal[0]) != reference_direction:\n            logger.info(f\"Reversing normal for edge {key}\")\n            normals[key] = -normal  # Reverse the direction of the normal\n    return normals\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.extract_central_region","title":"extract_central_region","text":"<pre><code>extract_central_region(points, percentile=50)\n</code></pre> <p>Extracts the central region of the point cloud using PCA and a distance threshold.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>central_points</code> (              <code>ndarray</code> )          \u2013            <p>The extracted central points.</p> </li> <li> <code>pca</code> (              <code>PCA</code> )          \u2013            <p>The PCA transformation object.</p> </li> <li> <code>mean</code> (              <code>ndarray</code> )          \u2013            <p>Mean of the original point cloud.</p> </li> <li> <code>components</code> (              <code>ndarray</code> )          \u2013            <p>The principal component axes.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def extract_central_region(points, percentile=50):\n    \"\"\"\n    Extracts the central region of the point cloud using PCA and a distance threshold.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array containing the 3D point cloud.\n    percentile : float\n        The percentage of points to keep (default 50% around the mean).\n\n    Returns\n    -------\n    central_points : np.ndarray\n        The extracted central points.\n    pca : PCA\n        The PCA transformation object.\n    mean : np.ndarray\n        Mean of the original point cloud.\n    components : np.ndarray\n        The principal component axes.\n    \"\"\"\n    # Center the points\n    mean = np.mean(points, axis=0)\n    centered_points = points - mean\n\n    # Apply PCA\n    pca = PCA(n_components=3)\n    pca.fit(centered_points)\n    components = pca.components_  # Principal axes\n\n    # Transform points into PCA space\n    aligned_points = centered_points @ components.T  # Manual projection\n\n    # Compute distances in PCA space (only in the XY plane)\n    distances = np.linalg.norm(aligned_points[:, :2], axis=1)\n    threshold = np.percentile(distances, percentile)\n\n    # Select only the central points\n    central_points = points[distances &lt; threshold]\n    return central_points, mean, components\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.extract_central_region(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array containing the 3D point cloud.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.extract_central_region(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>50</code> )           \u2013            <p>The percentage of points to keep (default 50% around the mean).</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches","title":"fit_surface_and_get_surface_normal_of_branches","text":"<pre><code>fit_surface_and_get_surface_normal_of_branches(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the branch midpoint.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_branches(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the\n    surface to the branch midpoint.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n         The graph containing the nodes.\n    lobe_name : str\n         The lobe to process.\n    smooth : float\n         RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n         A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n         A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n         The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    lobe_edge_ID_dict = {}\n\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n            lobe_edge_ID_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n        lobe_edge_ID_dict[lobe].append((u, v))\n\n    lobe_coordinates = np.array(lobe_node_dict[lobe_name])\n    lobe_edges = lobe_edge_ID_dict[lobe_name]\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_coordinates, smooth=smooth, percentile=100\n    )\n\n    mesh = tri.Trimesh(vertices, faces)\n\n    if not all(\"branch_midpoint\" in graph.edges[u, v] for u, v in graph.edges):\n        splines = nx.get_edge_attributes(graph, EDGE_SPLINE_KEY)\n        spline_midpoint_dict = {}\n        # get the midpoint of each spline\n        for edge, spline in splines.items():\n            spline_midpoint_dict[edge] = spline.eval(0.5, approx=True)\n    else:\n        logger.info(\"Using existing branch midpoints\")\n        spline_midpoint_dict = nx.get_edge_attributes(graph, \"branch_midpoint\")\n\n    lobe_midpoints = np.array([spline_midpoint_dict[key] for key in lobe_edges])\n\n    normal_dict, distance_dict = get_normal_of_closest_point(mesh, lobe_midpoints)\n\n    edge_normal_dict = {}\n    edge_distance_dict = {}\n\n    # Assign the normals and distances to the edges\n    for edge in lobe_edges:\n        edge_normal_dict[edge] = normal_dict[tuple(spline_midpoint_dict[edge])]\n        edge_distance_dict[edge] = distance_dict[tuple(spline_midpoint_dict[edge])]\n\n    return edge_normal_dict, edge_distance_dict, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_branches(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes","title":"fit_surface_and_get_surface_normal_of_nodes","text":"<pre><code>fit_surface_and_get_surface_normal_of_nodes(graph: DiGraph, lobe_name: str, smooth=1000)\n</code></pre> <p>Fits a surface to the central region of a point cloud and calculate normals.</p> <p>The normals is the surface normal of the closest point on the surface to the node.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normals</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its corresponding normal vector.</p> </li> <li> <code>distances</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each node to its distance to the surface.</p> </li> <li> <code>(vertices, faces) : tuple</code>           \u2013            <p>The vertices and faces of the fitted surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def fit_surface_and_get_surface_normal_of_nodes(\n    graph: nx.DiGraph, lobe_name: str, smooth=1000\n):\n    \"\"\"\n    Fits a surface to the central region of a point cloud and calculate normals.\n\n    The normals is the surface normal of the closest point on the surface to the node.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph containing the nodes.\n    lobe_name : str\n        The lobe to process.\n    smooth : float\n        RBF smoothing factor.\n\n    Returns\n    -------\n    normals : dict\n        A dictionary mapping each node to its corresponding normal vector.\n    distances : dict\n        A dictionary mapping each node to its distance to the surface.\n    (vertices, faces) : tuple\n        The vertices and faces of the fitted surface.\n    \"\"\"\n    # Extract the point cloud of the lobe\n    lobe_node_dict = {}\n    node_coords = nx.get_node_attributes(graph, NODE_COORDINATE_KEY)\n    for u, v, lobe in graph.edges(data=LOBE_NAME_KEY):\n        if lobe not in lobe_node_dict:\n            lobe_node_dict[lobe] = []\n        lobe_node_dict[lobe].extend([node_coords[u], node_coords[v]])\n\n    lobe_points = np.array(lobe_node_dict[lobe_name])\n    vertices, faces = fit_surface_to_pointcloud_rbf_pca(\n        lobe_points, smooth=smooth, percentile=100\n    )\n    mesh = tri.Trimesh(vertices, faces)\n    normals, distances = get_normal_of_closest_point(mesh, lobe_points)\n    return normals, distances, (vertices, faces)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph containing the nodes.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes(lobe_name)","title":"<code>lobe_name</code>","text":"(<code>str</code>)           \u2013            <p>The lobe to process.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_and_get_surface_normal_of_nodes(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>1000</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca","title":"fit_surface_to_pointcloud_rbf_pca","text":"<pre><code>fit_surface_to_pointcloud_rbf_pca(points: ndarray, smooth=0.2, percentile=100)\n</code></pre> <p>Fits an RBF surface to a pointcloud using PCA for rotation invariance.</p> <p>Can be fitted to a central region of the pointcloud.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>vertices, faces : np.ndarray</code>           \u2013            <p>Mesh vertices and faces.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def fit_surface_to_pointcloud_rbf_pca(points: np.ndarray, smooth=0.2, percentile=100):\n    \"\"\"Fits an RBF surface to a pointcloud using PCA for rotation invariance.\n\n    Can be fitted to a central region of the pointcloud.\n\n    Parameters\n    ----------\n    points : np.ndarray\n        (n_points, 3) array of 3D points.\n    smooth : float\n        RBF smoothing factor.\n    percentile : float\n        How much of the central region to retain (default 100%).\n\n    Returns\n    -------\n    vertices, faces : np.ndarray\n        Mesh vertices and faces.\n    \"\"\"\n    # Extract central region\n    central_points, mean, components = extract_central_region(points, percentile)\n\n    # Transform central points into PCA space\n    pca_space_points = (central_points - mean) @ components.T  # Manual projection\n\n    # Fit RBF surface on the central points in PCA space\n    x, y, z = pca_space_points[:, 0], pca_space_points[:, 1], pca_space_points[:, 2]\n    rbf = Rbf(x, y, z, function=\"multiquadric\", smooth=smooth)\n\n    # Generate a grid in PCA space\n    x_grid, y_grid = np.meshgrid(\n        np.linspace(np.min(x), np.max(x), 50), np.linspace(np.min(y), np.max(y), 50)\n    )\n    z_grid = rbf(x_grid, y_grid)\n\n    # Reconstruct the surface back into original space\n    grid_points_pca = np.vstack((x_grid.ravel(), y_grid.ravel(), z_grid.ravel())).T\n    original_grid_points = (\n        grid_points_pca @ components\n    ) + mean  # Correct transformation\n\n    # Build mesh\n    vertices = original_grid_points\n    tri = Delaunay(vertices[:, :2])\n    faces = tri.simplices\n\n    return vertices, faces\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_points, 3) array of 3D points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca(smooth)","title":"<code>smooth</code>","text":"(<code>float</code>, default:                   <code>0.2</code> )           \u2013            <p>RBF smoothing factor.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.fit_surface_to_pointcloud_rbf_pca(percentile)","title":"<code>percentile</code>","text":"(<code>float</code>, default:                   <code>100</code> )           \u2013            <p>How much of the central region to retain (default 100%).</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_point","title":"get_normal_of_closest_point","text":"<pre><code>get_normal_of_closest_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def get_normal_of_closest_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    if len(points.shape) == 1:\n        points = np.expand_dims(points, axis=0)\n\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = tri.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_surface_point","title":"get_normal_of_closest_surface_point","text":"<pre><code>get_normal_of_closest_surface_point(mesh: Trimesh, points: ndarray)\n</code></pre> <p>Computes the normal of the surface at the closest point to a set of points.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>normal_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its corresponding normal vector.</p> </li> <li> <code>distance_dict</code> (              <code>dict</code> )          \u2013            <p>A dictionary mapping each point to its distance to the surface.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def get_normal_of_closest_surface_point(mesh: trimesh.Trimesh, points: np.ndarray):\n    \"\"\"Computes the normal of the surface at the closest point to a set of points.\n\n    Parameters\n    ----------\n    mesh : trimesh.Trimesh\n        The mesh representing the surface.\n    points : np.ndarray\n        An array of shape (n_points, 3) containing the 3D coordinates of the points.\n\n    Returns\n    -------\n    normal_dict : dict\n        A dictionary mapping each point to its corresponding normal vector.\n    distance_dict : dict\n        A dictionary mapping each point to its distance to the surface.\n    \"\"\"\n    # Find the closest point on the surface\n    _, distance, closest_triangle = mesh.nearest.on_surface(points)\n    normals = trimesh.triangles.normals(mesh.triangles)[0]\n    normal_dict = {}\n    distance_dict = {}\n    for i in range(len(points)):\n        normal_dict[tuple(points[i])] = normals[closest_triangle[i]]\n        distance_dict[tuple(points[i])] = distance[i]\n\n    return normal_dict, distance_dict\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_surface_point(mesh)","title":"<code>mesh</code>","text":"(<code>Trimesh</code>)           \u2013            <p>The mesh representing the surface.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_closest_surface_point(points)","title":"<code>points</code>","text":"(<code>ndarray</code>)           \u2013            <p>An array of shape (n_points, 3) containing the 3D coordinates of the points.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane","title":"get_normal_of_plane","text":"<pre><code>get_normal_of_plane(p1: ndarray, p2: ndarray, p3: ndarray)\n</code></pre> <p>Get the normal vector of a plane defined by three points.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def get_normal_of_plane(p1: np.ndarray, p2: np.ndarray, p3: np.ndarray):\n    \"\"\"Get the normal vector of a plane defined by three points.\n\n    Parameters\n    ----------\n    p1 : np.ndarray\n        First point.\n    p2 : np.ndarray\n        Second point.\n    p3 : np.ndarray\n        Third point.\n\n    \"\"\"\n    v1 = p2 - p1\n    v2 = p3 - p1\n    cp = np.cross(v1, v2)\n    if all(cp == 0):\n        ValueError(\"The points are colinear\")\n    return cp\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane(p1)","title":"<code>p1</code>","text":"(<code>ndarray</code>)           \u2013            <p>First point.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane(p2)","title":"<code>p2</code>","text":"(<code>ndarray</code>)           \u2013            <p>Second point.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.get_normal_of_plane(p3)","title":"<code>p3</code>","text":"(<code>ndarray</code>)           \u2013            <p>Third point.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.graph_attributes_to_df","title":"graph_attributes_to_df","text":"<pre><code>graph_attributes_to_df(graph: Graph)\n</code></pre> <p>Converts all edge attributes of a graph to a pandas dataframe.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>attr_df</code> (              <code>DataFrame</code> )          \u2013            <p>A pandas dataframe with all edge attributes</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def graph_attributes_to_df(graph: nx.Graph):\n    \"\"\"Converts all edge attributes of a graph to a pandas dataframe.\n\n    Parameters\n    ----------\n    graph : nx.DiGraph\n        The graph to convert\n\n    Returns\n    -------\n    attr_df : pd.DataFrame\n        A pandas dataframe with all edge attributes\n\n    \"\"\"\n    attr_dict = {}\n    for u, v, attr in graph.edges(data=True):\n        attr_dict[(u, v)] = attr\n\n    attr_df = pd.DataFrame.from_dict(attr_dict, orient=\"index\").reset_index(drop=True)\n\n    return attr_df\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.graph_attributes_to_df(graph)","title":"<code>graph</code>","text":"(<code>DiGraph</code>)           \u2013            <p>The graph to convert</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.grey2rgb","title":"grey2rgb","text":"<pre><code>grey2rgb(image)\n</code></pre> <p>Convert a grayscale image to RGB by stacking the channels.</p> <p>Parameters:</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def grey2rgb(image):\n    \"\"\"Convert a grayscale image to RGB by stacking the channels.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        A 2D numpy array representing the grayscale image.\n    \"\"\"\n    image = np.stack([image] * 3, axis=-1)\n    image = (image - image.min()) / (image.max() - image.min()) * 255\n    return image.astype(np.uint8)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.grey2rgb(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>A 2D numpy array representing the grayscale image.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rad2deg","title":"rad2deg","text":"<pre><code>rad2deg(rad)\n</code></pre> <p>Convert radians to degrees.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def rad2deg(rad):\n    \"\"\"Convert radians to degrees.\"\"\"\n    return rad * 180 / np.pi\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.radius_from_area","title":"radius_from_area","text":"<pre><code>radius_from_area(area)\n</code></pre> <p>Calculate the radius from the area of a circle.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>radius</code> (              <code>float</code> )          \u2013            <p>The radius of the circle.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def radius_from_area(area):\n    \"\"\"Calculate the radius from the area of a circle.\n\n    Parameters\n    ----------\n    area : float\n        The area of the circle.\n\n    Returns\n    -------\n    radius : float\n        The radius of the circle.\n    \"\"\"\n    return np.sqrt(area / np.pi)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.radius_from_area(area)","title":"<code>area</code>","text":"(<code>float</code>)           \u2013            <p>The area of the circle.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rotation_matrix_from_vectors","title":"rotation_matrix_from_vectors","text":"<pre><code>rotation_matrix_from_vectors(a: ndarray, b: ndarray)\n</code></pre> <p>Compute the rotation matrix that rotates unit vector a onto unit vector b.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>The rotation matrix.</p> </li> </ul> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def rotation_matrix_from_vectors(a: np.ndarray, b: np.ndarray):\n    \"\"\"Compute the rotation matrix that rotates unit vector a onto unit vector b.\n\n    Parameters\n    ----------\n    a : numpy.ndarray\n        The initial unit vector.\n    b : numpy.ndarray\n        The target unit vector.\n\n    Returns\n    -------\n    numpy.ndarray\n        The rotation matrix.\n    \"\"\"\n    # Compute the cross product and its magnitude\n    v = np.cross(a, b)\n    s = np.linalg.norm(v)\n\n    # Compute the dot product\n    c = np.dot(a, b)\n\n    # Skew-symmetric cross-product matrix\n    v_cross = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])\n\n    # Rotation matrix\n    if s != 0:\n        rm = np.eye(3) + v_cross + np.dot(v_cross, v_cross) * ((1 - c) / (s**2))\n    else:\n        rm = np.eye(3)\n\n    return R.from_matrix(rm)\n</code></pre>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rotation_matrix_from_vectors(a)","title":"<code>a</code>","text":"(<code>ndarray</code>)           \u2013            <p>The initial unit vector.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.rotation_matrix_from_vectors(b)","title":"<code>b</code>","text":"(<code>ndarray</code>)           \u2013            <p>The target unit vector.</p>"},{"location":"reference/skeleplex/measurements/utils/#skeleplex.measurements.utils.unit_vector","title":"unit_vector","text":"<pre><code>unit_vector(vector)\n</code></pre> <p>Returns the unit vector of the vector.</p> Source code in <code>skeleplex/measurements/utils.py</code> <pre><code>def unit_vector(vector):\n    \"\"\"Returns the unit vector of the vector.\"\"\"\n    return np.squeeze(np.asarray(vector / np.linalg.norm(vector)))\n</code></pre>"},{"location":"reference/skeleplex/skeleton/","title":"skeleton","text":""},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton","title":"skeleplex.skeleton","text":"<p>Tools to create a skeleton image of a structure.</p> <p>Modules:</p> <ul> <li> <code>distance_field</code>           \u2013            <p>Functions for computing normalized distance transform.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_skeletonization_model</code>             \u2013              <p>Get a pretrained model from the SkelePlex repository.</p> </li> <li> <code>label_chunks_parallel</code>             \u2013              <p>Label connected components in a large zarr image using parallel processing.</p> </li> <li> <code>merge_touching_labels</code>             \u2013              <p>Merge touching labels across chunk boundaries.</p> </li> <li> <code>relabel_parallel</code>             \u2013              <p>Relabel a zarr array in parallel by applying a label mapping to chunks.</p> </li> <li> <code>segment</code>             \u2013              <p>Segment the structures to be skeletonized.</p> </li> <li> <code>skeletonize</code>             \u2013              <p>Skeletonize a normalized distance field image.</p> </li> <li> <code>upscale_skeleton</code>             \u2013              <p>Upscale a 3D skeleton image while maintaining 1-voxel width.</p> </li> <li> <code>upscale_skeleton_parallel</code>             \u2013              <p>Upscale a skeleton image in parallel chunks across multiple processes.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.get_skeletonization_model","title":"get_skeletonization_model","text":"<pre><code>get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet\n</code></pre> <p>Get a pretrained model from the SkelePlex repository.</p> <p>Returns:</p> <ul> <li> <code>MultiscaleSkeletonizationNet</code>           \u2013            <p>The pretrained skeletonization model.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_utils.py</code> <pre><code>def get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet:\n    \"\"\"Get a pretrained model from the SkelePlex repository.\n\n    Returns\n    -------\n    MultiscaleSkeletonizationNet\n        The pretrained skeletonization model.\n    \"\"\"\n    # download the weights\n    file_path = SKELETONIZATION_MODEL_REGISTRY.fetch(\"skel-best.ckpt\")\n\n    return MultiscaleSkeletonizationNet.load_from_checkpoint(file_path)\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel","title":"label_chunks_parallel","text":"<pre><code>label_chunks_parallel(input_path: str, output_path: str, chunk_shape: tuple[int, ...], n_processes: int = 4, pool_type: Literal['spawn', 'fork', 'forkserver', 'thread'] = 'fork', backend: Literal['cpu', 'cupy'] = 'cpu') -&gt; int\n</code></pre> <p>Label connected components in a large zarr image using parallel processing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Total number of unique labels assigned</p> </li> </ul> Notes <ul> <li>Input zarr must already exist</li> <li>Output zarr will be created with same shape/dtype as input if it doesn't exist</li> <li>Components spanning chunk boundaries will receive different labels</li> </ul> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def label_chunks_parallel(\n    input_path: str,\n    output_path: str,\n    chunk_shape: tuple[int, ...],\n    n_processes: int = 4,\n    pool_type: Literal[\"spawn\", \"fork\", \"forkserver\", \"thread\"] = \"fork\",\n    backend: Literal[\"cpu\", \"cupy\"] = \"cpu\",\n) -&gt; int:\n    \"\"\"\n    Label connected components in a large zarr image using parallel processing.\n\n    Parameters\n    ----------\n    input_path : str\n        Path to input zarr array\n    output_path : str\n        Path to output zarr array (will be created if doesn't exist)\n    chunk_shape : tuple of int\n        Shape of chunks to process in parallel. This will be the chunk shape\n        of the output array.\n    n_processes : int, default=4\n        Number of parallel processes/threads\n    pool_type : {'spawn', 'fork', 'forkserver', 'thread'}, default='spawn'\n        Type of multiprocessing context to use.\n        - 'spawn': Start fresh Python process (safest, works on all platforms)\n        - 'fork': Copy parent process (faster but can have issues with threads)\n        - 'forkserver': Hybrid approach (Unix only)\n        - 'thread': Use threading instead of multiprocessing (good for I/O bound)\n    backend : {'cpu', 'cupy'}, default='cpu'\n        Backend to use for labeling. 'cpu' uses CPU-based labeling,\n        'cupy' uses GPU-based labeling with CuPy. Default is 'cpu'.\n\n    Returns\n    -------\n    int\n        Total number of unique labels assigned\n\n    Notes\n    -----\n    - Input zarr must already exist\n    - Output zarr will be created with same shape/dtype as input if it doesn't exist\n    - Components spanning chunk boundaries will receive different labels\n    \"\"\"\n    # Open input zarr to get metadata\n    input_zarr = zarr.open(input_path, mode=\"r\")\n    array_shape = input_zarr.shape\n\n    # Create the output zarr\n    _ = zarr.create_array(\n        output_path, shape=array_shape, chunks=chunk_shape, dtype=np.uint64\n    )\n\n    # Create list of chunk slices\n    chunk_slices_list = create_chunk_slices(array_shape, chunk_shape)\n\n    print(\n        f\"Processing {len(chunk_slices_list)} chunks using {n_processes} \"\n        f\"{pool_type} workers\"\n    )\n\n    # Process chunks in parallel\n    if pool_type == \"thread\":\n        from multiprocessing.pool import ThreadPool\n\n        offset_counter = Value(\"i\", 0)\n        counter_lock = Lock()\n        pool = ThreadPool(\n            n_processes,\n            initializer=_init_worker,\n            initargs=(offset_counter, counter_lock),\n        )\n    else:\n        ctx = get_context(pool_type)\n        offset_counter = ctx.Value(\"i\", 0)\n        counter_lock = ctx.Lock()\n        pool = ctx.Pool(\n            n_processes,\n            initializer=_init_worker,\n            initargs=(offset_counter, counter_lock),\n        )\n\n    # Create the processing function\n    if backend == \"cpu\":\n        process_func = partial(\n            _label_chunk_with_offset, input_path=input_path, output_path=output_path\n        )\n    elif backend == \"cupy\":\n        process_func = partial(\n            _label_chunk_with_offset_gpu, input_path=input_path, output_path=output_path\n        )\n    else:\n        raise ValueError(f\"Unsupported backend: {backend}\")\n\n    try:\n        _ = pool.map(process_func, chunk_slices_list)\n    finally:\n        pool.close()\n        pool.join()\n\n    total_labels = offset_counter.value\n\n    return total_labels\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel(input_path)","title":"<code>input_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel(output_path)","title":"<code>output_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array (will be created if doesn't exist)</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple of int</code>)           \u2013            <p>Shape of chunks to process in parallel. This will be the chunk shape of the output array.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of parallel processes/threads</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork, forkserver, thread)</code>, default:                   <code>'spawn'</code> )           \u2013            <p>Type of multiprocessing context to use. - 'spawn': Start fresh Python process (safest, works on all platforms) - 'fork': Copy parent process (faster but can have issues with threads) - 'forkserver': Hybrid approach (Unix only) - 'thread': Use threading instead of multiprocessing (good for I/O bound)</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.label_chunks_parallel(backend)","title":"<code>backend</code>","text":"(<code>(cpu, cupy)</code>, default:                   <code>'cpu'</code> )           \u2013            <p>Backend to use for labeling. 'cpu' uses CPU-based labeling, 'cupy' uses GPU-based labeling with CuPy. Default is 'cpu'.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels","title":"merge_touching_labels","text":"<pre><code>merge_touching_labels(label_image_path: str, output_image_path: str, chunk_shape: tuple[int, int, int], max_label_value: int, n_processes: int, pool_type: Literal['spawn', 'fork', 'forkserver', 'thread'], backend: Literal['cpu', 'cupy'] = 'cpu') -&gt; None\n</code></pre> <p>Merge touching labels across chunk boundaries.</p> <p>This function finds labels that touch at chunk boundaries, computes connected components, and relabels all labels in each connected component to the maximum label value in that component.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def merge_touching_labels(\n    label_image_path: str,\n    output_image_path: str,\n    chunk_shape: tuple[int, int, int],\n    max_label_value: int,\n    n_processes: int,\n    pool_type: Literal[\"spawn\", \"fork\", \"forkserver\", \"thread\"],\n    backend: Literal[\"cpu\", \"cupy\"] = \"cpu\",\n) -&gt; None:\n    \"\"\"\n    Merge touching labels across chunk boundaries.\n\n    This function finds labels that touch at chunk boundaries, computes connected\n    components, and relabels all labels in each connected component to the maximum\n    label value in that component.\n\n    Parameters\n    ----------\n    label_image_path : str\n        Path to input zarr array.\n    output_image_path : str\n        Path to output zarr array (will be created if doesn't exist).\n    chunk_shape : tuple[int, int, int]\n        Shape of chunks to process in parallel.\n    max_label_value : int\n        Maximum label value in the entire image.\n    n_processes : int\n        Number of parallel processes/threads.\n    pool_type : {'spawn', 'fork', 'forkserver', 'thread'}\n        Type of multiprocessing context to use.\n    backend : {'cpu', 'cupy'}, default='cpu'\n        Backend to use for finding touching labels. 'cpu' uses CPU-based.\n        'cupy' uses GPU-based with CuPy. Default is 'cpu'.\n    \"\"\"\n    # Open input zarr to get array shape\n    input_zarr = zarr.open(label_image_path, mode=\"r\")\n    array_shape = input_zarr.shape\n\n    print(f\"Merging touching labels in array with shape {array_shape}\")\n\n    # Get boundary slices\n    boundaries = get_boundary_slices(array_shape, chunk_shape)\n\n    print(f\"Found {len(boundaries)} chunk boundaries\")\n\n    # Handle case with no boundaries (single chunk or small array)\n    if len(boundaries) == 0:\n        print(\"No chunk boundaries found. Copying input to output.\")\n        _copy_zarr_array(\n            label_image_path, output_image_path, chunk_shape, n_processes, pool_type\n        )\n        return\n\n    # Find touching labels at all boundaries in parallel\n    print(f\"Finding touching labels using {n_processes} {pool_type} workers\")\n\n    if pool_type == \"thread\":\n        pool = ThreadPool(n_processes)\n    else:\n        ctx = get_context(pool_type)\n        pool = ctx.Pool(n_processes)\n\n    # Create processing function for finding touching labels\n    if backend == \"cpu\":\n        process_func = partial(_find_touching_labels, label_image_path=label_image_path)\n    elif backend == \"cupy\":\n        process_func = partial(\n            _find_touching_labels_gpu, label_image_path=label_image_path\n        )\n    else:\n        raise ValueError(f\"Unsupported backend: {backend}\")\n\n    try:\n        results = pool.map(process_func, boundaries)\n    finally:\n        pool.close()\n        pool.join()\n\n    # Combine all touching pairs\n    all_touching_pairs = [arr for arr in results if len(arr) &gt; 0]\n\n    if len(all_touching_pairs) == 0:\n        print(\"No touching labels found. Copying input to output.\")\n        _copy_zarr_array(\n            label_image_path, output_image_path, chunk_shape, n_processes, pool_type\n        )\n        return\n\n    # Stack and remove duplicates\n    touching_pairs = np.vstack(all_touching_pairs)\n    touching_pairs = np.unique(touching_pairs, axis=0)\n\n    print(f\"Found {len(touching_pairs)} unique touching label pairs\")\n\n    # Create label mapping based on connected components\n    label_mapping = _make_label_mapping(touching_pairs, max_label_value)\n\n    print(f\"Created mapping for {len(label_mapping)} labels\")\n\n    if len(label_mapping) == 0:\n        print(\"No labels need remapping. Copying input to output.\")\n        _copy_zarr_array(\n            label_image_path, output_image_path, chunk_shape, n_processes, pool_type\n        )\n        return\n\n    # Apply relabeling in parallel\n    print(\"Applying relabeling to all chunks\")\n    relabel_parallel(\n        label_image_path=label_image_path,\n        output_array_path=output_image_path,\n        chunk_shape=chunk_shape,\n        label_mapping=label_mapping,\n        n_processes=n_processes,\n        pool_type=pool_type,\n    )\n\n    print(\"Merging complete\")\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(label_image_path)","title":"<code>label_image_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(output_image_path)","title":"<code>output_image_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array (will be created if doesn't exist).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of chunks to process in parallel.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(max_label_value)","title":"<code>max_label_value</code>","text":"(<code>int</code>)           \u2013            <p>Maximum label value in the entire image.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>)           \u2013            <p>Number of parallel processes/threads.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork, forkserver, thread)</code>, default:                   <code>'spawn'</code> )           \u2013            <p>Type of multiprocessing context to use.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.merge_touching_labels(backend)","title":"<code>backend</code>","text":"(<code>(cpu, cupy)</code>, default:                   <code>'cpu'</code> )           \u2013            <p>Backend to use for finding touching labels. 'cpu' uses CPU-based. 'cupy' uses GPU-based with CuPy. Default is 'cpu'.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel","title":"relabel_parallel","text":"<pre><code>relabel_parallel(label_image_path: str, output_array_path: str, chunk_shape: tuple[int, int, int], label_mapping: dict[int, int], n_processes: int, pool_type: Literal['spawn', 'fork', 'forkserver', 'thread']) -&gt; None\n</code></pre> <p>Relabel a zarr array in parallel by applying a label mapping to chunks.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def relabel_parallel(\n    label_image_path: str,\n    output_array_path: str,\n    chunk_shape: tuple[int, int, int],\n    label_mapping: dict[int, int],\n    n_processes: int,\n    pool_type: Literal[\"spawn\", \"fork\", \"forkserver\", \"thread\"],\n) -&gt; None:\n    \"\"\"\n    Relabel a zarr array in parallel by applying a label mapping to chunks.\n\n    Parameters\n    ----------\n    label_image_path : str\n        Path to input zarr array.\n    output_array_path : str\n        Path to output zarr array (will be created if doesn't exist).\n    chunk_shape : tuple[int, int, int]\n        Shape of chunks to process in parallel.\n    label_mapping : dict[int, int]\n        Mapping from original labels to new labels.\n    n_processes : int\n        Number of parallel processes/threads.\n    pool_type : {'spawn', 'fork', 'forkserver', 'thread'}\n        Type of multiprocessing context to use.\n    \"\"\"\n    # Open input zarr to get metadata\n    input_zarr = zarr.open(label_image_path, mode=\"r\")\n    array_shape = input_zarr.shape\n    dtype = input_zarr.dtype\n\n    # Create the output zarr\n    _ = zarr.create_array(\n        output_array_path, shape=array_shape, chunks=chunk_shape, dtype=dtype\n    )\n\n    # Create list of chunk slices\n    chunk_slices_list = create_chunk_slices(array_shape, chunk_shape)\n\n    print(\n        f\"Processing {len(chunk_slices_list)} chunks using {n_processes} \"\n        f\"{pool_type} workers\"\n    )\n\n    # Process chunks in parallel\n    if pool_type == \"thread\":\n        pool = ThreadPool(n_processes)\n    else:\n        ctx = get_context(pool_type)\n        pool = ctx.Pool(n_processes)\n\n    # Create the processing function\n    process_func = partial(\n        _relabel_chunk,\n        input_path=label_image_path,\n        output_path=output_array_path,\n        label_mapping=label_mapping,\n    )\n\n    try:\n        pool.map(process_func, chunk_slices_list)\n    finally:\n        pool.close()\n        pool.join()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel(label_image_path)","title":"<code>label_image_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel(output_array_path)","title":"<code>output_array_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array (will be created if doesn't exist).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of chunks to process in parallel.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel(label_mapping)","title":"<code>label_mapping</code>","text":"(<code>dict[int, int]</code>)           \u2013            <p>Mapping from original labels to new labels.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>)           \u2013            <p>Number of parallel processes/threads.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.relabel_parallel(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork, forkserver, thread)</code>, default:                   <code>'spawn'</code> )           \u2013            <p>Type of multiprocessing context to use.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment","title":"segment","text":"<pre><code>segment(image: ndarray, model: Literal['pretrained'] | MultiscaleSemanticSegmentationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Segment the structures to be skeletonized.</p> <p>In the case of lungs, this would be used to segment the airways.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_segment.py</code> <pre><code>def segment(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Segment the structures to be skeletonized.\n\n    In the case of lungs, this would be used to segment the airways.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        raise NotImplementedError(\"pretrained segmentation models not implemented.\")\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.segment(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize","title":"skeletonize","text":"<pre><code>skeletonize(image: ndarray, model: Literal['pretrained'] | MultiscaleSkeletonizationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Skeletonize a normalized distance field image.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def skeletonize(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Skeletonize a normalized distance field image.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        model = get_skeletonization_model()\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.skeletonize(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton","title":"upscale_skeleton","text":"<pre><code>upscale_skeleton(skeleton: ndarray, scale_factors: tuple[int, int, int]) -&gt; ndarray\n</code></pre> <p>Upscale a 3D skeleton image while maintaining 1-voxel width.</p> <p>This function upscales a skeleton by scaling the coordinates of skeleton voxels and drawing lines between voxels that were originally connected.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>upscaled_skeleton</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array of the upscaled skeleton with shape (skeleton.shape[0] * scale_factors[0],  skeleton.shape[1] * scale_factors[1],  skeleton.shape[2] * scale_factors[2]).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If skeleton is not 3D, if scale_factors are not integers, or if scale_factors are not positive.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_upscale.py</code> <pre><code>def upscale_skeleton(\n    skeleton: np.ndarray,\n    scale_factors: tuple[int, int, int],\n) -&gt; np.ndarray:\n    \"\"\"Upscale a 3D skeleton image while maintaining 1-voxel width.\n\n    This function upscales a skeleton by scaling the coordinates of skeleton\n    voxels and drawing lines between voxels that were originally connected.\n\n    Parameters\n    ----------\n    skeleton : np.ndarray\n        3D boolean array representing the skeleton, where True indicates\n        skeleton voxels. Must be 3D.\n    scale_factors : tuple[int, int, int]\n        Integer scaling factors for each dimension (z, y, x). Must be positive\n        integers.\n\n    Returns\n    -------\n    upscaled_skeleton : np.ndarray\n        Boolean array of the upscaled skeleton with shape\n        (skeleton.shape[0] * scale_factors[0],\n         skeleton.shape[1] * scale_factors[1],\n         skeleton.shape[2] * scale_factors[2]).\n\n    Raises\n    ------\n    ValueError\n        If skeleton is not 3D, if scale_factors are not integers,\n        or if scale_factors are not positive.\n    \"\"\"\n    # Validate inputs\n    if skeleton.ndim != 3:\n        raise ValueError(f\"Skeleton must be 3D, got {skeleton.ndim}D\")\n\n    if len(scale_factors) != 3:\n        raise ValueError(f\"scale_factors must have length 3, got {len(scale_factors)}\")\n\n    # Check that scale factors are integers\n    if not all(isinstance(s, int | np.integer) for s in scale_factors):\n        raise ValueError(f\"scale_factors must be integers, got {scale_factors}\")\n\n    # Check that scale factors are positive\n    if not all(s &gt; 0 for s in scale_factors):\n        raise ValueError(\n            f\"scale_factors must be positive integers, got {scale_factors}\"\n        )\n\n    # Calculate upscaled shape\n    upscaled_shape = tuple(skeleton.shape[i] * scale_factors[i] for i in range(3))\n\n    # Create output array\n    upscaled_skeleton = np.zeros(upscaled_shape, dtype=bool)\n\n    # Get the connectivity graph of the original skeleton\n    # Use connectivity=3 for 26-connectivity (includes diagonals)\n    edges, nodes = pixel_graph(skeleton, connectivity=3)\n\n    if len(nodes) == 0:\n        # Empty skeleton, return empty upscaled skeleton\n        return upscaled_skeleton\n\n    # Convert the raveled node indices back to coordinates in the original scale\n    node_coordinates = np.array(np.unravel_index(nodes, skeleton.shape)).T\n\n    # Scale the coordinates and clip to array boundaries\n    scaled_node_coords = np.round(node_coordinates * np.array(scale_factors)).astype(\n        int\n    )\n\n    # Clip to ensure coordinates are within bounds\n    for i in range(3):\n        scaled_node_coords[:, i] = np.clip(\n            scaled_node_coords[:, i], 0, upscaled_shape[i] - 1\n        )\n\n    # Set the scaled coordinates to True\n    upscaled_skeleton[\n        scaled_node_coords[:, 0],\n        scaled_node_coords[:, 1],\n        scaled_node_coords[:, 2],\n    ] = True\n\n    # Convert edges to COO format arrays for iteration\n    # edges is a sparse matrix where\n    # entry (i,j) means nodes[i] and nodes[j] are connected\n    edge_indices = np.array(edges.nonzero()).T\n\n    # Draw lines between connected voxels in the upscaled image\n    for i in range(edge_indices.shape[0]):\n        # Get the indices into the nodes array\n        idx1 = edge_indices[i, 0]\n        idx2 = edge_indices[i, 1]\n\n        # Get the scaled coordinates of the two connected voxels\n        coord1 = scaled_node_coords[idx1]\n        coord2 = scaled_node_coords[idx2]\n\n        # Draw a line between them\n        # line_nd returns indices for each dimension\n        line_indices = line_nd(coord1, coord2, endpoint=True)\n\n        # Set all voxels along the line to True\n        upscaled_skeleton[line_indices] = True\n\n    return upscaled_skeleton\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton(skeleton)","title":"<code>skeleton</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D boolean array representing the skeleton, where True indicates skeleton voxels. Must be 3D.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton(scale_factors)","title":"<code>scale_factors</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Integer scaling factors for each dimension (z, y, x). Must be positive integers.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel","title":"upscale_skeleton_parallel","text":"<pre><code>upscale_skeleton_parallel(input_path: str, output_path: str, scale_factors: tuple[int, int, int], n_processing_chunks: tuple[int, int, int], border_size: tuple[int, int, int], n_processes: int, pool_type: Literal['spawn', 'fork']) -&gt; None\n</code></pre> <p>Upscale a skeleton image in parallel chunks across multiple processes.</p> <p>This function processes a skeleton zarr image in parallel chunks across multiple CPU processes, applying skeleton upscaling to each chunk. The border around each chunk ensures skeleton connectivity that spans chunk boundaries is properly preserved during upscaling.</p> <p>Processing chunks are defined as multiples of the zarr file chunks to ensure chunk boundaries align for safe parallel writing. The output zarr uses the same chunk structure as the input (before scaling).</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If processing chunks don't align with zarr chunks, if border size is too large, or if scale factors are invalid.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_chunked_upscale.py</code> <pre><code>def upscale_skeleton_parallel(\n    input_path: str,\n    output_path: str,\n    scale_factors: tuple[int, int, int],\n    n_processing_chunks: tuple[int, int, int],\n    border_size: tuple[int, int, int],\n    n_processes: int,\n    pool_type: Literal[\"spawn\", \"fork\"],\n) -&gt; None:\n    \"\"\"Upscale a skeleton image in parallel chunks across multiple processes.\n\n    This function processes a skeleton zarr image in parallel chunks across\n    multiple CPU processes, applying skeleton upscaling to each chunk. The\n    border around each chunk ensures skeleton connectivity that spans chunk\n    boundaries is properly preserved during upscaling.\n\n    Processing chunks are defined as multiples of the zarr file chunks to\n    ensure chunk boundaries align for safe parallel writing. The output zarr\n    uses the same chunk structure as the input (before scaling).\n\n    Parameters\n    ----------\n    input_path : str\n        Path to input zarr array (binary skeleton image).\n    output_path : str\n        Path to output zarr array for upscaled skeleton (will be created).\n    scale_factors : tuple[int, int, int]\n        Integer scaling factors for each dimension (z, y, x). Must be positive\n        integers.\n    n_processing_chunks : tuple[int, int, int]\n        Number of zarr file chunks to process together along each axis (z, y, x).\n        Processing chunk size = zarr_chunk_size * n_processing_chunks.\n        Must result in processing chunks that are multiples of zarr chunks.\n    border_size : tuple[int, int, int]\n        Size of border to add around each chunk in voxels (z, y, x) in input\n        space. Should be large enough to capture skeleton connectivity that\n        might span chunk boundaries. Used to prevent incomplete upscaling at\n        chunk edges but not written to output.\n    n_processes : int\n        Number of parallel processes to use.\n    pool_type : {\"spawn\", \"fork\"}\n        Type of multiprocessing context to use.\n        - \"spawn\": Start fresh Python process (safest, works on all platforms)\n        - \"fork\": Copy parent process (faster but can have issues with threads)\n\n    Raises\n    ------\n    ValueError\n        If processing chunks don't align with zarr chunks, if border size is\n        too large, or if scale factors are invalid.\n    \"\"\"\n    # Open input zarr to get metadata\n    input_zarr = zarr.open(input_path, mode=\"r\")\n    input_shape = input_zarr.shape\n    zarr_chunks = input_zarr.chunks\n    dtype = input_zarr.dtype\n\n    # Calculate processing chunk size (in input space)\n    processing_chunk_size = tuple(\n        zarr_chunks[i] * n_processing_chunks[i] for i in range(3)\n    )\n\n    # Validate that processing chunks align with zarr chunks\n    for i in range(3):\n        if processing_chunk_size[i] % zarr_chunks[i] != 0:\n            raise ValueError(\n                f\"Processing chunk size {processing_chunk_size[i]} must be a \"\n                f\"multiple of zarr chunk size {zarr_chunks[i]} along axis {i}\"\n            )\n\n    # Validate border size is smaller than processing chunk size\n    for i in range(3):\n        if border_size[i] &gt;= processing_chunk_size[i]:\n            raise ValueError(\n                f\"Border size {border_size[i]} must be smaller than processing \"\n                f\"chunk size {processing_chunk_size[i]} along axis {i}\"\n            )\n\n    # Calculate output shape\n    output_shape = tuple(input_shape[i] * scale_factors[i] for i in range(3))\n\n    # Create output zarr array (same chunk structure as input)\n    _ = zarr.open(\n        output_path,\n        mode=\"w\",\n        shape=output_shape,\n        chunks=zarr_chunks,  # Same as input chunks\n        dtype=dtype,\n    )\n\n    # Create list of chunk slices (in input space)\n    chunk_slices_list = create_chunk_slices(input_shape, processing_chunk_size)\n\n    print(\n        f\"Processing {len(chunk_slices_list)} chunks of size \"\n        f\"{processing_chunk_size} using {n_processes} {pool_type} workers\"\n    )\n\n    # Create multiprocessing pool\n    ctx = get_context(pool_type)\n    pool = ctx.Pool(n_processes)\n\n    # Create the processing function with fixed arguments\n    process_func = partial(\n        _upscale_skeleton_chunk,\n        input_path=input_path,\n        output_path=output_path,\n        border_size=border_size,\n        scale_factors=scale_factors,\n        input_array_shape=input_shape,\n    )\n\n    try:\n        # Process all chunks in parallel\n        pool.map(process_func, chunk_slices_list)\n    finally:\n        # Cleanup pool\n        pool.close()\n        pool.join()\n\n    print(\"Skeleton upscaling complete\")\n</code></pre>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(input_path)","title":"<code>input_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array (binary skeleton image).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(output_path)","title":"<code>output_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array for upscaled skeleton (will be created).</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(scale_factors)","title":"<code>scale_factors</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Integer scaling factors for each dimension (z, y, x). Must be positive integers.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(n_processing_chunks)","title":"<code>n_processing_chunks</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Number of zarr file chunks to process together along each axis (z, y, x). Processing chunk size = zarr_chunk_size * n_processing_chunks. Must result in processing chunks that are multiples of zarr chunks.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(border_size)","title":"<code>border_size</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Size of border to add around each chunk in voxels (z, y, x) in input space. Should be large enough to capture skeleton connectivity that might span chunk boundaries. Used to prevent incomplete upscaling at chunk edges but not written to output.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>)           \u2013            <p>Number of parallel processes to use.</p>"},{"location":"reference/skeleplex/skeleton/#skeleplex.skeleton.upscale_skeleton_parallel(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork)</code>, default:                   <code>\"spawn\"</code> )           \u2013            <p>Type of multiprocessing context to use. - \"spawn\": Start fresh Python process (safest, works on all platforms) - \"fork\": Copy parent process (faster but can have issues with threads)</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/","title":"_chunked_label","text":""},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label","title":"skeleplex.skeleton._chunked_label","text":"<p>Functions:</p> <ul> <li> <code>create_chunk_slices</code>             \u2013              <p>Create a list of slice tuples for iterating over an array in chunks.</p> </li> <li> <code>label_chunks_parallel</code>             \u2013              <p>Label connected components in a large zarr image using parallel processing.</p> </li> <li> <code>merge_touching_labels</code>             \u2013              <p>Merge touching labels across chunk boundaries.</p> </li> <li> <code>relabel_parallel</code>             \u2013              <p>Relabel a zarr array in parallel by applying a label mapping to chunks.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.create_chunk_slices","title":"create_chunk_slices","text":"<pre><code>create_chunk_slices(array_shape: tuple[int, ...], chunk_shape: tuple[int, ...]) -&gt; list[tuple[slice, ...]]\n</code></pre> <p>Create a list of slice tuples for iterating over an array in chunks.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list of tuple of slice</code>           \u2013            <p>list where each element is a tuple of slices for one chunk. The tuple has the same length as array_shape.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def create_chunk_slices(\n    array_shape: tuple[int, ...], chunk_shape: tuple[int, ...]\n) -&gt; list[tuple[slice, ...]]:\n    \"\"\"\n    Create a list of slice tuples for iterating over an array in chunks.\n\n    Parameters\n    ----------\n    array_shape : tuple of int\n        Shape of the array to be chunked (e.g., (1024, 2048, 2048))\n    chunk_shape : tuple of int\n        Shape of each chunk (e.g., (256, 512, 512))\n\n    Returns\n    -------\n    list of tuple of slice\n        list where each element is a tuple of slices for one chunk.\n        The tuple has the same length as array_shape.\n    \"\"\"\n    if len(array_shape) != len(chunk_shape):\n        raise ValueError(\"array_shape and chunk_shape must have same length\")\n\n    # Calculate number of chunks along each dimension\n    n_chunks_per_dim = [\n        (size + chunk_size - 1) // chunk_size  # Ceiling division\n        for size, chunk_size in zip(array_shape, chunk_shape, strict=False)\n    ]\n\n    # Generate all chunk indices\n    chunk_slices = []\n    for chunk_indices in product(*[range(n) for n in n_chunks_per_dim]):\n        slices = tuple(\n            slice(idx * chunk_size, min((idx + 1) * chunk_size, array_size))\n            for idx, chunk_size, array_size in zip(\n                chunk_indices, chunk_shape, array_shape, strict=False\n            )\n        )\n        chunk_slices.append(slices)\n\n    return chunk_slices\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.create_chunk_slices(array_shape)","title":"<code>array_shape</code>","text":"(<code>tuple of int</code>)           \u2013            <p>Shape of the array to be chunked (e.g., (1024, 2048, 2048))</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.create_chunk_slices(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple of int</code>)           \u2013            <p>Shape of each chunk (e.g., (256, 512, 512))</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel","title":"label_chunks_parallel","text":"<pre><code>label_chunks_parallel(input_path: str, output_path: str, chunk_shape: tuple[int, ...], n_processes: int = 4, pool_type: Literal['spawn', 'fork', 'forkserver', 'thread'] = 'fork', backend: Literal['cpu', 'cupy'] = 'cpu') -&gt; int\n</code></pre> <p>Label connected components in a large zarr image using parallel processing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Total number of unique labels assigned</p> </li> </ul> Notes <ul> <li>Input zarr must already exist</li> <li>Output zarr will be created with same shape/dtype as input if it doesn't exist</li> <li>Components spanning chunk boundaries will receive different labels</li> </ul> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def label_chunks_parallel(\n    input_path: str,\n    output_path: str,\n    chunk_shape: tuple[int, ...],\n    n_processes: int = 4,\n    pool_type: Literal[\"spawn\", \"fork\", \"forkserver\", \"thread\"] = \"fork\",\n    backend: Literal[\"cpu\", \"cupy\"] = \"cpu\",\n) -&gt; int:\n    \"\"\"\n    Label connected components in a large zarr image using parallel processing.\n\n    Parameters\n    ----------\n    input_path : str\n        Path to input zarr array\n    output_path : str\n        Path to output zarr array (will be created if doesn't exist)\n    chunk_shape : tuple of int\n        Shape of chunks to process in parallel. This will be the chunk shape\n        of the output array.\n    n_processes : int, default=4\n        Number of parallel processes/threads\n    pool_type : {'spawn', 'fork', 'forkserver', 'thread'}, default='spawn'\n        Type of multiprocessing context to use.\n        - 'spawn': Start fresh Python process (safest, works on all platforms)\n        - 'fork': Copy parent process (faster but can have issues with threads)\n        - 'forkserver': Hybrid approach (Unix only)\n        - 'thread': Use threading instead of multiprocessing (good for I/O bound)\n    backend : {'cpu', 'cupy'}, default='cpu'\n        Backend to use for labeling. 'cpu' uses CPU-based labeling,\n        'cupy' uses GPU-based labeling with CuPy. Default is 'cpu'.\n\n    Returns\n    -------\n    int\n        Total number of unique labels assigned\n\n    Notes\n    -----\n    - Input zarr must already exist\n    - Output zarr will be created with same shape/dtype as input if it doesn't exist\n    - Components spanning chunk boundaries will receive different labels\n    \"\"\"\n    # Open input zarr to get metadata\n    input_zarr = zarr.open(input_path, mode=\"r\")\n    array_shape = input_zarr.shape\n\n    # Create the output zarr\n    _ = zarr.create_array(\n        output_path, shape=array_shape, chunks=chunk_shape, dtype=np.uint64\n    )\n\n    # Create list of chunk slices\n    chunk_slices_list = create_chunk_slices(array_shape, chunk_shape)\n\n    print(\n        f\"Processing {len(chunk_slices_list)} chunks using {n_processes} \"\n        f\"{pool_type} workers\"\n    )\n\n    # Process chunks in parallel\n    if pool_type == \"thread\":\n        from multiprocessing.pool import ThreadPool\n\n        offset_counter = Value(\"i\", 0)\n        counter_lock = Lock()\n        pool = ThreadPool(\n            n_processes,\n            initializer=_init_worker,\n            initargs=(offset_counter, counter_lock),\n        )\n    else:\n        ctx = get_context(pool_type)\n        offset_counter = ctx.Value(\"i\", 0)\n        counter_lock = ctx.Lock()\n        pool = ctx.Pool(\n            n_processes,\n            initializer=_init_worker,\n            initargs=(offset_counter, counter_lock),\n        )\n\n    # Create the processing function\n    if backend == \"cpu\":\n        process_func = partial(\n            _label_chunk_with_offset, input_path=input_path, output_path=output_path\n        )\n    elif backend == \"cupy\":\n        process_func = partial(\n            _label_chunk_with_offset_gpu, input_path=input_path, output_path=output_path\n        )\n    else:\n        raise ValueError(f\"Unsupported backend: {backend}\")\n\n    try:\n        _ = pool.map(process_func, chunk_slices_list)\n    finally:\n        pool.close()\n        pool.join()\n\n    total_labels = offset_counter.value\n\n    return total_labels\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel(input_path)","title":"<code>input_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel(output_path)","title":"<code>output_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array (will be created if doesn't exist)</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple of int</code>)           \u2013            <p>Shape of chunks to process in parallel. This will be the chunk shape of the output array.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Number of parallel processes/threads</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork, forkserver, thread)</code>, default:                   <code>'spawn'</code> )           \u2013            <p>Type of multiprocessing context to use. - 'spawn': Start fresh Python process (safest, works on all platforms) - 'fork': Copy parent process (faster but can have issues with threads) - 'forkserver': Hybrid approach (Unix only) - 'thread': Use threading instead of multiprocessing (good for I/O bound)</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.label_chunks_parallel(backend)","title":"<code>backend</code>","text":"(<code>(cpu, cupy)</code>, default:                   <code>'cpu'</code> )           \u2013            <p>Backend to use for labeling. 'cpu' uses CPU-based labeling, 'cupy' uses GPU-based labeling with CuPy. Default is 'cpu'.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels","title":"merge_touching_labels","text":"<pre><code>merge_touching_labels(label_image_path: str, output_image_path: str, chunk_shape: tuple[int, int, int], max_label_value: int, n_processes: int, pool_type: Literal['spawn', 'fork', 'forkserver', 'thread'], backend: Literal['cpu', 'cupy'] = 'cpu') -&gt; None\n</code></pre> <p>Merge touching labels across chunk boundaries.</p> <p>This function finds labels that touch at chunk boundaries, computes connected components, and relabels all labels in each connected component to the maximum label value in that component.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def merge_touching_labels(\n    label_image_path: str,\n    output_image_path: str,\n    chunk_shape: tuple[int, int, int],\n    max_label_value: int,\n    n_processes: int,\n    pool_type: Literal[\"spawn\", \"fork\", \"forkserver\", \"thread\"],\n    backend: Literal[\"cpu\", \"cupy\"] = \"cpu\",\n) -&gt; None:\n    \"\"\"\n    Merge touching labels across chunk boundaries.\n\n    This function finds labels that touch at chunk boundaries, computes connected\n    components, and relabels all labels in each connected component to the maximum\n    label value in that component.\n\n    Parameters\n    ----------\n    label_image_path : str\n        Path to input zarr array.\n    output_image_path : str\n        Path to output zarr array (will be created if doesn't exist).\n    chunk_shape : tuple[int, int, int]\n        Shape of chunks to process in parallel.\n    max_label_value : int\n        Maximum label value in the entire image.\n    n_processes : int\n        Number of parallel processes/threads.\n    pool_type : {'spawn', 'fork', 'forkserver', 'thread'}\n        Type of multiprocessing context to use.\n    backend : {'cpu', 'cupy'}, default='cpu'\n        Backend to use for finding touching labels. 'cpu' uses CPU-based.\n        'cupy' uses GPU-based with CuPy. Default is 'cpu'.\n    \"\"\"\n    # Open input zarr to get array shape\n    input_zarr = zarr.open(label_image_path, mode=\"r\")\n    array_shape = input_zarr.shape\n\n    print(f\"Merging touching labels in array with shape {array_shape}\")\n\n    # Get boundary slices\n    boundaries = get_boundary_slices(array_shape, chunk_shape)\n\n    print(f\"Found {len(boundaries)} chunk boundaries\")\n\n    # Handle case with no boundaries (single chunk or small array)\n    if len(boundaries) == 0:\n        print(\"No chunk boundaries found. Copying input to output.\")\n        _copy_zarr_array(\n            label_image_path, output_image_path, chunk_shape, n_processes, pool_type\n        )\n        return\n\n    # Find touching labels at all boundaries in parallel\n    print(f\"Finding touching labels using {n_processes} {pool_type} workers\")\n\n    if pool_type == \"thread\":\n        pool = ThreadPool(n_processes)\n    else:\n        ctx = get_context(pool_type)\n        pool = ctx.Pool(n_processes)\n\n    # Create processing function for finding touching labels\n    if backend == \"cpu\":\n        process_func = partial(_find_touching_labels, label_image_path=label_image_path)\n    elif backend == \"cupy\":\n        process_func = partial(\n            _find_touching_labels_gpu, label_image_path=label_image_path\n        )\n    else:\n        raise ValueError(f\"Unsupported backend: {backend}\")\n\n    try:\n        results = pool.map(process_func, boundaries)\n    finally:\n        pool.close()\n        pool.join()\n\n    # Combine all touching pairs\n    all_touching_pairs = [arr for arr in results if len(arr) &gt; 0]\n\n    if len(all_touching_pairs) == 0:\n        print(\"No touching labels found. Copying input to output.\")\n        _copy_zarr_array(\n            label_image_path, output_image_path, chunk_shape, n_processes, pool_type\n        )\n        return\n\n    # Stack and remove duplicates\n    touching_pairs = np.vstack(all_touching_pairs)\n    touching_pairs = np.unique(touching_pairs, axis=0)\n\n    print(f\"Found {len(touching_pairs)} unique touching label pairs\")\n\n    # Create label mapping based on connected components\n    label_mapping = _make_label_mapping(touching_pairs, max_label_value)\n\n    print(f\"Created mapping for {len(label_mapping)} labels\")\n\n    if len(label_mapping) == 0:\n        print(\"No labels need remapping. Copying input to output.\")\n        _copy_zarr_array(\n            label_image_path, output_image_path, chunk_shape, n_processes, pool_type\n        )\n        return\n\n    # Apply relabeling in parallel\n    print(\"Applying relabeling to all chunks\")\n    relabel_parallel(\n        label_image_path=label_image_path,\n        output_array_path=output_image_path,\n        chunk_shape=chunk_shape,\n        label_mapping=label_mapping,\n        n_processes=n_processes,\n        pool_type=pool_type,\n    )\n\n    print(\"Merging complete\")\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(label_image_path)","title":"<code>label_image_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(output_image_path)","title":"<code>output_image_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array (will be created if doesn't exist).</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of chunks to process in parallel.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(max_label_value)","title":"<code>max_label_value</code>","text":"(<code>int</code>)           \u2013            <p>Maximum label value in the entire image.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>)           \u2013            <p>Number of parallel processes/threads.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork, forkserver, thread)</code>, default:                   <code>'spawn'</code> )           \u2013            <p>Type of multiprocessing context to use.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.merge_touching_labels(backend)","title":"<code>backend</code>","text":"(<code>(cpu, cupy)</code>, default:                   <code>'cpu'</code> )           \u2013            <p>Backend to use for finding touching labels. 'cpu' uses CPU-based. 'cupy' uses GPU-based with CuPy. Default is 'cpu'.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel","title":"relabel_parallel","text":"<pre><code>relabel_parallel(label_image_path: str, output_array_path: str, chunk_shape: tuple[int, int, int], label_mapping: dict[int, int], n_processes: int, pool_type: Literal['spawn', 'fork', 'forkserver', 'thread']) -&gt; None\n</code></pre> <p>Relabel a zarr array in parallel by applying a label mapping to chunks.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_chunked_label.py</code> <pre><code>def relabel_parallel(\n    label_image_path: str,\n    output_array_path: str,\n    chunk_shape: tuple[int, int, int],\n    label_mapping: dict[int, int],\n    n_processes: int,\n    pool_type: Literal[\"spawn\", \"fork\", \"forkserver\", \"thread\"],\n) -&gt; None:\n    \"\"\"\n    Relabel a zarr array in parallel by applying a label mapping to chunks.\n\n    Parameters\n    ----------\n    label_image_path : str\n        Path to input zarr array.\n    output_array_path : str\n        Path to output zarr array (will be created if doesn't exist).\n    chunk_shape : tuple[int, int, int]\n        Shape of chunks to process in parallel.\n    label_mapping : dict[int, int]\n        Mapping from original labels to new labels.\n    n_processes : int\n        Number of parallel processes/threads.\n    pool_type : {'spawn', 'fork', 'forkserver', 'thread'}\n        Type of multiprocessing context to use.\n    \"\"\"\n    # Open input zarr to get metadata\n    input_zarr = zarr.open(label_image_path, mode=\"r\")\n    array_shape = input_zarr.shape\n    dtype = input_zarr.dtype\n\n    # Create the output zarr\n    _ = zarr.create_array(\n        output_array_path, shape=array_shape, chunks=chunk_shape, dtype=dtype\n    )\n\n    # Create list of chunk slices\n    chunk_slices_list = create_chunk_slices(array_shape, chunk_shape)\n\n    print(\n        f\"Processing {len(chunk_slices_list)} chunks using {n_processes} \"\n        f\"{pool_type} workers\"\n    )\n\n    # Process chunks in parallel\n    if pool_type == \"thread\":\n        pool = ThreadPool(n_processes)\n    else:\n        ctx = get_context(pool_type)\n        pool = ctx.Pool(n_processes)\n\n    # Create the processing function\n    process_func = partial(\n        _relabel_chunk,\n        input_path=label_image_path,\n        output_path=output_array_path,\n        label_mapping=label_mapping,\n    )\n\n    try:\n        pool.map(process_func, chunk_slices_list)\n    finally:\n        pool.close()\n        pool.join()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel(label_image_path)","title":"<code>label_image_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel(output_array_path)","title":"<code>output_array_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array (will be created if doesn't exist).</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of chunks to process in parallel.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel(label_mapping)","title":"<code>label_mapping</code>","text":"(<code>dict[int, int]</code>)           \u2013            <p>Mapping from original labels to new labels.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>)           \u2013            <p>Number of parallel processes/threads.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_label/#skeleplex.skeleton._chunked_label.relabel_parallel(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork, forkserver, thread)</code>, default:                   <code>'spawn'</code> )           \u2013            <p>Type of multiprocessing context to use.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/","title":"_chunked_upscale","text":""},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale","title":"skeleplex.skeleton._chunked_upscale","text":"<p>Functions:</p> <ul> <li> <code>upscale_skeleton_parallel</code>             \u2013              <p>Upscale a skeleton image in parallel chunks across multiple processes.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel","title":"upscale_skeleton_parallel","text":"<pre><code>upscale_skeleton_parallel(input_path: str, output_path: str, scale_factors: tuple[int, int, int], n_processing_chunks: tuple[int, int, int], border_size: tuple[int, int, int], n_processes: int, pool_type: Literal['spawn', 'fork']) -&gt; None\n</code></pre> <p>Upscale a skeleton image in parallel chunks across multiple processes.</p> <p>This function processes a skeleton zarr image in parallel chunks across multiple CPU processes, applying skeleton upscaling to each chunk. The border around each chunk ensures skeleton connectivity that spans chunk boundaries is properly preserved during upscaling.</p> <p>Processing chunks are defined as multiples of the zarr file chunks to ensure chunk boundaries align for safe parallel writing. The output zarr uses the same chunk structure as the input (before scaling).</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If processing chunks don't align with zarr chunks, if border size is too large, or if scale factors are invalid.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_chunked_upscale.py</code> <pre><code>def upscale_skeleton_parallel(\n    input_path: str,\n    output_path: str,\n    scale_factors: tuple[int, int, int],\n    n_processing_chunks: tuple[int, int, int],\n    border_size: tuple[int, int, int],\n    n_processes: int,\n    pool_type: Literal[\"spawn\", \"fork\"],\n) -&gt; None:\n    \"\"\"Upscale a skeleton image in parallel chunks across multiple processes.\n\n    This function processes a skeleton zarr image in parallel chunks across\n    multiple CPU processes, applying skeleton upscaling to each chunk. The\n    border around each chunk ensures skeleton connectivity that spans chunk\n    boundaries is properly preserved during upscaling.\n\n    Processing chunks are defined as multiples of the zarr file chunks to\n    ensure chunk boundaries align for safe parallel writing. The output zarr\n    uses the same chunk structure as the input (before scaling).\n\n    Parameters\n    ----------\n    input_path : str\n        Path to input zarr array (binary skeleton image).\n    output_path : str\n        Path to output zarr array for upscaled skeleton (will be created).\n    scale_factors : tuple[int, int, int]\n        Integer scaling factors for each dimension (z, y, x). Must be positive\n        integers.\n    n_processing_chunks : tuple[int, int, int]\n        Number of zarr file chunks to process together along each axis (z, y, x).\n        Processing chunk size = zarr_chunk_size * n_processing_chunks.\n        Must result in processing chunks that are multiples of zarr chunks.\n    border_size : tuple[int, int, int]\n        Size of border to add around each chunk in voxels (z, y, x) in input\n        space. Should be large enough to capture skeleton connectivity that\n        might span chunk boundaries. Used to prevent incomplete upscaling at\n        chunk edges but not written to output.\n    n_processes : int\n        Number of parallel processes to use.\n    pool_type : {\"spawn\", \"fork\"}\n        Type of multiprocessing context to use.\n        - \"spawn\": Start fresh Python process (safest, works on all platforms)\n        - \"fork\": Copy parent process (faster but can have issues with threads)\n\n    Raises\n    ------\n    ValueError\n        If processing chunks don't align with zarr chunks, if border size is\n        too large, or if scale factors are invalid.\n    \"\"\"\n    # Open input zarr to get metadata\n    input_zarr = zarr.open(input_path, mode=\"r\")\n    input_shape = input_zarr.shape\n    zarr_chunks = input_zarr.chunks\n    dtype = input_zarr.dtype\n\n    # Calculate processing chunk size (in input space)\n    processing_chunk_size = tuple(\n        zarr_chunks[i] * n_processing_chunks[i] for i in range(3)\n    )\n\n    # Validate that processing chunks align with zarr chunks\n    for i in range(3):\n        if processing_chunk_size[i] % zarr_chunks[i] != 0:\n            raise ValueError(\n                f\"Processing chunk size {processing_chunk_size[i]} must be a \"\n                f\"multiple of zarr chunk size {zarr_chunks[i]} along axis {i}\"\n            )\n\n    # Validate border size is smaller than processing chunk size\n    for i in range(3):\n        if border_size[i] &gt;= processing_chunk_size[i]:\n            raise ValueError(\n                f\"Border size {border_size[i]} must be smaller than processing \"\n                f\"chunk size {processing_chunk_size[i]} along axis {i}\"\n            )\n\n    # Calculate output shape\n    output_shape = tuple(input_shape[i] * scale_factors[i] for i in range(3))\n\n    # Create output zarr array (same chunk structure as input)\n    _ = zarr.open(\n        output_path,\n        mode=\"w\",\n        shape=output_shape,\n        chunks=zarr_chunks,  # Same as input chunks\n        dtype=dtype,\n    )\n\n    # Create list of chunk slices (in input space)\n    chunk_slices_list = create_chunk_slices(input_shape, processing_chunk_size)\n\n    print(\n        f\"Processing {len(chunk_slices_list)} chunks of size \"\n        f\"{processing_chunk_size} using {n_processes} {pool_type} workers\"\n    )\n\n    # Create multiprocessing pool\n    ctx = get_context(pool_type)\n    pool = ctx.Pool(n_processes)\n\n    # Create the processing function with fixed arguments\n    process_func = partial(\n        _upscale_skeleton_chunk,\n        input_path=input_path,\n        output_path=output_path,\n        border_size=border_size,\n        scale_factors=scale_factors,\n        input_array_shape=input_shape,\n    )\n\n    try:\n        # Process all chunks in parallel\n        pool.map(process_func, chunk_slices_list)\n    finally:\n        # Cleanup pool\n        pool.close()\n        pool.join()\n\n    print(\"Skeleton upscaling complete\")\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(input_path)","title":"<code>input_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to input zarr array (binary skeleton image).</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(output_path)","title":"<code>output_path</code>","text":"(<code>str</code>)           \u2013            <p>Path to output zarr array for upscaled skeleton (will be created).</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(scale_factors)","title":"<code>scale_factors</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Integer scaling factors for each dimension (z, y, x). Must be positive integers.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(n_processing_chunks)","title":"<code>n_processing_chunks</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Number of zarr file chunks to process together along each axis (z, y, x). Processing chunk size = zarr_chunk_size * n_processing_chunks. Must result in processing chunks that are multiples of zarr chunks.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(border_size)","title":"<code>border_size</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Size of border to add around each chunk in voxels (z, y, x) in input space. Should be large enough to capture skeleton connectivity that might span chunk boundaries. Used to prevent incomplete upscaling at chunk edges but not written to output.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(n_processes)","title":"<code>n_processes</code>","text":"(<code>int</code>)           \u2013            <p>Number of parallel processes to use.</p>"},{"location":"reference/skeleplex/skeleton/_chunked_upscale/#skeleplex.skeleton._chunked_upscale.upscale_skeleton_parallel(pool_type)","title":"<code>pool_type</code>","text":"(<code>(spawn, fork)</code>, default:                   <code>\"spawn\"</code> )           \u2013            <p>Type of multiprocessing context to use. - \"spawn\": Start fresh Python process (safest, works on all platforms) - \"fork\": Copy parent process (faster but can have issues with threads)</p>"},{"location":"reference/skeleplex/skeleton/_segment/","title":"_segment","text":""},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment","title":"skeleplex.skeleton._segment","text":"<p>Functions:</p> <ul> <li> <code>segment</code>             \u2013              <p>Segment the structures to be skeletonized.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment","title":"segment","text":"<pre><code>segment(image: ndarray, model: Literal['pretrained'] | MultiscaleSemanticSegmentationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Segment the structures to be skeletonized.</p> <p>In the case of lungs, this would be used to segment the airways.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_segment.py</code> <pre><code>def segment(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Segment the structures to be skeletonized.\n\n    In the case of lungs, this would be used to segment the airways.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        raise NotImplementedError(\"pretrained segmentation models not implemented.\")\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSemanticSegmentationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSemanticSegmentationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/_segment/#skeleplex.skeleton._segment.segment(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/","title":"_skeletonize","text":""},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize","title":"skeleplex.skeleton._skeletonize","text":"<p>Functions:</p> <ul> <li> <code>filter_skeleton_by_segmentation</code>             \u2013              <p>Mask a predicted skeleton using a segmentation mask.</p> </li> <li> <code>skeletonize</code>             \u2013              <p>Skeletonize a normalized distance field image.</p> </li> <li> <code>skeletonize_chunkwise</code>             \u2013              <p>Skeletonize a large volume chunk by chunk using SkelePlex's skeletonize().</p> </li> <li> <code>threshold_skeleton</code>             \u2013              <p>Threshold a skeleton prediction to produce a binary skeleton mask.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.filter_skeleton_by_segmentation","title":"filter_skeleton_by_segmentation","text":"<pre><code>filter_skeleton_by_segmentation(skeleton: Array, segmentation: Array) -&gt; Array\n</code></pre> <p>Mask a predicted skeleton using a segmentation mask.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>Masked skeleton image (same dtype as skeleton).</p> </li> </ul> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def filter_skeleton_by_segmentation(\n    skeleton: da.Array,\n    segmentation: da.Array,\n) -&gt; da.Array:\n    \"\"\"\n    Mask a predicted skeleton using a segmentation mask.\n\n    Parameters\n    ----------\n    skeleton : dask.array.Array\n        Skeleton prediction image (usually float-valued).\n    segmentation : dask.array.Array\n        Binary segmentation mask with same shape as skeleton.\n\n    Returns\n    -------\n    dask.array.Array\n        Masked skeleton image (same dtype as skeleton).\n    \"\"\"\n    if skeleton.shape != segmentation.shape:\n        raise ValueError(\"Skeleton and segmentation shapes do not match.\")\n\n    return skeleton * segmentation.astype(np.float32)\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.filter_skeleton_by_segmentation(skeleton)","title":"<code>skeleton</code>","text":"(<code>Array</code>)           \u2013            <p>Skeleton prediction image (usually float-valued).</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.filter_skeleton_by_segmentation(segmentation)","title":"<code>segmentation</code>","text":"(<code>Array</code>)           \u2013            <p>Binary segmentation mask with same shape as skeleton.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize","title":"skeletonize","text":"<pre><code>skeletonize(image: ndarray, model: Literal['pretrained'] | MultiscaleSkeletonizationNet = 'pretrained', roi_size: tuple[int, int, int] = (120, 120, 120), overlap: float = 0.5, stitching_mode: str = 'gaussian', progress_bar: bool = True, batch_size: int = 1) -&gt; ndarray\n</code></pre> <p>Skeletonize a normalized distance field image.</p> <p>Parameters:</p> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def skeletonize(\n    image: np.ndarray,\n    model: Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    progress_bar: bool = True,\n    batch_size: int = 1,\n) -&gt; np.ndarray:\n    \"\"\"Skeletonize a normalized distance field image.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        The input image to skeletonize.\n        This should be a normalized distance field image.\n    model : Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",\n        The model to use for prediction. This can either be an instance of\n        MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\",\n        a pretrained model will be downloaded from the SkelePlex repository and used.\n        Default value is \"pretrained\".\n    roi_size : tuple[int, int, int]\n        The size of each tile to predict on.\n        The default value is (120, 120, 120).\n    overlap : float\n        The amount of overlap between tiles.\n        Should be between 0 and 1.\n        Default value is 0.5.\n    stitching_mode : str\n        The method to use to stitch overlapping tiles.\n        Should be \"gaussian\" or \"constant\".\n        \"gaussian\" uses a Gaussian kernel to weight the overlapping regions.\n        \"constant\" uses equal weight across overlapping regions.\n        \"gaussian\" is the default.\n    progress_bar : bool\n        Displays a progress bar during the prediction when set to True.\n        Default is True.\n    batch_size : int\n        The number of tiles to predict at once.\n        Default value is 1.\n    \"\"\"\n    # add dim -&gt; NCZYX\n    expanded_image = torch.from_numpy(make_image_5d(image))\n\n    # get the skeletonziation model if requested\n    if model == \"pretrained\":\n        model = get_skeletonization_model()\n\n    # put the model in eval mode\n    model.eval()\n\n    # make the prediction\n    with torch.no_grad():\n        result = sliding_window_inference(\n            inputs=expanded_image,\n            sw_batch_size=batch_size,\n            sw_device=torch.device(\"cuda\"),\n            predictor=model,\n            roi_size=roi_size,\n            overlap=overlap,\n            mode=stitching_mode,\n            device=torch.device(\"cpu\"),\n            progress=progress_bar,\n        )\n\n    # squeeze dims -&gt; ZYX\n    return torch.squeeze(torch.squeeze(result, dim=0), dim=0).numpy()\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>The input image to skeletonize. This should be a normalized distance field image.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(model)","title":"<code>model</code>","text":"(<code>Literal[\"pretrained\"] | MultiscaleSkeletonizationNet = \"pretrained\",</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for prediction. This can either be an instance of MultiscaleSkeletonizationNet or the string \"pretrained\". If \"pretrained\", a pretrained model will be downloaded from the SkelePlex repository and used. Default value is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple[int, int, int]</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>The size of each tile to predict on. The default value is (120, 120, 120).</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>The amount of overlap between tiles. Should be between 0 and 1. Default value is 0.5.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>The method to use to stitch overlapping tiles. Should be \"gaussian\" or \"constant\". \"gaussian\" uses a Gaussian kernel to weight the overlapping regions. \"constant\" uses equal weight across overlapping regions. \"gaussian\" is the default.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(progress_bar)","title":"<code>progress_bar</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Displays a progress bar during the prediction when set to True. Default is True.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The number of tiles to predict at once. Default value is 1.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise","title":"skeletonize_chunkwise","text":"<pre><code>skeletonize_chunkwise(input_dask_array: Array, model: str | MultiscaleSkeletonizationNet = 'pretrained', chunk_size: tuple[int, int, int] = (512, 512, 512), roi_size: tuple[int, int, int] = (120, 120, 120), padding: tuple[int, int, int] = (60, 60, 60), overlap: float = 0.5, stitching_mode: str = 'gaussian', batch_size: int = 1) -&gt; Array\n</code></pre> <p>Skeletonize a large volume chunk by chunk using SkelePlex's skeletonize().</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>Skeleton prediction as a Dask array.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def skeletonize_chunkwise(\n    input_dask_array: da.Array,\n    model: str | MultiscaleSkeletonizationNet = \"pretrained\",\n    chunk_size: tuple[int, int, int] = (512, 512, 512),\n    roi_size: tuple[int, int, int] = (120, 120, 120),\n    padding: tuple[int, int, int] = (60, 60, 60),\n    overlap: float = 0.5,\n    stitching_mode: str = \"gaussian\",\n    batch_size: int = 1,\n) -&gt; da.Array:\n    \"\"\"\n    Skeletonize a large volume chunk by chunk using SkelePlex's skeletonize().\n\n    Parameters\n    ----------\n    input_dask_array : dask.array.Array\n        Normalized distance field as a Dask array.\n    model : str or MultiscaleSkeletonizationNet, optional\n        The model to use for skeletonization.\n        If \"pretrained\", a pretrained model will be used.\n        Default is \"pretrained\".\n    chunk_size : tuple\n        Size of each chunk to process.\n    roi_size : tuple\n        ROI size for sliding window inference.\n    padding : tuple\n        Overlap margin in each direction.\n    overlap : float\n        Sliding window overlap for each chunk.\n    stitching_mode : str\n        Stitching mode for overlapping patches.\n    batch_size : int\n        Sliding window batch size.\n\n    Returns\n    -------\n    dask.array.Array\n        Skeleton prediction as a Dask array.\n    \"\"\"\n    model = get_skeletonization_model()\n\n    image_dask = input_dask_array\n    image_shape = image_dask.shape\n\n    start_indices = [\n        range(0, s, cs) for s, cs in zip(image_shape, chunk_size, strict=False)\n    ]\n    depth_chunks = []\n\n    for z_start in tqdm(start_indices[0], desc=\"Z\"):\n        height_chunks = []\n        for y_start in start_indices[1]:\n            width_chunks = []\n            for x_start in start_indices[2]:\n                z0 = max(z_start - padding[0], 0)\n                y0 = max(y_start - padding[1], 0)\n                x0 = max(x_start - padding[2], 0)\n\n                z1 = min(z_start + chunk_size[0] + padding[0], image_shape[0])\n                y1 = min(y_start + chunk_size[1] + padding[1], image_shape[1])\n                x1 = min(x_start + chunk_size[2] + padding[2], image_shape[2])\n\n                padded_chunk = image_dask[z0:z1, y0:y1, x0:x1].compute()\n\n                predicted_skeleton = skeletonize(\n                    padded_chunk,\n                    model=model,\n                    roi_size=roi_size,\n                    overlap=overlap,\n                    stitching_mode=stitching_mode,\n                    progress_bar=False,\n                    batch_size=batch_size,\n                )\n\n                crop_z0 = z_start - z0\n                crop_y0 = y_start - y0\n                crop_x0 = x_start - x0\n\n                crop_z1 = crop_z0 + min(chunk_size[0], image_shape[0] - z_start)\n                crop_y1 = crop_y0 + min(chunk_size[1], image_shape[1] - y_start)\n                crop_x1 = crop_x0 + min(chunk_size[2], image_shape[2] - x_start)\n\n                cropped_skeleton_prediction = predicted_skeleton[\n                    crop_z0:crop_z1,\n                    crop_y0:crop_y1,\n                    crop_x0:crop_x1,\n                ]\n\n                skeleton_chunk = da.from_array(\n                    cropped_skeleton_prediction,\n                    chunks=cropped_skeleton_prediction.shape,\n                )\n                width_chunks.append(skeleton_chunk)\n\n            height_chunks.append(da.concatenate(width_chunks, axis=2))\n        depth_chunk = da.concatenate(height_chunks, axis=1)\n        depth_chunks.append(depth_chunk)\n\n    skeleton_prediction = da.concatenate(depth_chunks, axis=0)\n    return skeleton_prediction\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(input_dask_array)","title":"<code>input_dask_array</code>","text":"(<code>Array</code>)           \u2013            <p>Normalized distance field as a Dask array.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(model)","title":"<code>model</code>","text":"(<code>str or MultiscaleSkeletonizationNet</code>, default:                   <code>'pretrained'</code> )           \u2013            <p>The model to use for skeletonization. If \"pretrained\", a pretrained model will be used. Default is \"pretrained\".</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(chunk_size)","title":"<code>chunk_size</code>","text":"(<code>tuple</code>, default:                   <code>(512, 512, 512)</code> )           \u2013            <p>Size of each chunk to process.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(roi_size)","title":"<code>roi_size</code>","text":"(<code>tuple</code>, default:                   <code>(120, 120, 120)</code> )           \u2013            <p>ROI size for sliding window inference.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(padding)","title":"<code>padding</code>","text":"(<code>tuple</code>, default:                   <code>(60, 60, 60)</code> )           \u2013            <p>Overlap margin in each direction.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(overlap)","title":"<code>overlap</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Sliding window overlap for each chunk.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(stitching_mode)","title":"<code>stitching_mode</code>","text":"(<code>str</code>, default:                   <code>'gaussian'</code> )           \u2013            <p>Stitching mode for overlapping patches.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.skeletonize_chunkwise(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Sliding window batch size.</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.threshold_skeleton","title":"threshold_skeleton","text":"<pre><code>threshold_skeleton(skeleton: Array, threshold: float) -&gt; Array\n</code></pre> <p>Threshold a skeleton prediction to produce a binary skeleton mask.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Array</code>           \u2013            <p>Binary skeleton mask as uint8.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_skeletonize.py</code> <pre><code>def threshold_skeleton(skeleton: da.Array, threshold: float) -&gt; da.Array:\n    \"\"\"\n    Threshold a skeleton prediction to produce a binary skeleton mask.\n\n    Parameters\n    ----------\n    skeleton : dask.array.Array\n        Input skeleton prediction array (e.g. probabilities).\n    threshold : float\n        Threshold value to binarize the skeleton prediction.\n\n    Returns\n    -------\n    dask.array.Array\n        Binary skeleton mask as uint8.\n    \"\"\"\n    return (skeleton &gt; threshold).astype(\"uint8\")\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.threshold_skeleton(skeleton)","title":"<code>skeleton</code>","text":"(<code>Array</code>)           \u2013            <p>Input skeleton prediction array (e.g. probabilities).</p>"},{"location":"reference/skeleplex/skeleton/_skeletonize/#skeleplex.skeleton._skeletonize.threshold_skeleton(threshold)","title":"<code>threshold</code>","text":"(<code>float</code>)           \u2013            <p>Threshold value to binarize the skeleton prediction.</p>"},{"location":"reference/skeleplex/skeleton/_upscale/","title":"_upscale","text":""},{"location":"reference/skeleplex/skeleton/_upscale/#skeleplex.skeleton._upscale","title":"skeleplex.skeleton._upscale","text":"<p>Upscale a skeleton image while preserving topology.</p> <p>Functions:</p> <ul> <li> <code>upscale_skeleton</code>             \u2013              <p>Upscale a 3D skeleton image while maintaining 1-voxel width.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_upscale/#skeleplex.skeleton._upscale.upscale_skeleton","title":"upscale_skeleton","text":"<pre><code>upscale_skeleton(skeleton: ndarray, scale_factors: tuple[int, int, int]) -&gt; ndarray\n</code></pre> <p>Upscale a 3D skeleton image while maintaining 1-voxel width.</p> <p>This function upscales a skeleton by scaling the coordinates of skeleton voxels and drawing lines between voxels that were originally connected.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>upscaled_skeleton</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array of the upscaled skeleton with shape (skeleton.shape[0] * scale_factors[0],  skeleton.shape[1] * scale_factors[1],  skeleton.shape[2] * scale_factors[2]).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If skeleton is not 3D, if scale_factors are not integers, or if scale_factors are not positive.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_upscale.py</code> <pre><code>def upscale_skeleton(\n    skeleton: np.ndarray,\n    scale_factors: tuple[int, int, int],\n) -&gt; np.ndarray:\n    \"\"\"Upscale a 3D skeleton image while maintaining 1-voxel width.\n\n    This function upscales a skeleton by scaling the coordinates of skeleton\n    voxels and drawing lines between voxels that were originally connected.\n\n    Parameters\n    ----------\n    skeleton : np.ndarray\n        3D boolean array representing the skeleton, where True indicates\n        skeleton voxels. Must be 3D.\n    scale_factors : tuple[int, int, int]\n        Integer scaling factors for each dimension (z, y, x). Must be positive\n        integers.\n\n    Returns\n    -------\n    upscaled_skeleton : np.ndarray\n        Boolean array of the upscaled skeleton with shape\n        (skeleton.shape[0] * scale_factors[0],\n         skeleton.shape[1] * scale_factors[1],\n         skeleton.shape[2] * scale_factors[2]).\n\n    Raises\n    ------\n    ValueError\n        If skeleton is not 3D, if scale_factors are not integers,\n        or if scale_factors are not positive.\n    \"\"\"\n    # Validate inputs\n    if skeleton.ndim != 3:\n        raise ValueError(f\"Skeleton must be 3D, got {skeleton.ndim}D\")\n\n    if len(scale_factors) != 3:\n        raise ValueError(f\"scale_factors must have length 3, got {len(scale_factors)}\")\n\n    # Check that scale factors are integers\n    if not all(isinstance(s, int | np.integer) for s in scale_factors):\n        raise ValueError(f\"scale_factors must be integers, got {scale_factors}\")\n\n    # Check that scale factors are positive\n    if not all(s &gt; 0 for s in scale_factors):\n        raise ValueError(\n            f\"scale_factors must be positive integers, got {scale_factors}\"\n        )\n\n    # Calculate upscaled shape\n    upscaled_shape = tuple(skeleton.shape[i] * scale_factors[i] for i in range(3))\n\n    # Create output array\n    upscaled_skeleton = np.zeros(upscaled_shape, dtype=bool)\n\n    # Get the connectivity graph of the original skeleton\n    # Use connectivity=3 for 26-connectivity (includes diagonals)\n    edges, nodes = pixel_graph(skeleton, connectivity=3)\n\n    if len(nodes) == 0:\n        # Empty skeleton, return empty upscaled skeleton\n        return upscaled_skeleton\n\n    # Convert the raveled node indices back to coordinates in the original scale\n    node_coordinates = np.array(np.unravel_index(nodes, skeleton.shape)).T\n\n    # Scale the coordinates and clip to array boundaries\n    scaled_node_coords = np.round(node_coordinates * np.array(scale_factors)).astype(\n        int\n    )\n\n    # Clip to ensure coordinates are within bounds\n    for i in range(3):\n        scaled_node_coords[:, i] = np.clip(\n            scaled_node_coords[:, i], 0, upscaled_shape[i] - 1\n        )\n\n    # Set the scaled coordinates to True\n    upscaled_skeleton[\n        scaled_node_coords[:, 0],\n        scaled_node_coords[:, 1],\n        scaled_node_coords[:, 2],\n    ] = True\n\n    # Convert edges to COO format arrays for iteration\n    # edges is a sparse matrix where\n    # entry (i,j) means nodes[i] and nodes[j] are connected\n    edge_indices = np.array(edges.nonzero()).T\n\n    # Draw lines between connected voxels in the upscaled image\n    for i in range(edge_indices.shape[0]):\n        # Get the indices into the nodes array\n        idx1 = edge_indices[i, 0]\n        idx2 = edge_indices[i, 1]\n\n        # Get the scaled coordinates of the two connected voxels\n        coord1 = scaled_node_coords[idx1]\n        coord2 = scaled_node_coords[idx2]\n\n        # Draw a line between them\n        # line_nd returns indices for each dimension\n        line_indices = line_nd(coord1, coord2, endpoint=True)\n\n        # Set all voxels along the line to True\n        upscaled_skeleton[line_indices] = True\n\n    return upscaled_skeleton\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_upscale/#skeleplex.skeleton._upscale.upscale_skeleton(skeleton)","title":"<code>skeleton</code>","text":"(<code>ndarray</code>)           \u2013            <p>3D boolean array representing the skeleton, where True indicates skeleton voxels. Must be 3D.</p>"},{"location":"reference/skeleplex/skeleton/_upscale/#skeleplex.skeleton._upscale.upscale_skeleton(scale_factors)","title":"<code>scale_factors</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Integer scaling factors for each dimension (z, y, x). Must be positive integers.</p>"},{"location":"reference/skeleplex/skeleton/_utils/","title":"_utils","text":""},{"location":"reference/skeleplex/skeleton/_utils/#skeleplex.skeleton._utils","title":"skeleplex.skeleton._utils","text":"<p>Utilities for the skeletonization process.</p> <p>Functions:</p> <ul> <li> <code>get_skeletonization_model</code>             \u2013              <p>Get a pretrained model from the SkelePlex repository.</p> </li> <li> <code>make_image_5d</code>             \u2013              <p>Make a 5D image from a 3D, 4D, or 5D image.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/_utils/#skeleplex.skeleton._utils.get_skeletonization_model","title":"get_skeletonization_model","text":"<pre><code>get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet\n</code></pre> <p>Get a pretrained model from the SkelePlex repository.</p> <p>Returns:</p> <ul> <li> <code>MultiscaleSkeletonizationNet</code>           \u2013            <p>The pretrained skeletonization model.</p> </li> </ul> Source code in <code>skeleplex/skeleton/_utils.py</code> <pre><code>def get_skeletonization_model() -&gt; MultiscaleSkeletonizationNet:\n    \"\"\"Get a pretrained model from the SkelePlex repository.\n\n    Returns\n    -------\n    MultiscaleSkeletonizationNet\n        The pretrained skeletonization model.\n    \"\"\"\n    # download the weights\n    file_path = SKELETONIZATION_MODEL_REGISTRY.fetch(\"skel-best.ckpt\")\n\n    return MultiscaleSkeletonizationNet.load_from_checkpoint(file_path)\n</code></pre>"},{"location":"reference/skeleplex/skeleton/_utils/#skeleplex.skeleton._utils.make_image_5d","title":"make_image_5d","text":"<pre><code>make_image_5d(image: ndarray) -&gt; ndarray\n</code></pre> <p>Make a 5D image from a 3D, 4D, or 5D image.</p> Source code in <code>skeleplex/skeleton/_utils.py</code> <pre><code>def make_image_5d(image: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Make a 5D image from a 3D, 4D, or 5D image.\"\"\"\n    if image.ndim == 5:\n        return image\n    elif image.ndim == 4:\n        return np.expand_dims(image, axis=0)\n    elif image.ndim == 3:\n        return np.expand_dims(np.expand_dims(image, axis=0), axis=0)\n    else:\n        raise ValueError(\"Image must be 3D, 4D or 5D\")\n</code></pre>"},{"location":"reference/skeleplex/skeleton/distance_field/","title":"distance_field","text":""},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field","title":"skeleplex.skeleton.distance_field","text":"<p>Functions for computing normalized distance transform.</p> <p>Functions:</p> <ul> <li> <code>local_normalized_distance</code>             \u2013              <p>Compute normalized distance transform for a binary image.</p> </li> <li> <code>local_normalized_distance_gpu</code>             \u2013              <p>Compute normalized distance transform for a binary image on GPU using CuPy.</p> </li> </ul>"},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field.local_normalized_distance","title":"local_normalized_distance","text":"<pre><code>local_normalized_distance(image: ndarray, max_ball_radius: int = 30) -&gt; ndarray\n</code></pre> <p>Compute normalized distance transform for a binary image.</p> <p>This algorithm computes the distance transform for each connected component of the binary image and normalizes the distances locally using a maximum filter. This ensures comparable distance measures across regions of varying sizes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of same shape as input image, containing normalized distance values.</p> </li> </ul> Source code in <code>skeleplex/skeleton/distance_field.py</code> <pre><code>def local_normalized_distance(\n    image: np.ndarray,\n    max_ball_radius: int = 30,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute normalized distance transform for a binary image.\n\n    This algorithm computes the distance transform for each connected component\n    of the binary image and normalizes the distances locally using a maximum filter.\n    This ensures comparable distance measures across regions of varying sizes.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        Binary array where non-zero values are interpreted as foreground.\n    max_ball_radius : int\n        Maximum radius of the ball used for maximum filtering.\n        Default is 30.\n\n    Returns\n    -------\n    np.ndarray\n        Array of same shape as input image, containing normalized distance values.\n    \"\"\"\n    image = np.asarray(image)\n    binary = image &gt; 0\n    labeled, num_labels = label(binary)\n    normalized_distance = np.zeros_like(image, dtype=np.float32)\n\n    for i in range(1, num_labels + 1):\n        mask = labeled == i\n\n        distance = distance_transform_edt(mask)\n\n        local_max = np.max(distance)\n        radius = min(int(local_max / 2), max_ball_radius)\n\n        # apply maximum filter to normalize distances locally\n        local_max_distance = maximum_filter(distance, size=radius * 2 + 1)\n\n        normalized_distance[mask] = distance[mask] / (local_max_distance[mask])\n\n    return normalized_distance\n</code></pre>"},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field.local_normalized_distance(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>Binary array where non-zero values are interpreted as foreground.</p>"},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field.local_normalized_distance(max_ball_radius)","title":"<code>max_ball_radius</code>","text":"(<code>int</code>, default:                   <code>30</code> )           \u2013            <p>Maximum radius of the ball used for maximum filtering. Default is 30.</p>"},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field.local_normalized_distance_gpu","title":"local_normalized_distance_gpu","text":"<pre><code>local_normalized_distance_gpu(image: ndarray, max_ball_radius: int = 30) -&gt; ndarray\n</code></pre> <p>Compute normalized distance transform for a binary image on GPU using CuPy.</p> <p>This algorithm computes the distance transform for each connected component of the binary image and normalizes the distances locally using a maximum filter. This ensures comparable distance measures across regions of varying sizes. It is accelerated on the GPU using CuPy.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>Array of same shape as input image, containing normalized distance values.</p> </li> </ul> Source code in <code>skeleplex/skeleton/distance_field.py</code> <pre><code>def local_normalized_distance_gpu(\n    image: np.ndarray,\n    max_ball_radius: int = 30,\n) -&gt; np.ndarray:\n    \"\"\"\n    Compute normalized distance transform for a binary image on GPU using CuPy.\n\n    This algorithm computes the distance transform for each connected component\n    of the binary image and normalizes the distances locally using a maximum filter.\n    This ensures comparable distance measures across regions of varying sizes.\n    It is accelerated on the GPU using CuPy.\n\n    Parameters\n    ----------\n    image : np.ndarray\n        Binary array where non-zero values are interpreted as foreground.\n    max_ball_radius : int\n        Maximum radius for the structuring element used in the maximum filter.\n        Default is 30.\n\n    Returns\n    -------\n    np.ndarray\n        Array of same shape as input image, containing normalized distance values.\n    \"\"\"\n    try:\n        import cupy as cp\n        from cupyx.scipy.ndimage import (\n            distance_transform_edt as distance_transform_edt_gpu,\n        )\n        from cupyx.scipy.ndimage import label\n        from cupyx.scipy.ndimage import maximum_filter as maximum_filter_gpu\n\n    except ImportError as err:\n        raise ImportError(\n            \"local_normalized_distance_gpu requires CuPy. \"\n            \"Please install it by following the CuPy \"\n            \"installation instructions for your GPU.\"\n        ) from err\n\n    image = cp.asarray(image)  # move to GPU\n    binary = image &gt; 0\n    labeled, num_labels = label(binary)\n    normalized_distance = cp.zeros_like(image, dtype=cp.float32)\n\n    for i in range(1, num_labels + 1):\n        mask = labeled == i\n\n        distance = distance_transform_edt_gpu(mask)\n\n        local_max = cp.max(distance)\n        radius = min(int(local_max / 2), max_ball_radius)\n\n        # apply maximum filter to normalize distances locally\n        local_max_distance = maximum_filter_gpu(distance, size=radius * 2 + 1)\n\n        normalized_distance[mask] = distance[mask] / (local_max_distance[mask])\n\n    return cp.asnumpy(normalized_distance)\n</code></pre>"},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field.local_normalized_distance_gpu(image)","title":"<code>image</code>","text":"(<code>ndarray</code>)           \u2013            <p>Binary array where non-zero values are interpreted as foreground.</p>"},{"location":"reference/skeleplex/skeleton/distance_field/#skeleplex.skeleton.distance_field.local_normalized_distance_gpu(max_ball_radius)","title":"<code>max_ball_radius</code>","text":"(<code>int</code>, default:                   <code>30</code> )           \u2013            <p>Maximum radius for the structuring element used in the maximum filter. Default is 30.</p>"},{"location":"reference/skeleplex/utils/","title":"utils","text":""},{"location":"reference/skeleplex/utils/#skeleplex.utils","title":"skeleplex.utils","text":"<p>Utilities for operating on the skeleton.</p> <p>Functions:</p> <ul> <li> <code>calculate_expanded_slice</code>             \u2013              <p>Calculate expanded slice and actual border size for a chunk.</p> </li> <li> <code>get_boundary_slices</code>             \u2013              <p>Get slice objects for 2-voxel thick interfaces at chunk boundaries.</p> </li> <li> <code>iteratively_process_chunks_3d</code>             \u2013              <p>Apply a function to each chunk of a Dask array with extra border handling.</p> </li> <li> <code>line_segments_in_aabb</code>             \u2013              <p>Get a boolean mask for line segments completely within an AABB.</p> </li> <li> <code>points_in_aabb</code>             \u2013              <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> </li> </ul>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.calculate_expanded_slice","title":"calculate_expanded_slice","text":"<pre><code>calculate_expanded_slice(chunk_slice: tuple[slice, ...], border_size: tuple[int, int, int], array_shape: tuple[int, int, int]) -&gt; tuple[tuple[slice, ...], tuple[int, int, int]]\n</code></pre> <p>Calculate expanded slice and actual border size for a chunk.</p> <p>Given a core chunk slice, this function calculates an expanded slice that includes a border around the core chunk, clipped to array boundaries. It also returns the actual border size used (may be smaller at array edges).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>expanded_slice</code> (              <code>tuple of slice</code> )          \u2013            <p>Slice objects defining the expanded chunk region (core + border).</p> </li> <li> <code>actual_border_before</code> (              <code>tuple[int, int, int]</code> )          \u2013            <p>Actual border size before the core chunk (z, y, x). May be smaller than requested at array boundaries.</p> </li> </ul> Source code in <code>skeleplex/utils/_chunked.py</code> <pre><code>def calculate_expanded_slice(\n    chunk_slice: tuple[slice, ...],\n    border_size: tuple[int, int, int],\n    array_shape: tuple[int, int, int],\n) -&gt; tuple[tuple[slice, ...], tuple[int, int, int]]:\n    \"\"\"Calculate expanded slice and actual border size for a chunk.\n\n    Given a core chunk slice, this function calculates an expanded slice\n    that includes a border around the core chunk, clipped to array boundaries.\n    It also returns the actual border size used (may be smaller at array edges).\n\n    Parameters\n    ----------\n    chunk_slice : tuple of slice\n        Slice objects defining the core chunk region.\n    border_size : tuple[int, int, int]\n        Desired border size to add around chunk in voxels (z, y, x).\n    array_shape : tuple[int, int, int]\n        Shape of the full array (z, y, x).\n\n    Returns\n    -------\n    expanded_slice : tuple of slice\n        Slice objects defining the expanded chunk region (core + border).\n    actual_border_before : tuple[int, int, int]\n        Actual border size before the core chunk (z, y, x).\n        May be smaller than requested at array boundaries.\n    \"\"\"\n    # Extract core chunk boundaries\n    core_start = tuple(s.start for s in chunk_slice)\n    core_end = tuple(s.stop for s in chunk_slice)\n\n    # Calculate expanded slice (core + border, clipped to array boundaries)\n    expanded_start = tuple(max(0, core_start[i] - border_size[i]) for i in range(3))\n    expanded_end = tuple(\n        min(array_shape[i], core_end[i] + border_size[i]) for i in range(3)\n    )\n    expanded_slice = tuple(slice(expanded_start[i], expanded_end[i]) for i in range(3))\n\n    # Calculate actual border used (may be smaller at array edges)\n    actual_border_before = tuple(core_start[i] - expanded_start[i] for i in range(3))\n\n    return expanded_slice, actual_border_before\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.calculate_expanded_slice(chunk_slice)","title":"<code>chunk_slice</code>","text":"(<code>tuple of slice</code>)           \u2013            <p>Slice objects defining the core chunk region.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.calculate_expanded_slice(border_size)","title":"<code>border_size</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Desired border size to add around chunk in voxels (z, y, x).</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.calculate_expanded_slice(array_shape)","title":"<code>array_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of the full array (z, y, x).</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.get_boundary_slices","title":"get_boundary_slices","text":"<pre><code>get_boundary_slices(array_shape: tuple[int, int, int], chunk_shape: tuple[int, int, int]) -&gt; list[tuple[slice, slice, slice]]\n</code></pre> <p>Get slice objects for 2-voxel thick interfaces at chunk boundaries.</p> <p>For each boundary between chunks, returns a tuple of slice objects that selects a 2-voxel thick region: 1 voxel from the end of one chunk and 1 voxel from the beginning of the adjacent chunk.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[slice, slice, slice]]</code>           \u2013            <p>List of (slice, slice, slice) tuples for indexing boundary regions</p> </li> </ul> Source code in <code>skeleplex/utils/_chunked.py</code> <pre><code>def get_boundary_slices(\n    array_shape: tuple[int, int, int], chunk_shape: tuple[int, int, int]\n) -&gt; list[tuple[slice, slice, slice]]:\n    \"\"\"\n    Get slice objects for 2-voxel thick interfaces at chunk boundaries.\n\n    For each boundary between chunks, returns a tuple of slice objects that\n    selects a 2-voxel thick region: 1 voxel from the end of one chunk and\n    1 voxel from the beginning of the adjacent chunk.\n\n    Parameters\n    ----------\n    array_shape : tuple[int, int, int]\n        Shape of the array (z, y, x)\n    chunk_shape : tuple[int, int, int]\n        Shape of each chunk (z, y, x). All chunks are assumed to be the same size.\n\n    Returns\n    -------\n    list[tuple[slice, slice, slice]]\n        List of (slice, slice, slice) tuples for indexing boundary regions\n    \"\"\"\n    boundary_slices = []\n\n    # Iterate through each dimension (z=0, y=1, x=2)\n    for dim in range(3):\n        # Calculate number of chunks in this dimension\n        num_chunks = (array_shape[dim] + chunk_shape[dim] - 1) // chunk_shape[dim]\n\n        # Iterate through internal boundaries (between chunk n and chunk n+1)\n        for chunk_idx in range(1, num_chunks):\n            # Boundary position is at the start of chunk (chunk_idx)\n            boundary_pos = chunk_idx * chunk_shape[dim]\n\n            # Check if the 2-voxel interface fits within array bounds\n            if boundary_pos &gt; 0 and boundary_pos &lt; array_shape[dim]:\n                # Create slice tuple for this boundary\n                slices = [slice(None)] * 3  # Start with full slices for all dims\n\n                # Set the slice for the boundary dimension\n                # Take 1 voxel before and 1 voxel at the boundary\n                slices[dim] = slice(boundary_pos - 1, boundary_pos + 1)\n\n                boundary_slices.append(tuple(slices))\n\n    return boundary_slices\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.get_boundary_slices(array_shape)","title":"<code>array_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of the array (z, y, x)</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.get_boundary_slices(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of each chunk (z, y, x). All chunks are assumed to be the same size.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.iteratively_process_chunks_3d","title":"iteratively_process_chunks_3d","text":"<pre><code>iteratively_process_chunks_3d(input_array: Array, output_zarr: Array, function_to_apply: Callable[[ndarray], ndarray], chunk_shape: tuple[int, int, int], extra_border: tuple[int, int, int], *args, **kwargs)\n</code></pre> <p>Apply a function to each chunk of a Dask array with extra border handling.</p> no <p>input_array : dask.array.Array     The input Dask array to process. Must be 3D. output_zarr : zarr.Array     The output Zarr array to write results to.     Must have the same shape as input_array. function_to_apply : Callable[[np.ndarray], np.ndarray]     The function to apply to each chunk. chunk_shape : tuple[int, int, int]     The shape of each chunk to process. extra_border : tuple[int, int, int]     The extra border to include around each chunk. args     Additional positional arguments to pass to function_to_apply. *kwargs     Additional keyword arguments to pass to function_to_apply.</p> Source code in <code>skeleplex/utils/_chunked.py</code> <pre><code>def iteratively_process_chunks_3d(\n    input_array: da.Array,\n    output_zarr: zarr.Array,\n    function_to_apply: Callable[[np.ndarray], np.ndarray],\n    chunk_shape: tuple[int, int, int],\n    extra_border: tuple[int, int, int],\n    *args,\n    **kwargs,\n):\n    \"\"\"Apply a function to each chunk of a Dask array with extra border handling.\n\n    no\n    ----------\n    input_array : dask.array.Array\n        The input Dask array to process. Must be 3D.\n    output_zarr : zarr.Array\n        The output Zarr array to write results to.\n        Must have the same shape as input_array.\n    function_to_apply : Callable[[np.ndarray], np.ndarray]\n        The function to apply to each chunk.\n    chunk_shape : tuple[int, int, int]\n        The shape of each chunk to process.\n    extra_border : tuple[int, int, int]\n        The extra border to include around each chunk.\n    *args\n        Additional positional arguments to pass to function_to_apply.\n    **kwargs\n        Additional keyword arguments to pass to function_to_apply.\n    \"\"\"\n    # validate inputs before processing\n    if input_array.ndim != 3:\n        raise ValueError(f\"Input array must be 3D, got {input_array.ndim}D\")\n\n    if len(chunk_shape) != 3:\n        raise ValueError(\n            f\"chunk_shape must be a 3-tuple, got length {len(chunk_shape)}\"\n        )\n\n    if len(extra_border) != 3:\n        raise ValueError(\n            f\"extra_border must be a 3-tuple, got length {len(extra_border)}\"\n        )\n\n    # calculate the chunk grid\n    array_shape = input_array.shape\n    n_chunks = tuple(int(np.ceil(array_shape[i] / chunk_shape[i])) for i in range(3))\n\n    total_chunks = n_chunks[0] * n_chunks[1] * n_chunks[2]\n    with tqdm(total=total_chunks, desc=\"Processing chunks\") as pbar:\n        for i in range(n_chunks[0]):\n            for j in range(n_chunks[1]):\n                for k in range(n_chunks[2]):\n                    pbar.update(1)\n\n                    # calculate core chunk slice\n                    core_start = (\n                        i * chunk_shape[0],\n                        j * chunk_shape[1],\n                        k * chunk_shape[2],\n                    )\n                    core_end = (\n                        min((i + 1) * chunk_shape[0], array_shape[0]),\n                        min((j + 1) * chunk_shape[1], array_shape[1]),\n                        min((k + 1) * chunk_shape[2], array_shape[2]),\n                    )\n                    core_slice = tuple(\n                        slice(core_start[dim], core_end[dim]) for dim in range(3)\n                    )\n\n                    # calculate expanded slice (chunk + border)\n                    # clipped to array boundaries\n                    expanded_start = tuple(\n                        max(0, core_start[dim] - extra_border[dim]) for dim in range(3)\n                    )\n                    expanded_end = tuple(\n                        min(array_shape[dim], core_end[dim] + extra_border[dim])\n                        for dim in range(3)\n                    )\n                    expanded_slice = tuple(\n                        slice(expanded_start[dim], expanded_end[dim])\n                        for dim in range(3)\n                    )\n\n                    # calculate actual border used (may be smaller at edges)\n                    actual_border_before = tuple(\n                        core_start[dim] - expanded_start[dim] for dim in range(3)\n                    )\n\n                    # extract chunk + border and compute\n                    chunk_with_border = input_array[expanded_slice].compute()\n\n                    # apply function\n                    processed = function_to_apply(chunk_with_border, *args, **kwargs)\n\n                    # extend slice to match output_array_shape array dimensions\n                    core_in_result_slice = [\n                        slice(\n                            actual_border_before[dim],\n                            actual_border_before[dim]\n                            + (core_end[dim] - core_start[dim]),\n                        )\n                        for dim in range(3)\n                    ]\n\n                    # if the processed array has extra dims (e.g., channels/features),\n                    # extend the slice with full slices for those dimensions\n                    n_extra_dims = processed.ndim - 3\n                    # dimensions beyond the first 3\n                    if n_extra_dims &gt; 0:\n                        extra_slices = [\n                            slice(0, processed.shape[dim_idx])\n                            for dim_idx in range(n_extra_dims)\n                        ]\n\n                        # this is used to slice the processed array\n                        core_in_result_slice = extra_slices + core_in_result_slice\n                        # this is used slice the output array into which we write\n                        core_slice_extended = extra_slices + list(core_slice)\n                    else:\n                        # if no extra dims, just use the 3D slices\n                        core_slice_extended = list(core_slice)\n\n                    # convert back to tuple\n                    core_in_result_slice = tuple(core_in_result_slice)\n                    core_slice_extended = tuple(core_slice_extended)\n\n                    # check if end dimensions match input\n                    if processed.ndim != len(core_in_result_slice):\n                        raise ValueError(\n                            \"The output of function_to_apply has \"\n                            \"incompatible number of dimensions.\"\n                        )\n\n                    core_result = processed[core_in_result_slice]\n\n                    # write to Zarr\n                    output_zarr[core_slice_extended] = core_result\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb","title":"line_segments_in_aabb","text":"<pre><code>line_segments_in_aabb(line_segments: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Get a boolean mask for line segments completely within an AABB.</p> <p>A line segment is considered completely inside the bounding box if both its start and end points are within the bounding box (inclusive of boundaries).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_line_segments,) where True indicates line segments completely within the bounding box.</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def line_segments_in_aabb(\n    line_segments: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Get a boolean mask for line segments completely within an AABB.\n\n    A line segment is considered completely inside the bounding box if both\n    its start and end points are within the bounding box (inclusive of boundaries).\n\n    Parameters\n    ----------\n    line_segments : np.ndarray\n        (2 * n_line_segments, n_dim) array of line segment coordinates.\n        Line segment n goes from line_segments[2*n] to line_segments[2*n + 1].\n    min_bounds : np.ndarray\n        (n_dim,) array of the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array of the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_line_segments,) where True indicates\n        line segments completely within the bounding box.\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Calculate number of line segments\n    n_line_segments = line_segments.shape[0] // 2\n\n    # Reshape to separate start and end points: (n_line_segments, 2, 3)\n    segments_reshaped = line_segments.reshape(n_line_segments, 2, 3)\n\n    # Check if each point is within bounds\n    # Broadcasting: (n_line_segments, 2, 3) &gt;= (3,) -&gt; (n_line_segments, 2, 3)\n    within_min = np.all(segments_reshaped &gt;= min_bounds, axis=2)  # (n_line_segments, 2)\n    within_max = np.all(segments_reshaped &lt;= max_bounds, axis=2)  # (n_line_segments, 2)\n\n    # Both start and end points must be within bounds\n    points_in_bounds = within_min &amp; within_max  # (n_line_segments, 2)\n\n    # Line segment is completely inside if both points are inside\n    segments_completely_inside = np.all(points_in_bounds, axis=1)  # (n_line_segments,)\n\n    expanded_mask = np.repeat(segments_completely_inside, 2)  # (2 * n_line_segments,)\n\n    return expanded_mask\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb(line_segments)","title":"<code>line_segments</code>","text":"(<code>ndarray</code>)           \u2013            <p>(2 * n_line_segments, n_dim) array of line segment coordinates. Line segment n goes from line_segments[2n] to line_segments[2n + 1].</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.line_segments_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb","title":"points_in_aabb","text":"<pre><code>points_in_aabb(coordinates: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_coordinates,) where True indicates coordinates within the bounding box (inclusive of boundaries).</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def points_in_aabb(\n    coordinates: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Create a boolean mask for coordinates within an axis-aligned bounding box.\n\n    Parameters\n    ----------\n    coordinates : np.ndarray\n        (n_coordinates, n_dim) array of point coordinates.\n    min_bounds : np.ndarray\n        (n_dim,) array with the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array with the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_coordinates,) where True indicates\n        coordinates within the bounding box (inclusive of boundaries).\n\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Vectorized comparison: coordinates &gt;= min_bounds and coordinates &lt;= max_bounds\n    # Broadcasting handles the comparison across all coordinates simultaneously\n    within_min = np.all(coordinates &gt;= min_bounds, axis=1)\n    within_max = np.all(coordinates &lt;= max_bounds, axis=1)\n\n    # Return mask where both conditions are satisfied\n    return within_min &amp; within_max\n</code></pre>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_coordinates, n_dim) array of point coordinates.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/#skeleplex.utils.points_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_chunked/","title":"_chunked","text":""},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked","title":"skeleplex.utils._chunked","text":"<p>Utilities for working with chunked arrays.</p> <p>Functions:</p> <ul> <li> <code>calculate_expanded_slice</code>             \u2013              <p>Calculate expanded slice and actual border size for a chunk.</p> </li> <li> <code>get_boundary_slices</code>             \u2013              <p>Get slice objects for 2-voxel thick interfaces at chunk boundaries.</p> </li> <li> <code>iteratively_process_chunks_3d</code>             \u2013              <p>Apply a function to each chunk of a Dask array with extra border handling.</p> </li> </ul>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.calculate_expanded_slice","title":"calculate_expanded_slice","text":"<pre><code>calculate_expanded_slice(chunk_slice: tuple[slice, ...], border_size: tuple[int, int, int], array_shape: tuple[int, int, int]) -&gt; tuple[tuple[slice, ...], tuple[int, int, int]]\n</code></pre> <p>Calculate expanded slice and actual border size for a chunk.</p> <p>Given a core chunk slice, this function calculates an expanded slice that includes a border around the core chunk, clipped to array boundaries. It also returns the actual border size used (may be smaller at array edges).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>expanded_slice</code> (              <code>tuple of slice</code> )          \u2013            <p>Slice objects defining the expanded chunk region (core + border).</p> </li> <li> <code>actual_border_before</code> (              <code>tuple[int, int, int]</code> )          \u2013            <p>Actual border size before the core chunk (z, y, x). May be smaller than requested at array boundaries.</p> </li> </ul> Source code in <code>skeleplex/utils/_chunked.py</code> <pre><code>def calculate_expanded_slice(\n    chunk_slice: tuple[slice, ...],\n    border_size: tuple[int, int, int],\n    array_shape: tuple[int, int, int],\n) -&gt; tuple[tuple[slice, ...], tuple[int, int, int]]:\n    \"\"\"Calculate expanded slice and actual border size for a chunk.\n\n    Given a core chunk slice, this function calculates an expanded slice\n    that includes a border around the core chunk, clipped to array boundaries.\n    It also returns the actual border size used (may be smaller at array edges).\n\n    Parameters\n    ----------\n    chunk_slice : tuple of slice\n        Slice objects defining the core chunk region.\n    border_size : tuple[int, int, int]\n        Desired border size to add around chunk in voxels (z, y, x).\n    array_shape : tuple[int, int, int]\n        Shape of the full array (z, y, x).\n\n    Returns\n    -------\n    expanded_slice : tuple of slice\n        Slice objects defining the expanded chunk region (core + border).\n    actual_border_before : tuple[int, int, int]\n        Actual border size before the core chunk (z, y, x).\n        May be smaller than requested at array boundaries.\n    \"\"\"\n    # Extract core chunk boundaries\n    core_start = tuple(s.start for s in chunk_slice)\n    core_end = tuple(s.stop for s in chunk_slice)\n\n    # Calculate expanded slice (core + border, clipped to array boundaries)\n    expanded_start = tuple(max(0, core_start[i] - border_size[i]) for i in range(3))\n    expanded_end = tuple(\n        min(array_shape[i], core_end[i] + border_size[i]) for i in range(3)\n    )\n    expanded_slice = tuple(slice(expanded_start[i], expanded_end[i]) for i in range(3))\n\n    # Calculate actual border used (may be smaller at array edges)\n    actual_border_before = tuple(core_start[i] - expanded_start[i] for i in range(3))\n\n    return expanded_slice, actual_border_before\n</code></pre>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.calculate_expanded_slice(chunk_slice)","title":"<code>chunk_slice</code>","text":"(<code>tuple of slice</code>)           \u2013            <p>Slice objects defining the core chunk region.</p>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.calculate_expanded_slice(border_size)","title":"<code>border_size</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Desired border size to add around chunk in voxels (z, y, x).</p>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.calculate_expanded_slice(array_shape)","title":"<code>array_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of the full array (z, y, x).</p>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.get_boundary_slices","title":"get_boundary_slices","text":"<pre><code>get_boundary_slices(array_shape: tuple[int, int, int], chunk_shape: tuple[int, int, int]) -&gt; list[tuple[slice, slice, slice]]\n</code></pre> <p>Get slice objects for 2-voxel thick interfaces at chunk boundaries.</p> <p>For each boundary between chunks, returns a tuple of slice objects that selects a 2-voxel thick region: 1 voxel from the end of one chunk and 1 voxel from the beginning of the adjacent chunk.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[slice, slice, slice]]</code>           \u2013            <p>List of (slice, slice, slice) tuples for indexing boundary regions</p> </li> </ul> Source code in <code>skeleplex/utils/_chunked.py</code> <pre><code>def get_boundary_slices(\n    array_shape: tuple[int, int, int], chunk_shape: tuple[int, int, int]\n) -&gt; list[tuple[slice, slice, slice]]:\n    \"\"\"\n    Get slice objects for 2-voxel thick interfaces at chunk boundaries.\n\n    For each boundary between chunks, returns a tuple of slice objects that\n    selects a 2-voxel thick region: 1 voxel from the end of one chunk and\n    1 voxel from the beginning of the adjacent chunk.\n\n    Parameters\n    ----------\n    array_shape : tuple[int, int, int]\n        Shape of the array (z, y, x)\n    chunk_shape : tuple[int, int, int]\n        Shape of each chunk (z, y, x). All chunks are assumed to be the same size.\n\n    Returns\n    -------\n    list[tuple[slice, slice, slice]]\n        List of (slice, slice, slice) tuples for indexing boundary regions\n    \"\"\"\n    boundary_slices = []\n\n    # Iterate through each dimension (z=0, y=1, x=2)\n    for dim in range(3):\n        # Calculate number of chunks in this dimension\n        num_chunks = (array_shape[dim] + chunk_shape[dim] - 1) // chunk_shape[dim]\n\n        # Iterate through internal boundaries (between chunk n and chunk n+1)\n        for chunk_idx in range(1, num_chunks):\n            # Boundary position is at the start of chunk (chunk_idx)\n            boundary_pos = chunk_idx * chunk_shape[dim]\n\n            # Check if the 2-voxel interface fits within array bounds\n            if boundary_pos &gt; 0 and boundary_pos &lt; array_shape[dim]:\n                # Create slice tuple for this boundary\n                slices = [slice(None)] * 3  # Start with full slices for all dims\n\n                # Set the slice for the boundary dimension\n                # Take 1 voxel before and 1 voxel at the boundary\n                slices[dim] = slice(boundary_pos - 1, boundary_pos + 1)\n\n                boundary_slices.append(tuple(slices))\n\n    return boundary_slices\n</code></pre>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.get_boundary_slices(array_shape)","title":"<code>array_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of the array (z, y, x)</p>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.get_boundary_slices(chunk_shape)","title":"<code>chunk_shape</code>","text":"(<code>tuple[int, int, int]</code>)           \u2013            <p>Shape of each chunk (z, y, x). All chunks are assumed to be the same size.</p>"},{"location":"reference/skeleplex/utils/_chunked/#skeleplex.utils._chunked.iteratively_process_chunks_3d","title":"iteratively_process_chunks_3d","text":"<pre><code>iteratively_process_chunks_3d(input_array: Array, output_zarr: Array, function_to_apply: Callable[[ndarray], ndarray], chunk_shape: tuple[int, int, int], extra_border: tuple[int, int, int], *args, **kwargs)\n</code></pre> <p>Apply a function to each chunk of a Dask array with extra border handling.</p> no <p>input_array : dask.array.Array     The input Dask array to process. Must be 3D. output_zarr : zarr.Array     The output Zarr array to write results to.     Must have the same shape as input_array. function_to_apply : Callable[[np.ndarray], np.ndarray]     The function to apply to each chunk. chunk_shape : tuple[int, int, int]     The shape of each chunk to process. extra_border : tuple[int, int, int]     The extra border to include around each chunk. args     Additional positional arguments to pass to function_to_apply. *kwargs     Additional keyword arguments to pass to function_to_apply.</p> Source code in <code>skeleplex/utils/_chunked.py</code> <pre><code>def iteratively_process_chunks_3d(\n    input_array: da.Array,\n    output_zarr: zarr.Array,\n    function_to_apply: Callable[[np.ndarray], np.ndarray],\n    chunk_shape: tuple[int, int, int],\n    extra_border: tuple[int, int, int],\n    *args,\n    **kwargs,\n):\n    \"\"\"Apply a function to each chunk of a Dask array with extra border handling.\n\n    no\n    ----------\n    input_array : dask.array.Array\n        The input Dask array to process. Must be 3D.\n    output_zarr : zarr.Array\n        The output Zarr array to write results to.\n        Must have the same shape as input_array.\n    function_to_apply : Callable[[np.ndarray], np.ndarray]\n        The function to apply to each chunk.\n    chunk_shape : tuple[int, int, int]\n        The shape of each chunk to process.\n    extra_border : tuple[int, int, int]\n        The extra border to include around each chunk.\n    *args\n        Additional positional arguments to pass to function_to_apply.\n    **kwargs\n        Additional keyword arguments to pass to function_to_apply.\n    \"\"\"\n    # validate inputs before processing\n    if input_array.ndim != 3:\n        raise ValueError(f\"Input array must be 3D, got {input_array.ndim}D\")\n\n    if len(chunk_shape) != 3:\n        raise ValueError(\n            f\"chunk_shape must be a 3-tuple, got length {len(chunk_shape)}\"\n        )\n\n    if len(extra_border) != 3:\n        raise ValueError(\n            f\"extra_border must be a 3-tuple, got length {len(extra_border)}\"\n        )\n\n    # calculate the chunk grid\n    array_shape = input_array.shape\n    n_chunks = tuple(int(np.ceil(array_shape[i] / chunk_shape[i])) for i in range(3))\n\n    total_chunks = n_chunks[0] * n_chunks[1] * n_chunks[2]\n    with tqdm(total=total_chunks, desc=\"Processing chunks\") as pbar:\n        for i in range(n_chunks[0]):\n            for j in range(n_chunks[1]):\n                for k in range(n_chunks[2]):\n                    pbar.update(1)\n\n                    # calculate core chunk slice\n                    core_start = (\n                        i * chunk_shape[0],\n                        j * chunk_shape[1],\n                        k * chunk_shape[2],\n                    )\n                    core_end = (\n                        min((i + 1) * chunk_shape[0], array_shape[0]),\n                        min((j + 1) * chunk_shape[1], array_shape[1]),\n                        min((k + 1) * chunk_shape[2], array_shape[2]),\n                    )\n                    core_slice = tuple(\n                        slice(core_start[dim], core_end[dim]) for dim in range(3)\n                    )\n\n                    # calculate expanded slice (chunk + border)\n                    # clipped to array boundaries\n                    expanded_start = tuple(\n                        max(0, core_start[dim] - extra_border[dim]) for dim in range(3)\n                    )\n                    expanded_end = tuple(\n                        min(array_shape[dim], core_end[dim] + extra_border[dim])\n                        for dim in range(3)\n                    )\n                    expanded_slice = tuple(\n                        slice(expanded_start[dim], expanded_end[dim])\n                        for dim in range(3)\n                    )\n\n                    # calculate actual border used (may be smaller at edges)\n                    actual_border_before = tuple(\n                        core_start[dim] - expanded_start[dim] for dim in range(3)\n                    )\n\n                    # extract chunk + border and compute\n                    chunk_with_border = input_array[expanded_slice].compute()\n\n                    # apply function\n                    processed = function_to_apply(chunk_with_border, *args, **kwargs)\n\n                    # extend slice to match output_array_shape array dimensions\n                    core_in_result_slice = [\n                        slice(\n                            actual_border_before[dim],\n                            actual_border_before[dim]\n                            + (core_end[dim] - core_start[dim]),\n                        )\n                        for dim in range(3)\n                    ]\n\n                    # if the processed array has extra dims (e.g., channels/features),\n                    # extend the slice with full slices for those dimensions\n                    n_extra_dims = processed.ndim - 3\n                    # dimensions beyond the first 3\n                    if n_extra_dims &gt; 0:\n                        extra_slices = [\n                            slice(0, processed.shape[dim_idx])\n                            for dim_idx in range(n_extra_dims)\n                        ]\n\n                        # this is used to slice the processed array\n                        core_in_result_slice = extra_slices + core_in_result_slice\n                        # this is used slice the output array into which we write\n                        core_slice_extended = extra_slices + list(core_slice)\n                    else:\n                        # if no extra dims, just use the 3D slices\n                        core_slice_extended = list(core_slice)\n\n                    # convert back to tuple\n                    core_in_result_slice = tuple(core_in_result_slice)\n                    core_slice_extended = tuple(core_slice_extended)\n\n                    # check if end dimensions match input\n                    if processed.ndim != len(core_in_result_slice):\n                        raise ValueError(\n                            \"The output of function_to_apply has \"\n                            \"incompatible number of dimensions.\"\n                        )\n\n                    core_result = processed[core_in_result_slice]\n\n                    # write to Zarr\n                    output_zarr[core_slice_extended] = core_result\n</code></pre>"},{"location":"reference/skeleplex/utils/_geometry/","title":"_geometry","text":""},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry","title":"skeleplex.utils._geometry","text":"<p>Functions:</p> <ul> <li> <code>line_segments_in_aabb</code>             \u2013              <p>Get a boolean mask for line segments completely within an AABB.</p> </li> <li> <code>points_in_aabb</code>             \u2013              <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> </li> </ul>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb","title":"line_segments_in_aabb","text":"<pre><code>line_segments_in_aabb(line_segments: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Get a boolean mask for line segments completely within an AABB.</p> <p>A line segment is considered completely inside the bounding box if both its start and end points are within the bounding box (inclusive of boundaries).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_line_segments,) where True indicates line segments completely within the bounding box.</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def line_segments_in_aabb(\n    line_segments: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Get a boolean mask for line segments completely within an AABB.\n\n    A line segment is considered completely inside the bounding box if both\n    its start and end points are within the bounding box (inclusive of boundaries).\n\n    Parameters\n    ----------\n    line_segments : np.ndarray\n        (2 * n_line_segments, n_dim) array of line segment coordinates.\n        Line segment n goes from line_segments[2*n] to line_segments[2*n + 1].\n    min_bounds : np.ndarray\n        (n_dim,) array of the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array of the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_line_segments,) where True indicates\n        line segments completely within the bounding box.\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Calculate number of line segments\n    n_line_segments = line_segments.shape[0] // 2\n\n    # Reshape to separate start and end points: (n_line_segments, 2, 3)\n    segments_reshaped = line_segments.reshape(n_line_segments, 2, 3)\n\n    # Check if each point is within bounds\n    # Broadcasting: (n_line_segments, 2, 3) &gt;= (3,) -&gt; (n_line_segments, 2, 3)\n    within_min = np.all(segments_reshaped &gt;= min_bounds, axis=2)  # (n_line_segments, 2)\n    within_max = np.all(segments_reshaped &lt;= max_bounds, axis=2)  # (n_line_segments, 2)\n\n    # Both start and end points must be within bounds\n    points_in_bounds = within_min &amp; within_max  # (n_line_segments, 2)\n\n    # Line segment is completely inside if both points are inside\n    segments_completely_inside = np.all(points_in_bounds, axis=1)  # (n_line_segments,)\n\n    expanded_mask = np.repeat(segments_completely_inside, 2)  # (2 * n_line_segments,)\n\n    return expanded_mask\n</code></pre>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb(line_segments)","title":"<code>line_segments</code>","text":"(<code>ndarray</code>)           \u2013            <p>(2 * n_line_segments, n_dim) array of line segment coordinates. Line segment n goes from line_segments[2n] to line_segments[2n + 1].</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.line_segments_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array of the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb","title":"points_in_aabb","text":"<pre><code>points_in_aabb(coordinates: ndarray, min_bounds: ndarray, max_bounds: ndarray) -&gt; ndarray\n</code></pre> <p>Create a boolean mask for coordinates within an axis-aligned bounding box.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>mask</code> (              <code>ndarray</code> )          \u2013            <p>Boolean array with shape (n_coordinates,) where True indicates coordinates within the bounding box (inclusive of boundaries).</p> </li> </ul> Source code in <code>skeleplex/utils/_geometry.py</code> <pre><code>def points_in_aabb(\n    coordinates: np.ndarray,\n    min_bounds: np.ndarray,\n    max_bounds: np.ndarray,\n) -&gt; np.ndarray:\n    \"\"\"Create a boolean mask for coordinates within an axis-aligned bounding box.\n\n    Parameters\n    ----------\n    coordinates : np.ndarray\n        (n_coordinates, n_dim) array of point coordinates.\n    min_bounds : np.ndarray\n        (n_dim,) array with the minimum bounds of the bounding box.\n    max_bounds : np.ndarray\n        (n_dim,) array with the maximum bounds of the bounding box.\n\n    Returns\n    -------\n    mask : np.ndarray\n        Boolean array with shape (n_coordinates,) where True indicates\n        coordinates within the bounding box (inclusive of boundaries).\n\n    \"\"\"\n    # Check that min_bounds &lt;= max_bounds for each dimension\n    if np.any(min_bounds &gt; max_bounds):\n        raise ValueError(\"min_bounds must be &lt;= max_bounds for all dimensions\")\n\n    # Vectorized comparison: coordinates &gt;= min_bounds and coordinates &lt;= max_bounds\n    # Broadcasting handles the comparison across all coordinates simultaneously\n    within_min = np.all(coordinates &gt;= min_bounds, axis=1)\n    within_max = np.all(coordinates &lt;= max_bounds, axis=1)\n\n    # Return mask where both conditions are satisfied\n    return within_min &amp; within_max\n</code></pre>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb(coordinates)","title":"<code>coordinates</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_coordinates, n_dim) array of point coordinates.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb(min_bounds)","title":"<code>min_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the minimum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/utils/_geometry/#skeleplex.utils._geometry.points_in_aabb(max_bounds)","title":"<code>max_bounds</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_dim,) array with the maximum bounds of the bounding box.</p>"},{"location":"reference/skeleplex/visualize/","title":"visualize","text":""},{"location":"reference/skeleplex/visualize/#skeleplex.visualize","title":"skeleplex.visualize","text":"<p>Module for interactive visualization and curation of the skeleton.</p> <p>Modules:</p> <ul> <li> <code>spline</code>           \u2013            <p>Utilities for visualizing splines.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>EdgeColormap</code>           \u2013            <p>A colormap for edges in a graph.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>line_segment_coordinates_from_spline</code>             \u2013              <p>Get the coordinates for a line segment from a spline.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap","title":"EdgeColormap  <code>dataclass</code>","text":"<pre><code>EdgeColormap(colormap: dict[tuple[int, int], Color], default_color: Color)\n</code></pre> <p>A colormap for edges in a graph.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>colormap</code>               (<code>dict[tuple[int, int], Color]</code>)           \u2013            <p>A dictionary mapping edge keys (tuples of integers) to Color objects.</p> </li> <li> <code>default_color</code>               (<code>Color</code>)           \u2013            <p>The default color to use for edges not in the colormap.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>from_arrays</code>             \u2013              <p>Create an EdgeColormap from arrays.</p> </li> <li> <code>map_array</code>             \u2013              <p>Map an array of edge keys to an RGBA array.</p> </li> <li> <code>map_edge</code>             \u2013              <p>Map an edge key to an RGBA color.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap(colormap)","title":"<code>colormap</code>","text":"(<code>dict[tuple[int, int], Color]</code>)           \u2013            <p>The colormap mapping edge keys (tuples of integers) to Color objects. For information on how to specify the colors, see the cmap docs: https://cmap-docs.readthedocs.io/en/stable/colors/</p>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap(default_color)","title":"<code>default_color</code>","text":"(<code>Color</code>)           \u2013            <p>The color to use for edges not in the colormap.</p>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.from_arrays","title":"from_arrays  <code>classmethod</code>","text":"<pre><code>from_arrays(colormap: dict[tuple[int, int], ndarray], default_color: ndarray) -&gt; Self\n</code></pre> <p>Create an EdgeColormap from arrays.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EdgeColormap</code>           \u2013            <p>An instance of EdgeColormap.</p> </li> </ul> Source code in <code>skeleplex/visualize/_color.py</code> <pre><code>@classmethod\ndef from_arrays(\n    cls, colormap: dict[tuple[int, int], np.ndarray], default_color: np.ndarray\n) -&gt; Self:\n    \"\"\"Create an EdgeColormap from arrays.\n\n    Parameters\n    ----------\n    colormap : dict[tuple[int, int], np.ndarray]\n        A dictionary mapping edge keys (tuples of integers) to RGBA color arrays.\n        For information on how to specify the color as an RGBA, see the cmap docs:\n        https://cmap-docs.readthedocs.io/en/stable/colors/\n    default_color : np.ndarray\n        The default RGBA color as a numpy array.\n        This is the color used when an edge key is not found in the colormap.\n\n    Returns\n    -------\n    EdgeColormap\n        An instance of EdgeColormap.\n    \"\"\"\n    return cls(\n        colormap={k: Color(v) for k, v in colormap.items()},\n        default_color=Color(default_color),\n    )\n</code></pre>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.from_arrays(colormap)","title":"<code>colormap</code>","text":"(<code>dict[tuple[int, int], ndarray]</code>)           \u2013            <p>A dictionary mapping edge keys (tuples of integers) to RGBA color arrays. For information on how to specify the color as an RGBA, see the cmap docs: https://cmap-docs.readthedocs.io/en/stable/colors/</p>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.from_arrays(default_color)","title":"<code>default_color</code>","text":"(<code>ndarray</code>)           \u2013            <p>The default RGBA color as a numpy array. This is the color used when an edge key is not found in the colormap.</p>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.map_array","title":"map_array","text":"<pre><code>map_array(edge_key_array: ndarray) -&gt; ndarray\n</code></pre> <p>Map an array of edge keys to an RGBA array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(n_edges, 4) array of RGBA colors.</p> </li> </ul> Source code in <code>skeleplex/visualize/_color.py</code> <pre><code>def map_array(self, edge_key_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Map an array of edge keys to an RGBA array.\n\n    Parameters\n    ----------\n    edge_key_array : np.ndarray\n        (n_edges, 2) array of edge keys.\n\n    Returns\n    -------\n    np.ndarray\n        (n_edges, 4) array of RGBA colors.\n    \"\"\"\n    return np.array(\n        [self.map_edge(edge_key) for edge_key in edge_key_array],\n    )\n</code></pre>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.map_array(edge_key_array)","title":"<code>edge_key_array</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_edges, 2) array of edge keys.</p>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.map_edge","title":"map_edge","text":"<pre><code>map_edge(edge_key: tuple[int, int]) -&gt; tuple[float, float, float, float]\n</code></pre> <p>Map an edge key to an RGBA color.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float, float]</code>           \u2013            <p>The RGBA color.</p> </li> </ul> Source code in <code>skeleplex/visualize/_color.py</code> <pre><code>def map_edge(self, edge_key: tuple[int, int]) -&gt; tuple[float, float, float, float]:\n    \"\"\"Map an edge key to an RGBA color.\n\n    Parameters\n    ----------\n    edge_key : tuple[int, int]\n        The edge key as a tuple of two integers.\n\n    Returns\n    -------\n    tuple[float, float, float, float]\n        The RGBA color.\n    \"\"\"\n    if not isinstance(edge_key, tuple):\n        # coerce to tuple\n        edge_key = (int(edge_key[0]), int(edge_key[1]))\n    color = self.colormap.get(edge_key, self.default_color)\n    return color.rgba\n</code></pre>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.EdgeColormap.map_edge(edge_key)","title":"<code>edge_key</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The edge key as a tuple of two integers.</p>"},{"location":"reference/skeleplex/visualize/#skeleplex.visualize.line_segment_coordinates_from_spline","title":"line_segment_coordinates_from_spline","text":"<pre><code>line_segment_coordinates_from_spline(spline: B3Spline, n_line_segments: int = 3) -&gt; ndarray\n</code></pre> <p>Get the coordinates for a line segment from a spline.</p> Source code in <code>skeleplex/visualize/spline.py</code> <pre><code>def line_segment_coordinates_from_spline(\n    spline: B3Spline,\n    n_line_segments: int = 3,\n) -&gt; np.ndarray:\n    \"\"\"Get the coordinates for a line segment from a spline.\"\"\"\n    n_knots = len(spline.model.knots)\n    t = np.linspace(0, n_knots - 1, n_line_segments + 1, endpoint=True)\n\n    spline_coordinates = spline.model.eval(t)\n\n    line_coordinates = np.empty((2 * n_line_segments, 3))\n    line_coordinates[::2] = spline_coordinates[:-1]\n    line_coordinates[1::2] = spline_coordinates[1:]\n\n    return line_coordinates\n</code></pre>"},{"location":"reference/skeleplex/visualize/_color/","title":"_color","text":""},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color","title":"skeleplex.visualize._color","text":"<p>Classes:</p> <ul> <li> <code>EdgeColormap</code>           \u2013            <p>A colormap for edges in a graph.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap","title":"EdgeColormap  <code>dataclass</code>","text":"<pre><code>EdgeColormap(colormap: dict[tuple[int, int], Color], default_color: Color)\n</code></pre> <p>A colormap for edges in a graph.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>colormap</code>               (<code>dict[tuple[int, int], Color]</code>)           \u2013            <p>A dictionary mapping edge keys (tuples of integers) to Color objects.</p> </li> <li> <code>default_color</code>               (<code>Color</code>)           \u2013            <p>The default color to use for edges not in the colormap.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>from_arrays</code>             \u2013              <p>Create an EdgeColormap from arrays.</p> </li> <li> <code>map_array</code>             \u2013              <p>Map an array of edge keys to an RGBA array.</p> </li> <li> <code>map_edge</code>             \u2013              <p>Map an edge key to an RGBA color.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap(colormap)","title":"<code>colormap</code>","text":"(<code>dict[tuple[int, int], Color]</code>)           \u2013            <p>The colormap mapping edge keys (tuples of integers) to Color objects. For information on how to specify the colors, see the cmap docs: https://cmap-docs.readthedocs.io/en/stable/colors/</p>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap(default_color)","title":"<code>default_color</code>","text":"(<code>Color</code>)           \u2013            <p>The color to use for edges not in the colormap.</p>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.from_arrays","title":"from_arrays  <code>classmethod</code>","text":"<pre><code>from_arrays(colormap: dict[tuple[int, int], ndarray], default_color: ndarray) -&gt; Self\n</code></pre> <p>Create an EdgeColormap from arrays.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EdgeColormap</code>           \u2013            <p>An instance of EdgeColormap.</p> </li> </ul> Source code in <code>skeleplex/visualize/_color.py</code> <pre><code>@classmethod\ndef from_arrays(\n    cls, colormap: dict[tuple[int, int], np.ndarray], default_color: np.ndarray\n) -&gt; Self:\n    \"\"\"Create an EdgeColormap from arrays.\n\n    Parameters\n    ----------\n    colormap : dict[tuple[int, int], np.ndarray]\n        A dictionary mapping edge keys (tuples of integers) to RGBA color arrays.\n        For information on how to specify the color as an RGBA, see the cmap docs:\n        https://cmap-docs.readthedocs.io/en/stable/colors/\n    default_color : np.ndarray\n        The default RGBA color as a numpy array.\n        This is the color used when an edge key is not found in the colormap.\n\n    Returns\n    -------\n    EdgeColormap\n        An instance of EdgeColormap.\n    \"\"\"\n    return cls(\n        colormap={k: Color(v) for k, v in colormap.items()},\n        default_color=Color(default_color),\n    )\n</code></pre>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.from_arrays(colormap)","title":"<code>colormap</code>","text":"(<code>dict[tuple[int, int], ndarray]</code>)           \u2013            <p>A dictionary mapping edge keys (tuples of integers) to RGBA color arrays. For information on how to specify the color as an RGBA, see the cmap docs: https://cmap-docs.readthedocs.io/en/stable/colors/</p>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.from_arrays(default_color)","title":"<code>default_color</code>","text":"(<code>ndarray</code>)           \u2013            <p>The default RGBA color as a numpy array. This is the color used when an edge key is not found in the colormap.</p>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.map_array","title":"map_array","text":"<pre><code>map_array(edge_key_array: ndarray) -&gt; ndarray\n</code></pre> <p>Map an array of edge keys to an RGBA array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>(n_edges, 4) array of RGBA colors.</p> </li> </ul> Source code in <code>skeleplex/visualize/_color.py</code> <pre><code>def map_array(self, edge_key_array: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Map an array of edge keys to an RGBA array.\n\n    Parameters\n    ----------\n    edge_key_array : np.ndarray\n        (n_edges, 2) array of edge keys.\n\n    Returns\n    -------\n    np.ndarray\n        (n_edges, 4) array of RGBA colors.\n    \"\"\"\n    return np.array(\n        [self.map_edge(edge_key) for edge_key in edge_key_array],\n    )\n</code></pre>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.map_array(edge_key_array)","title":"<code>edge_key_array</code>","text":"(<code>ndarray</code>)           \u2013            <p>(n_edges, 2) array of edge keys.</p>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.map_edge","title":"map_edge","text":"<pre><code>map_edge(edge_key: tuple[int, int]) -&gt; tuple[float, float, float, float]\n</code></pre> <p>Map an edge key to an RGBA color.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float, float]</code>           \u2013            <p>The RGBA color.</p> </li> </ul> Source code in <code>skeleplex/visualize/_color.py</code> <pre><code>def map_edge(self, edge_key: tuple[int, int]) -&gt; tuple[float, float, float, float]:\n    \"\"\"Map an edge key to an RGBA color.\n\n    Parameters\n    ----------\n    edge_key : tuple[int, int]\n        The edge key as a tuple of two integers.\n\n    Returns\n    -------\n    tuple[float, float, float, float]\n        The RGBA color.\n    \"\"\"\n    if not isinstance(edge_key, tuple):\n        # coerce to tuple\n        edge_key = (int(edge_key[0]), int(edge_key[1]))\n    color = self.colormap.get(edge_key, self.default_color)\n    return color.rgba\n</code></pre>"},{"location":"reference/skeleplex/visualize/_color/#skeleplex.visualize._color.EdgeColormap.map_edge(edge_key)","title":"<code>edge_key</code>","text":"(<code>tuple[int, int]</code>)           \u2013            <p>The edge key as a tuple of two integers.</p>"},{"location":"reference/skeleplex/visualize/spline/","title":"spline","text":""},{"location":"reference/skeleplex/visualize/spline/#skeleplex.visualize.spline","title":"skeleplex.visualize.spline","text":"<p>Utilities for visualizing splines.</p> <p>Functions:</p> <ul> <li> <code>line_segment_coordinates_from_spline</code>             \u2013              <p>Get the coordinates for a line segment from a spline.</p> </li> </ul>"},{"location":"reference/skeleplex/visualize/spline/#skeleplex.visualize.spline.line_segment_coordinates_from_spline","title":"line_segment_coordinates_from_spline","text":"<pre><code>line_segment_coordinates_from_spline(spline: B3Spline, n_line_segments: int = 3) -&gt; ndarray\n</code></pre> <p>Get the coordinates for a line segment from a spline.</p> Source code in <code>skeleplex/visualize/spline.py</code> <pre><code>def line_segment_coordinates_from_spline(\n    spline: B3Spline,\n    n_line_segments: int = 3,\n) -&gt; np.ndarray:\n    \"\"\"Get the coordinates for a line segment from a spline.\"\"\"\n    n_knots = len(spline.model.knots)\n    t = np.linspace(0, n_knots - 1, n_line_segments + 1, endpoint=True)\n\n    spline_coordinates = spline.model.eval(t)\n\n    line_coordinates = np.empty((2 * n_line_segments, 3))\n    line_coordinates[::2] = spline_coordinates[:-1]\n    line_coordinates[1::2] = spline_coordinates[1:]\n\n    return line_coordinates\n</code></pre>"}]}