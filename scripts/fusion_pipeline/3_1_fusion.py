"""Fusion Part 3.1: Generate Optimal Tree from Scale Mapped Skeleton Predictions."""

##################################################################################################
#                                           IMPORTS
##################################################################################################
import time

import dask.array as da
import numpy as np

##################################################################################################
#                                           FUNCTIONS
##################################################################################################


def optimal_tree_generator(
    scale_map: np.ndarray,
    image: np.ndarray,
    scale_ranges: dict,
    scaled_images_dict: dict,
) -> np.ndarray:
    """
    Generate Optimal Tree.

    Fuse the re-scaled skeleton predictions together to
    form the "optimal tree". The fused skeleton prediction
    ("optimal tree") is generated by using the scale map
    to guide which scale's skeleton prediction to
    use at each voxel.

    Parameters
    ----------
    scale_map : np.ndarray
        Array with non-zero values documenting the scale of
        each voxel in the segmentation.
    image : np.array
        original image that serves as the mask guide
    scale_ranges : dict
        This dictionary is used to map the scales to the radii
        in the radius_map.
    scaled_images_dict : dict
        Dictionary containing all re-scaled skeleton predictions.

    Returns
    -------
    np.ndarray
        Array of same shape as input image, containing
        scale mapped values.

    """
    optimal_tree = da.zeros_like(image, dtype=image.dtype)

    for key in scale_ranges.keys():
        scale_number = key

        mask = scale_map == scale_number
        name = f"{image_prefix}_image_skeletonized_rescaled_from_{scale_number}"
        print(name)

        scaled_images_dict[name] = scaled_images_dict[name].rechunk(scale_map.chunks)
        optimal_tree = da.where(mask, scaled_images_dict[name], optimal_tree)

    optimal_tree.to_zarr(f"data/{image_prefix}_optimal_tree.zarr", overwrite=True)
    return optimal_tree


##################################################################################################
#                                           RUNNING FUSION
##################################################################################################

# Define the image prefix used to name the files
image_prefix = "IMAGE_PREFIX"  # ADAPT HERE

# Example: define scales and their valid ranges
scale_ranges_manual = {
    0: (1, 5),
    -1: (5, 12),
    -2: (12, 30),
    -3: (30, 150),
}  # ADAPT HERE

# Load the initial image (here: label)
lung_image = da.from_zarr(f"data/{image_prefix}.zarr")  # ADAPT HERE
lung_image = lung_image.rechunk((192, 192, 192))


################ From fusion Part 1 ################
start_time1 = time.time()

# Load Scale Map
lung_image_scale_map = da.from_zarr(
    f"data/{image_prefix}_image_scale_map.zarr/scale_original"
)
lung_image_scale_map = lung_image_scale_map.rechunk((192, 192, 192))


################ From fusion Part 2 ################

# Load rescaled images to combine rescaled images via scale map
multiscale_images = {}
for key in scale_ranges_manual.keys():
    scale_number = key
    image = da.from_zarr(
        f"data/{image_prefix}_skeletonized_rescaled.zarr/origin_scale{scale_number}"
    )
    image = image.rechunk((192, 192, 192))
    name = f"{image_prefix}_image_skeletonized_rescaled_from_{scale_number}"
    print(name)
    multiscale_images[name] = image

print(f"--- Loading all images took {time.time() - start_time1} seconds ---")

################ Fusion Part 3 ################
start_time2 = time.time()
# Combine resclaed images to one via scale map: generate optimal tree
lung_image_optimum = optimal_tree_generator(
    lung_image_scale_map, lung_image, scale_ranges_manual, multiscale_images
)
lung_image_optimum = lung_image_optimum.rechunk((192, 192, 192))
print(f"--- Generating optimal tree took {time.time() - start_time2} seconds ---")
